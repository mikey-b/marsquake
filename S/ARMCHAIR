; armchair
;
; The assembly langauge part of project MQ2
;
; (C) Paul Taylor 1996
;
; Code started 3/3/96
;
; NB. File best viewed with line width >=100
;
; As from 20/12/96, tile extra1 is bomb link, extra2 is enemy link.

r0		RN	0
r1		RN	1
r2		RN	2
r3		RN	3
r4		RN	4
r5		RN	5
r6		RN	6
r7		RN	7
r8		RN	8
r9		RN	9
r10		RN	10
r11		RN	11
r12		RN	12
r13		RN	13
r14             RN      14
pc              RN      15

vis_tiles_v	*	13
vis_tiles_h	*	19
dsym_swi_chunk	*	&45880

blockage_score	*	25

	AREA    |armchair|, CODE

	IMPORT	floor_map	; data structure for floor org/status
	IMPORT	floor_tiles	; gfx data block for floor tiles
	IMPORT	scrmem		; screen memory start address
	IMPORT	scrmem_arena	; screen memory start address
	IMPORT	expl_gfx	; explosion overlay graphics


draw_floor_data
	DCD	floor_map
	DCD	floor_tiles
	DCD	scrmem_arena
	DCD	expl_gfx

	EXPORT	draw_floor_data
draw_floor
	EXPORT draw_floor

	; parameters :
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - floorsize - vertical size of floor, in tiles.
	;	r2 - floor gfx address

	STMFD	r13!,{r0-r12,r14}	; Save regs

	ADR	r2,draw_floor_data
	LDMIA	r2,{r2,r3,r6}
	LDR	r6,[r6,#0]		; load variables

	ADD	r2,r2,#33*16		; skip sentinel tiles on map (TDC)

	; bottom 8 bits of global_y (r0) contain the fraction within a tile. The tiles are only
	; 16x16 pixels, so this gives us an accuracy to 1/16th of a pixel. If there is a hi-res
	; RPC mode (640x512) we can have 32x32 tiles, giving 1/8th pixel accuracy.

	MOV	r4,r0,LSR#4
	AND	r4,r4,#15		; get pixel offset within top row

	MOV	r0,r0,LSR#8		; get tile row offset

	MOV	r5,r4,LSL#4		; calc offset within single tile gfx

        ; r0 - first on screen tile row
	; r1 - max tile row
	; r2 - floor map data structure pointer
	; r3 - floor tiles gfx
	; r4 - pixel offset within tile
	; r5 - offset within gfx data to skip part of tile not on screen
	; r6 - start of screen memory

	; If the top row is not entirely visible (scroll is underway -> r4 != 0) draw top
	; row of tiles

	CMP	r4,#0                   ; no scroll ?
	MOVEQ	r7,#vis_tiles_v		; no - draw all vis_tiles_v rows
	BEQ	draw_floor_full_tiles	; and just draw those

	; draw partially visible top row

	STMFD	r13!,{r0,r1,r2,r4}	; free a few regs

	RSB	r4,r4,#16		; number of pixel lines to draw

	ADD	r2,r2,r0,LSL#9		; skip 32*16bytes per map line (TDC)

	MOV	r0,#vis_tiles_h		; tile count

	MOV	r7,r6			; save screen pointer

draw_floor_top_partial
	; r0  - tile counter
	; r2  - points to next map data entry
	; r3  - tile gfx data
	; r4  - number of pixel lines to draw
	; r5  - offset within tile pixel data to start reading from
	; r6  - screen memory pointer
	; r7  - screen pointer saved
	; r1,r8-r12,r14 free

	LDRB	r1,[r2,#1]		; load sprite reference number for next tile
	ADD	r1,r3,r1,LSL#8		; find address of that tiles pixel data
	ADD	r1,r1,r5		; skip top part of tile

	MOV	r8,r4			; line counter
	MOV	r14,r6			; screen pointer

partial_top_tile
	LDMIA	r1!,{r9-r12}		; load line of tile
	STMIA	r14,{r9-r12}		; write line to screen

	ADD	r14,r14,#320		; move down to next line

	SUBS	r8,r8,#1		; decrement line counter
	BNE	partial_top_tile	; continue until tile is complete

	LDRB	r1,[r2,#7]		; overlay sprite?
	CMP	r1,#0
	BEQ	partial_top_cont	; no - goto next tile

	; Ok, we've got to overlay an explosion sprite - what registers do we have?
	; r0  - tile counter
	; r1  - which sprite to overlay
	; r2  - points to next map data entry
	; r3  - tile gfx data
	; r4  - number of pixel lines to draw
	; r5  - offset within tile pixel data to start reading from
	; r6  - screen memory pointer
	; r7  - screen pointer saved
	; r1,r8-r12,r14 free

	LDR	r8,draw_floor_data+12	; get explosion overlay graphics address

	SUB	r1,r1,#64		; overlay counts from 64...
	ADD	r1,r8,r1,LSL#8		; 256 bytes per overlay
	ADD	r1,r1,r5		; skip hidden part of overlay

	STMFD	r13!,{r6,r7}		; free up two regs.

	MOV	r7,#255			; byte mask

	MOV	r8,r6			; screen addr
	MOV	r14,r4

drawpoverlay_pixel_line
	LDMIA	r1!,{r9-r12}		; get pixel line

	ANDS	r6,r7,r9		; get 1st pixel
	STRNEB	r6,[r8,#0]		; draw if not background

	ANDS	r6,r7,r9,LSR#8		; get 2nd pixel
	STRNEB	r6,[r8,#1]		; draw if not background

	ANDS	r6,r7,r9,LSR#16		; get 3rd pixel
	STRNEB	r6,[r8,#2]		; draw if not background

	ANDS	r6,r7,r9,LSR#24		; get 4th pixel
	STRNEB	r6,[r8,#3]		; draw if not background

	ANDS	r6,r7,r10		; get 5th pixel
	STRNEB	r6,[r8,#4]		; draw if not background

	ANDS	r6,r7,r10,LSR#8		; get 6th pixel
	STRNEB	r6,[r8,#5]		; draw if not background

	ANDS	r6,r7,r10,LSR#16	; get 7th pixel
	STRNEB	r6,[r8,#6]		; draw if not background

	ANDS	r6,r7,r10,LSR#24	; get 8th pixel
	STRNEB	r6,[r8,#7]		; draw if not background

	ANDS	r6,r7,r11		; get 9th pixel
	STRNEB	r6,[r8,#8]		; draw if not background

	ANDS	r6,r7,r11,LSR#8		; get 10th pixel
	STRNEB	r6,[r8,#9]		; draw if not background

	ANDS	r6,r7,r11,LSR#16	; get 11th pixel
	STRNEB	r6,[r8,#10]		; draw if not background

	ANDS	r6,r7,r11,LSR#24	; get 12th pixel
	STRNEB	r6,[r8,#11]		; draw if not background

	ANDS	r6,r7,r12		; get 13th pixel
	STRNEB	r6,[r8,#12]		; draw if not background

	ANDS	r6,r7,r12,LSR#8		; get 14th pixel
	STRNEB	r6,[r8,#13]		; draw if not background

	ANDS	r6,r7,r12,LSR#16	; get 15th pixel
	STRNEB	r6,[r8,#14]		; draw if not background

	ANDS	r6,r7,r12,LSR#24	; get 16th pixel
	STRNEB	r6,[r8,#15]		; draw if not background

	ADD	r8,r8,#320
	SUBS	r14,r14,#1		; finished row - any more?
	BNE	drawpoverlay_pixel_line	; continue until done.

	LDMFD	r13!,{r6,r7}


partial_top_cont
	ADD	r2,r2,#16		; move to next tile in map data (TDC)
	ADD	r6,r6,#16		; move to next tile on screen

	SUBS	r0,r0,#1		; decrement tile counter
	BNE	draw_floor_top_partial	; continue until top line is complete

	MOV	r6,r7
	ADD	r6,r6,r4,LSL#8
	ADD	r6,r6,r4,LSL#6		; set screen pointer to beginning of next tile row

	LDMFD	r13!,{r0,r1,r2,r4}	; restore regs

	ADD	r0,r0,#1		; move to next line on map

	MOV	r7,#vis_tiles_v-1	; one less full row than when no partial rows

draw_floor_full_tiles
	; r0 - tile row
	; r1 - max tile row	- what are we going to do with this...? Preprocess, I think!
	; r2 - floor map data structure pointer
	; r3 - floor tiles gfx
	; r4 - pixel offset within tile
	; r5 - offset within gfx data to skip part of tile not on screen
	; r6 - start of screen memory
	; r7 - number of full rows left to draw

	STMFD	r13!,{r0,r2,r4,r7}	; free a few regs

	MOV	r4,#16			; number of pixel lines to draw

	ADD	r2,r2,r0,LSL#9		; skip 32*16bytes per map line (TDC)

	MOV	r0,#vis_tiles_h		; tile count

	MOV	r7,r6			; save screen pointer

draw_floor_full_row
	LDRB	r1,[r2,#1]		; load sprite reference number for next tile
	ADD	r1,r3,r1,LSL#8		; find address of that tiles pixel data

	MOV	r8,r4			; line counter
	MOV	r14,r6			; screen pointer

full_tile_line
	LDMIA	r1!,{r9-r12}		; load line of tile
	STMIA	r14,{r9-r12}		; write line to screen

	ADD	r14,r14,#320		; move down to next line

	SUBS	r8,r8,#1		; decrement line counter
	BNE	full_tile_line		; continue until tile is complete

	LDRB	r1,[r2,#7]		; overlay sprite?
	CMP	r1,#0
	BEQ	full_cont		; no - goto next tile

	; Ok, we've got to overlay an explosion sprite - what registers do we have?
	; r0 - tile row
	; r1 - overlay sprite
	; r2 - floor map data structure pointer
	; r3 - floor tiles gfx
	; r4 - pixel offset within tile
	; r5 - offset within gfx data to skip part of tile not on screen
	; r6 - start of screen memory
	; r7 - number of full rows left to draw

	LDR	r8,draw_floor_data+12	; get explosion overlay graphics address

	SUB	r1,r1,#64		; overlay counts from 64...
	ADD	r1,r8,r1,LSL#8		; 256 bytes per overlay

	STMFD	r13!,{r6,r7}		; free up two regs.

	MOV	r7,#255			; byte mask

	MOV	r8,r6			; screen addr
	MOV	r14,r4

drawoverlay_pixel_line
	LDMIA	r1!,{r9-r12}		; get pixel line

	ANDS	r6,r7,r9		; get 1st pixel
	STRNEB	r6,[r8,#0]		; draw if not background

	ANDS	r6,r7,r9,LSR#8		; get 2nd pixel
	STRNEB	r6,[r8,#1]		; draw if not background

	ANDS	r6,r7,r9,LSR#16		; get 3rd pixel
	STRNEB	r6,[r8,#2]		; draw if not background

	ANDS	r6,r7,r9,LSR#24		; get 4th pixel
	STRNEB	r6,[r8,#3]		; draw if not background

	ANDS	r6,r7,r10		; get 5th pixel
	STRNEB	r6,[r8,#4]		; draw if not background

	ANDS	r6,r7,r10,LSR#8		; get 6th pixel
	STRNEB	r6,[r8,#5]		; draw if not background

	ANDS	r6,r7,r10,LSR#16	; get 7th pixel
	STRNEB	r6,[r8,#6]		; draw if not background

	ANDS	r6,r7,r10,LSR#24	; get 8th pixel
	STRNEB	r6,[r8,#7]		; draw if not background

	ANDS	r6,r7,r11		; get 9th pixel
	STRNEB	r6,[r8,#8]		; draw if not background

	ANDS	r6,r7,r11,LSR#8		; get 10th pixel
	STRNEB	r6,[r8,#9]		; draw if not background

	ANDS	r6,r7,r11,LSR#16	; get 11th pixel
	STRNEB	r6,[r8,#10]		; draw if not background

	ANDS	r6,r7,r11,LSR#24	; get 12th pixel
	STRNEB	r6,[r8,#11]		; draw if not background

	ANDS	r6,r7,r12		; get 13th pixel
	STRNEB	r6,[r8,#12]		; draw if not background

	ANDS	r6,r7,r12,LSR#8		; get 14th pixel
	STRNEB	r6,[r8,#13]		; draw if not background

	ANDS	r6,r7,r12,LSR#16	; get 15th pixel
	STRNEB	r6,[r8,#14]		; draw if not background

	ANDS	r6,r7,r12,LSR#24	; get 16th pixel
	STRNEB	r6,[r8,#15]		; draw if not background

	ADD	r8,r8,#320
	SUBS	r14,r14,#1		; finished row - any more?
	BNE	drawoverlay_pixel_line	; continue until done.

	LDMFD	r13!,{r6,r7}

full_cont
	; DEBUG!!
;	LDRB	r1,[r2,#3]
;	TST	r1,#1<<7
;	BEQ	no_debug_num_to_show

	; Show number r1&63 on screen at this tile location (r6)
;	STMFD	r13!,{r0,r1,r2,r14}

;	ADR	r2,debug_hex
;	AND	r0,r1,#&30		; nme number high digit
;	MOV	r0,r0,LSR#4
;	LDRB	r0,[r2,r0]		; get hex digit
;	STRB	r0,debug_num_str	; store in string
;	AND	r0,r1,#&f		; nme number low digit
;	LDRB	r0,[r2,r0]		; get hex digit
;	STRB	r0,debug_num_str+1	; store in string
;	MOV	r0,#0			; eol char
;	STRB	r0,debug_num_str+2	; store in string

;	ADR	r0,debug_num_str	; address of string
;	MOV	r1,r6			; screen address for string
;	BL	draw_small_string_addr	; draw it

;	LDMFD	r13!,{r0,r1,r2,r14}	; restore registers

;	B	no_debug_num_to_show	; and continue...
;debug_hex
;	DCB	'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
;debug_num_str
;	DCD	0

;no_debug_num_to_show
	ADD	r2,r2,#16		; move to next tile in map data (TDC)
	ADD	r6,r6,#16		; move to next tile on screen

	SUBS	r0,r0,#1		; decrement tile counter
	BNE	draw_floor_full_row	; continue until top line is complete

	MOV	r6,r7
	ADD	r6,r6,r4,LSL#8
	ADD	r6,r6,r4,LSL#6		; set screen pointer to beginning of next tile row

	LDMFD	r13!,{r0,r2,r4,r7}	; restore regs

	ADD	r0,r0,#1		; move to next row

	SUBS	r7,r7,#1		; decrement row counter
	BNE	draw_floor_full_tiles	; until there's no more rows to draw

	CMP	r4,#0			; any scroll?
	BEQ	draw_floor_exit		; no - go to exit

	; must draw partial bottom row
        ; r4 contains the number of pixel lines to draw

	ADD	r2,r2,r0,LSL#9		; skip 32*16bytes per map line (TDC)

	MOV	r0,#vis_tiles_h		; tile count

	MOV	r7,r6			; save screen pointer

draw_floor_bottom_row
	LDRB	r1,[r2,#1]		; load sprite reference number for next tile
	ADD	r1,r3,r1,LSL#8		; find address of that tiles pixel data

	MOV	r8,r4			; line counter
	MOV	r14,r6			; screen pointer

bottom_tile_line
	LDMIA	r1!,{r9-r12}		; load line of tile
	STMIA	r14,{r9-r12}		; write line to screen

	ADD	r14,r14,#320		; move down to next line

	SUBS	r8,r8,#1		; decrement line counter
	BNE	bottom_tile_line	; continue until tile is complete

	LDRB	r1,[r2,#7]		; overlay sprite?
	CMP	r1,#0
	BEQ	bottom_cont		; no - goto next tile

	; Ok, we've got to overlay an explosion sprite - what registers do we have?
	; r0 - tile row
	; r1 - overlay sprite
	; r2 - floor map data structure pointer
	; r3 - floor tiles gfx
	; r4 - pixel offset within tile
	; r5 - offset within gfx data to skip part of tile not on screen
	; r6 - start of screen memory
	; r7 - number of full rows left to draw

	LDR	r8,draw_floor_data+12	; get explosion overlay graphics address

	SUB	r1,r1,#64		; overlay counts from 64...
	ADD	r1,r8,r1,LSL#8		; 256 bytes per overlay

	STMFD	r13!,{r6,r7}		; free up two regs.

	MOV	r7,#255			; byte mask

	MOV	r8,r6			; screen addr
	MOV	r14,r4

drawboverlay_pixel_line
	LDMIA	r1!,{r9-r12}		; get pixel line

	ANDS	r6,r7,r9		; get 1st pixel
	STRNEB	r6,[r8,#0]		; draw if not background

	ANDS	r6,r7,r9,LSR#8		; get 2nd pixel
	STRNEB	r6,[r8,#1]		; draw if not background

	ANDS	r6,r7,r9,LSR#16		; get 3rd pixel
	STRNEB	r6,[r8,#2]		; draw if not background

	ANDS	r6,r7,r9,LSR#24		; get 4th pixel
	STRNEB	r6,[r8,#3]		; draw if not background

	ANDS	r6,r7,r10		; get 5th pixel
	STRNEB	r6,[r8,#4]		; draw if not background

	ANDS	r6,r7,r10,LSR#8		; get 6th pixel
	STRNEB	r6,[r8,#5]		; draw if not background

	ANDS	r6,r7,r10,LSR#16	; get 7th pixel
	STRNEB	r6,[r8,#6]		; draw if not background

	ANDS	r6,r7,r10,LSR#24	; get 8th pixel
	STRNEB	r6,[r8,#7]		; draw if not background

	ANDS	r6,r7,r11		; get 9th pixel
	STRNEB	r6,[r8,#8]		; draw if not background

	ANDS	r6,r7,r11,LSR#8		; get 10th pixel
	STRNEB	r6,[r8,#9]		; draw if not background

	ANDS	r6,r7,r11,LSR#16	; get 11th pixel
	STRNEB	r6,[r8,#10]		; draw if not background

	ANDS	r6,r7,r11,LSR#24	; get 12th pixel
	STRNEB	r6,[r8,#11]		; draw if not background

	ANDS	r6,r7,r12		; get 13th pixel
	STRNEB	r6,[r8,#12]		; draw if not background

	ANDS	r6,r7,r12,LSR#8		; get 14th pixel
	STRNEB	r6,[r8,#13]		; draw if not background

	ANDS	r6,r7,r12,LSR#16	; get 15th pixel
	STRNEB	r6,[r8,#14]		; draw if not background

	ANDS	r6,r7,r12,LSR#24	; get 16th pixel
	STRNEB	r6,[r8,#15]		; draw if not background

	ADD	r8,r8,#320
	SUBS	r14,r14,#1		; finished row - any more?
	BNE	drawboverlay_pixel_line	; continue until done.

	LDMFD	r13!,{r6,r7}

bottom_cont
	ADD	r2,r2,#16		; move to next tile in map data (TDC)
	ADD	r6,r6,#16		; move to next tile on screen

	SUBS	r0,r0,#1		; decrement tile counter
	BNE	draw_floor_bottom_row	; continue until top line is complete

draw_floor_exit
	; We've finished here -> let's exit

	LDMFD	r13!,{r0-r12,pc}

;----------------------------------------------------------------------------
; Advanced explosion graphics
;
; Part 1 (of how many?) - 48x48 pixel overlayed sprite at centre of explosion
;
; Scan grid from (global_y>>8)-1
;	    to   (global_y>>8)+1+vis_tiles_h
;

	IMPORT	bexpl_gfx
	IMPORT	flour_gfx
	IMPORT	flour_array

adv_exp_data
	DCD	floor_map
	DCD	scrmem_arena
	DCD	bexpl_gfx

draw_adv_exp
	EXPORT	draw_adv_exp

	STMFD	r13!,{r0-r12,r14}

	; On entry, r0 contains global_y

	BIC	r1,r0,#255
	SUB	r1,r1,#768

	; r1 = actual y big explosion will start drawing at

	MOV	r2,r0,ASR#8
	SUB	r2,r2,#1		; r2 = map tile row to start scan on

	ADR	r3,adv_exp_data
	LDMIA	r3,{r3-r5}		; load variables
	LDR	r4,[r4,#0]		; get screen address

	ADD	r3,r3,r2,LSL#9		; Move to start of map row
	MOV	r9,#(vis_tiles_v+2)	; Number of rows to scan

adv_scan_y
	MOV	r6,#vis_tiles_h+1
	MOV	r7,r3			; store current map row position

adv_scan_x
	LDRB	r8,[r3,#4]		; get blast details
	CMP	r8,#9+16		; explosion centre?

	;LDR	r12,plotdbug
	;ADD	r12,r12,#1
	;STR	r12,plotdbug		; test how many explosions are being drawn

	BLEQ	adv_exp_plot		; yes - draw it

	ADD	r3,r3,#16		; next tile
	SUBS	r6,r6,#1		; end of row?
	BNE	adv_scan_x		; no - continue loop

	ADD	r3,r7,#512		; move to next row
	ADD	r1,r1,#256
	SUBS	r9,r9,#1		; all necessary rows scanned?
	BNE	adv_scan_y		; no - continue loop

	; Scan and draw complete - exit

	LDMFD	r13!,{r0-r12,pc}

plotdbug
	EXPORT	plotdbug
	DCD	42

adv_exp_plot
	; On entry,
	;	r0  =	global_y
	;	r1  =	global_y scale position of top of big explosion
	;	r3  =	address of current tile data
	;	r4  =	screen memory start
	; 	r5  =	big explosion graphics data
	;	r6  =	vis_tiles_h-r6 = x position of tile on map
	;	r7  =   address of start of map row
	;	r9  =   no use here, but must be preserved
	;	r2, r8, r10-r12 = available for use
	;	r14 =   return address

	STMFD	r13!,{r1,r3,r4,r5,r6,r7,r9,r14}

	; Find start of pixel data

	RSB	r6,r6,#vis_tiles_h+1	; calc column number

	SUB	r6,r6,#1

	CMP	r6,#0
	CMPNE	r6,#vis_tiles_h-1	; left or rightmost column?

	MOVNE	r11,#48
	MOVEQ	r11,#32			; draw 2/3 if part off screen

	LDRB	r8,[r3,#5]		; blast frame number
	RSB	r8,r8,#20

	ADD	r2,r5,r8,LSL#12
	ADD	r2,r2,r8,LSL#9		; r2 = start address of blast frame

	CMP	r6,#0
	ADDEQ	r2,r2,#16*2		; clip left side if necessary
	SUBNE	r4,r4,#16		; otherwise, move back to centre explosion

	CMP	r1,r0
	BLT	adv_off_top

	; frame is not going off top of screen
	MOV	r9,#48                          ; default pixel rows to draw
	SUB	r8,r1,r0
	MOV	r8,r8,ASR#4
	CMP	r8,#((vis_tiles_v*16)-48)	; goes off bottom of screen?
	SUBGT	r10,r8,#((vis_tiles_v*16)-48)
	SUBGT	r9,r9,r10			; clipped pixel rows to draw

	ADD	r4,r4,r8,LSL#8
	ADD	r4,r4,r8,LSL#6			; Move down to start pixel row
	ADD	r4,r4,r6,LSL#4			; Move across to start column

	B	adv_start_draw

adv_off_top
	; frame is part way off top of screen
	SUB	r8,r0,r1
	MOV	r8,r8,ASR#4			; r8 pixel rows off top
	RSB	r9,r8,#48			; number of lines to draw

	ADD	r2,r2,r8,LSL#6
	ADD	r2,r2,r8,LSL#5			; skip pixel data

	ADD	r4,r4,r6,LSL#4			; move across to start row

adv_start_draw
	; r4 = screen address of point to start drawing
	; r2 = address of start of pixel data (after clipping)
	; r9 = number of rows to draw
	; r11 = width to draw
	; all other regs apart from r0 available for use

	CMP	r9,#0
	LDMLEFD	r13!,{r1,r3,r4,r5,r6,r7,r9,pc}	; Super clip if necessary

adv_draw_loop
	MOV	r10,r4			; screen address temp
	MOV	r12,r2			; pixel data temp

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 8

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 16

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 24

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 32

	CMP	r11,#48			; clip now?
	BLT	adv_next_line

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 40

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 48

adv_next_line
	ADD	r4,r4,#320		; move down screen 1 line
	ADD	r2,r2,#48*2		; move down pixel data 1 line

	SUBS	r9,r9,#1		; all lines done?
	BNE	adv_draw_loop

	; drawing is now complete. Restore regs and leave

	LDMFD	r13!,{r1,r3,r4,r5,r6,r7,r9,pc}

adv_flour_data
	DCD	scrmem_arena
	DCD	flour_gfx
	DCD	flour_array

draw_flour_exp
	EXPORT	draw_flour_exp

	STMFD	r13!,{r0-r12,r14}

	; On entry, r0 contains global_y

	MOV	r1,r0,ASR#8		; r1 = first row visible on screen
	SUB	r1,r1,#1		; big explosion can cover neighbouring rows
	ADD	r2,r1,#vis_tiles_v+2	; r2 = last row visible

	ADR	r4,adv_flour_data
	LDMIA	r4,{r4-r6}		; load variables
	LDR	r4,[r4,#0]		; get screen address

	MOV	r9,#64			; Number of possible explosions

flour_scan
	LDRB	r8,[r6,#2]		; get flour stats
	TST	r8,#1<<7		; exists?
	BEQ	no_flour_here		; apparently not

	LDRB	r8,[r6,#1]		; get flour y position
	CMP	r8,r1			; off top of screen?
	BLT	no_flour_here
	CMP	r8,r2			; off bottom of screen?
	BGE	no_flour_here

	LDRB	r7,[r6,#0]		; get x position
	BL	flour_exp_plot		; yes - draw it

no_flour_here
	ADD	r6,r6,#4
	SUBS	r9,r9,#1
	BNE	flour_scan

	; Scan and draw complete - exit

	LDMFD	r13!,{r0-r12,pc}

flour_exp_plot
	; On entry,
	;	r0  =	global_y
	;	r1  =	to be preserved
	;	r2  =	to be preserved
	;	r4  =	screen memory start
	; 	r5  =	big explosion graphics data
	;	r6  =	address of flour explosion control data
	;	r7  =   tile x position of flour explosion
	;	r8  =	tile y position of flour explosion
	;	r9  =   no use here, but must be preserved
	;	r3, r8, r10-r12 = available for use
	;	r14 =   return address

	STMFD	r13!,{r1,r2,r4,r5,r6,r7,r9,r14}

	; Find start of pixel data

	SUB	r8,r8,#2
	SUB	r7,r7,#1

	MOV	r1,r7

	CMP	r1,#0
	CMPNE	r1,#vis_tiles_h-1	; left or rightmost column?

	MOVNE	r11,#48
	MOVEQ	r11,#32			; draw 2/3 if part off screen

	LDRB	r6,[r6,#3]		; blast frame number
	RSB	r6,r6,#20

	ADD	r2,r5,r6,LSL#12
	ADD	r2,r2,r6,LSL#9		; r2 = start address of blast frame

	CMP	r1,#0
	ADDEQ	r2,r2,#16*2		; clip left side if necessary
	SUBNE	r4,r4,#16		; otherwise, move back to centre explosion

	CMP	r0,r8,LSL#8
	BGE	flour_off_top

	; frame is not going off top of screen
	MOV	r9,#48                          ; default pixel rows to draw
	RSB	r3,r0,r8,LSL#8			; exp_y - global_y
	MOV	r3,r3,ASR#4                     ; shifted to get pixel coords
	CMP	r3,#((vis_tiles_v*16)-48)	; goes off bottom of screen?
	SUBGT	r10,r3,#((vis_tiles_v*16)-48)
	SUBGT	r9,r9,r10			; clipped pixel rows to draw

	ADD	r4,r4,r3,LSL#8
	ADD	r4,r4,r3,LSL#6			; Move down to start pixel row
	ADD	r4,r4,r7,LSL#4			; Move across to start column

	B	flour_start_draw

flour_off_top
	; frame is part way off top of screen
	SUB	r3,r0,r8,LSL#8
	MOV	r3,r3,ASR#4			; r8 pixel rows off top
	RSB	r9,r3,#48			; number of lines to draw

	ADD	r2,r2,r3,LSL#6
	ADD	r2,r2,r3,LSL#5			; skip pixel data

	ADD	r4,r4,r7,LSL#4			; move across to start row

flour_start_draw
	; r4 = screen address of point to start drawing
	; r2 = address of start of pixel data (after clipping)
	; r9 = number of rows to draw
	; r11 = width to draw
	; all other regs apart from r0 available for use

	CMP	r9,#0
	LDMLEFD	r13!,{r1,r3,r4,r5,r6,r7,r9,pc}	; Super clip if necessary

flour_draw_loop
	MOV	r10,r4			; screen address temp
	MOV	r12,r2			; pixel data temp

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 8

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 16

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 24

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 32

	CMP	r11,#48			; clip now?
	BLT	flour_next_line

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 40

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 48

flour_next_line
	ADD	r4,r4,#320		; move down screen 1 line
	ADD	r2,r2,#48*2		; move down pixel data 1 line

	SUBS	r9,r9,#1		; all lines done?
	BNE	flour_draw_loop

	; drawing is now complete. Restore regs and leave

	LDMFD	r13!,{r1,r3,r4,r5,r6,r7,r9,pc}

;----------------------------------------------------------------------------
; Icon sprites - for menu use
;
;

	IMPORT	menu_icon

draw_icon_data
	DCD	menu_icon
	DCD	scrmem

draw_icon
	EXPORT	draw_icon

	; On entry,
	;	r0 - icon to draw
	;	r1,r2 - top left coord

	STMFD	r13!,{r0-r12,r14}

	LDR	r3,draw_icon_data	; address of sprite reference table
	ADD	r3,r3,r0,LSL#4		; 16 bytes per entry... r3 = our sprite

	LDMIA	r3,{r3,r5,r6}		; get width, height and sprite start address

	LDR	r4,draw_icon_data+4
	LDR	r4,[r4,#0]		; get screen address

	ADD	r4,r4,r2,LSL#8
	ADD	r4,r4,r2,LSL#6
	ADD	r4,r4,r1		; screen address to start drawing at

icon_draw_loop_y
	MOV	r10,r4			; screen address temp

	MOV	r11,r3			; width counter
icon_draw_loop_x
	LDMIA	r6!,{r1,r2}		; 4 pixels worth + masks
	LDMIA	r10,{r7}		; 4 pixels from screen

	AND	r7,r7,r2		; mask out parts of screen
	ORR	r7,r7,r1		; add in parts of icon

	STMIA	r10!,{r7}		; store new screen data

	SUBS	r11,r11,#4		; decrement x counter
	BGT	icon_draw_loop_x

	ADD	r4,r4,#320		; move down screen 1 line

	SUBS	r5,r5,#1		; all lines done?
	BNE	icon_draw_loop_y

	LDMFD	r13!,{r0-r12,pc}


;----------------------------------------------------------------------------
; Keyboard control
;
; control word data :
;	bit 0 - left
;	bit 1 - right
;	bit 2 - up
;	bit 3 - down
;	bit 4 - fire
;	bit 5 - fire2

; Event claimed keyboard reader

internal_keystate
	; 128 bytes - each byte reflecting the state of that internal key
	DCD	0,0,0,0,0,0,0,0
	DCD	0,0,0,0,0,0,0,0
	DCD	0,0,0,0,0,0,0,0
	DCD	0,0,0,0,0,0,0,0

kbd_event_process
	; On entry, check r0 - should be 11 for keyboard event

	CMP	r0,#11			; Key up/down event?
	MOVNES	pc,r14			; No - pass event on

	; r1 = 0 for key up, 1 for key down
	; r2 = [internal] key number
	; r3 = keyboard driver id

	; Make sure key is in range (should always be)
	CMP	r2,#0
	MOVLTS	pc,r14			; too low - pass on
	CMP	r2,#128
	MOVGES	pc,r14			; too high - pass on

	ADR	r0,internal_keystate
	STRB	r1,[r0,r2]		; store key state

	MOV	r0,#11
	MOVS	pc,r14			; pass event on

error_event_process
	; Some kind of error has been reported. PRMs aren't too clear on what information is
	; given in the registers, so I'll just make sure I preserve it.
	STMFD	r13!,{r0-r2,r14}

	; Disable the key up/down event
	MOV	r0,#13                  ; "Disable event"
	MOV	r1,#11			; key up/down event
	SWI	6			; "OS_Byte"

	; Release EventV
        MOV	r0,#&10			; EventV
	ADR	r1,kbd_event_process	; Our keyboard handler
	MOV	r2,#0
	SWI	&20			; "OS_Release"

	; Release ErrorV
	MOV	r0,#1			; ErrorV
	ADR	r1,error_event_process	; this routine
	MOV	r2,#0
	SWI	&20			; "OS_Release"

	; Restore registers
	LDMFD	r13!,{r0-r2,r14}

	; Pass on error event
	MOVS	pc,r14

kbd_claim
	EXPORT	kbd_claim

	STMFD	r13!,{r0-r2,r14}

	; On entry to the game (from desktop), claim EventV and clear internal keystates
	MOV	r0,#&10			; EventV
	ADR	r1,kbd_event_process	; Our keyboard handler
	MOV	r2,#0                   ; Parameter to be passed to handler
	SWI	&1f			; "OS_Claim"

	; Enable the event
	MOV	r0,#14                  ; "Enable event"
	MOV	r1,#11			; Key up/down event
	SWI	6			; "OS_Byte"

	; Clear keystate table
	ADR	r0,internal_keystate	; keystate table address
	MOV	r1,#32			; Size of table /4
	MOV	r2,#0
kbd_clear_loop
	STR	r2,[r0],#4		; clear four entries
	SUBS	r1,r1,#1		; keep count
	BNE	kbd_clear_loop

	; Claim ErrorV in order to release events if all goes wrong
	MOV	r0,#1			; ErrorV
	ADR	r1,error_event_process	; Our error handler
	MOV	r2,#0
	SWI	&1f			; "OS_Claim"

	; Finish
	LDMFD	r13!,{r0-r2,pc}

kbd_release
	EXPORT	kbd_release

	STMFD	r13!,{r0-r2,r14}

	; On exit from the game (back to desktop) release EventV to avoid potential damage to
	; other applications

	; Disable the event
	MOV	r0,#13                  ; "Disable event"
	MOV	r1,#11			; key up/down event
	SWI	6			; "OS_Byte"

	; Release the vector
        MOV	r0,#&10			; EventV
	ADR	r1,kbd_event_process	; Our keyboard handler
	MOV	r2,#0
	SWI	&20			; "OS_Release"

	; Release ErrorV
	MOV	r0,#1			; ErrorV
	ADR	r1,error_event_process	; Error handling (clean-up) routine
	MOV	r2,#0
	SWI	&20			; "OS_Release"

	; Finish
	LDMFD	r13!,{r0-r2,pc}

	IMPORT	keyboard_def
	IMPORT	ctrl_word_table

read_keyboard_data
	DCD	keyboard_def
	DCD	ctrl_word_table

read_keyboard_data_dest
	DCD	0
	DCD	0
	DCD	0
	DCD	0

misc_ctrl_keys
	EXPORT	misc_ctrl_keys
	DCD	0

read_keyboard
	; On entry,	r0 = control word entry for player 1
	;		r1 = control word entry for player 2
	;		r2 = control word entry for player 3
	;		r3 = control word entry for player 4

	EXPORT	read_keyboard

	STMFD	r13!,{r0-r7,r10,r11,r14}		; Save regs

	ADR	r10,read_keyboard_data_dest
	STMIA	r10,{r0-r3}

	MOV	r3,#0			; Four players controls to access

read_keyboard_each_player
	LDR	r11,[r10,r3,LSL#2]      ; Do we need a keyboard read for this word?
	CMP	r11,#0
	BLT	read_keyboard_abort_read

	MOV	r4,#0			; init word to 0

	LDR	r5,read_keyboard_data
	ADD	r5,r5,r3,LSL#5		; r5 points to players keyboard defns.

	MOV	r6,#6			; number of keys to test for this player
	MOV	r7,#1			; control bit to set

	ADR	r0,internal_keystate

read_key_for_player
	LDR	r1,[r5],#4		; get internal key value for key
	LDRB	r1,[r0,r1]		; get key state

	CMP	r1,#0			; If key is pressed,
	ORRNE	r4,r4,r7		; set bit in control word

	MOV	r7,r7,LSL#1		; move to next control bit

	SUBS	r6,r6,#1

	BNE	read_key_for_player	; continue till all keys read.

	; r4 contains new control word
	; - store in control word table at given entry.

	LDR	r5,read_keyboard_data+4

	STR	r4,[r5,r11,LSL#2]	; store players entry

read_keyboard_abort_read
	ADD	r3,r3,#1

	CMP	r3,#4			; all players done?
	BLT	read_keyboard_each_player

	LDMFD	r13!,{r0-r7,r10,r11,pc}	; restore regs and return

scan_keyboard
	EXPORT	scan_keyboard

	; Returns the internal key code of the pressed key, or &ff if none
	; are currently pressed

	STMFD	r13!,{r1-r3,r14}

	ADR	r0,internal_keystate	; table of key states
	MOV	r1,#0			; key number

key_scan_loop
	LDRB	r2,[r0,r1]		; read key state

	CMP	r2,#0			; is it pressed?
	MOVNE	r0,r1
	LDMNEFD r13!,{r1-r3,pc}		; yes - return key number

	ADD	r1,r1,#1
	CMP	r1,#128			; End of table?
	BLT	key_scan_loop		; No - continue search

	; No key found - return &ff
	MOV	r0,#&ff
	LDMFD	r13!,{r1-r3,pc}

read_ctrl_keys
	EXPORT	read_ctrl_keys

	; Check for miscellaneous control keys
	STMFD	r13!,{r0-r2,r14}

	ADR	r0,internal_keystate
	ADR	r2,misc_ctrl_keys

	LDRB	r1,[r0,#0]		; "Escape" - keycode 0
	STRB	r1,[r2,#0]		; Store state

	LDRB	r1,[r0,#&c]		; "F12" - keycode &0c
	STRB	r1,[r2,#1]		; Store state

	LDMFD	r13!,{r0-r2,pc}

;------------------------------------------------------------------------------
; Joystick Reader

read_joystick_data
	DCD	ctrl_word_table

read_joystick
	EXPORT	read_joystick
	; On entry,
	;	r0 = joystick to read
	;	r1 = control word entry for joystick information

	STMFD	r13!,{r0-r4,r14}

	MOV	r4,r1

	; Argh! No Joystick_Read SWI!
	SWI 	&63F40			; "XJoystick_Read"

	MOV	r3,#0			; New control word

	MOV	r1,r0,LSL#24
	MOV	r1,r1,ASR#24		; get Y byte (signed)

	MOV	r2,#4			; Up

	CMP	r1,#0
	RSBLT	r1,r1,#0		; absolute value

	MOVLT	r2,#8			; Down instead

	CMP	r1,#32			; pushed in that direction?

	ORRGT	r3,r3,r2		; yes - set direction bit

	MOV	r1,r0,LSL#16
	MOV	r1,r1,ASR#24		; get X byte (signed)

	MOV	r2,#2			; Right

	CMP	r1,#0
	RSBLT	r1,r1,#0		; absolute value

	MOVLT	r2,#1			; left instead

	CMP	r1,#32			; pushed in that direction?

	ORRGT	r3,r3,r2		; yes - set direction bit

	TST	r0,#&00010000		; joystick button 1?
	ORRNE	r3,r3,#16		; yes - set fire button bit

	TST	r0,#&00020000		; joystick button 2?
	ORRNE	r3,r3,#32		; yes - set extra fire button bit

	LDR	r0,read_joystick_data
	STR	r3,[r0,r4,LSL#2]	; store control word

	LDMFD	r13!,{r0-r4,pc}		; return

;------------------------------------------------------------------------------
; Mouse Reader

read_mouse_data
	DCD	ctrl_word_table

read_mouse_dir
	EXPORT	read_mouse_dir
	DCD	0

read_mouse
	EXPORT	read_mouse

	STMFD	r13!,{r0-r5,r14}

	SWI	&1c			; "OS_Mouse"

	MOV	r5,#0			; our new control word

	SUB	r0,r0,#640
	SUB	r1,r1,#512

	; Left button is pressed. Interpret mouse position as a direction
	CMP	r0,r1
	BGT	mouse_dir_rightdown

	; Either up or left.
	RSB	r1,r1,#0
	CMP	r0,r1

	ORRGT	r5,r5,#4
	ORRLE	r5,r5,#1

	B	mouse_dir_rendez

mouse_dir_rightdown
	; either down or right
	RSB	r1,r1,#0
	CMP	r0,r1

	ORRGT	r5,r5,#2
	ORRLE	r5,r5,#8

mouse_dir_rendez
	STR	r5,read_mouse_dir	; store prospective direction

	TST	r2,#4			; Left button pressed?
	MOVEQ	r5,#0			; no - don't use direction

	TST	r2,#1			; right mouse button?
	ORRNE	r5,r5,#16		; = fire 1

	TST	r2,#2			; middle button?
	ORRNE	r5,r5,#32		; = fire 2

	LDR	r0,read_mouse_data
	STR	r5,[r0,#8*4]		; store in ctrl word entry 8

	LDMFD	r13!,{r0-r5,pc}


;------------------------------------------------------------------------------

	IMPORT	bloke_gfx
	IMPORT	action_table
	IMPORT	plrpals

drawaman_data
	DCD	action_table
	DCD	scrmem_arena
	DCD	plrpals

drawaman
	EXPORT	drawaman
	; On entry,
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - address of control block for man being drawn

	STMFD	r13!,{r0-r10,r14}	; save regs

	; is player dead?
	LDRB	r3,[r1,#11]		; player status
	MOV	r3,r3,LSR#4		; get action code
	CMP	r3,#5			; dying?
	BNE	drawaman_not_dying
	LDRB	r4,[r1,#13]
	CMP	r4,#255			; dying, and animctr==255 => dead
	LDMEQFD r13!,{r0-r10,pc}

drawaman_not_dying

	LDR	r3,[r1,#4]		; get player ypos.
	SUB	r3,r3,#1<<4		; Skip sentinel row

	; Offset in pixels from top of visible screen to man =
	;	man.ypos - (global_y>>4)

	MOV	r4,#16			; draw all 16 lines of sprite
	MOV	r5,#0			; starting at line 0

	SUBS	r0,r3,r0,ASR#4		; y offset in pixels
	ADDLT	r4,r0,#16
	RSBLT	r5,r4,#16		; clip 16+y lines from top

	; Super clip test
	ADDS	r2,r0,#16               ; Completely off top?
	BLE	drawaman_exit
	CMP	r0,#vis_tiles_v*16      ; Completely off bottom?
	BGE	drawaman_exit

	CMP	r0,#(vis_tiles_v-1)*16	; Does sprite overlap bottom?
	ANDGT	r4,r0,#&f
	RSBGT	r4,r4,#16               ; Draw 16-(y&15) lines

	CMP	r0,#0
	MOVLT	r0,#0			; limit y offset to 0

	ADR	r2,drawaman_data
	LDMIA	r2,{r2,r3,r14}
	LDR	r3,[r3,#0]		; load variables

	; Register status -
	;
	; r0	- offset in pixels from top of screen to start of man
	; r1	- address of player control block
	; r2	- address of player action array
	; r3	- screen memory start
	; r4	- number of pixel rows of sprite to draw
	; r5	- number of pixel rows of sprite to skip before drawing

	LDRB	r7,[r1,#11]		; get status
	MOV	r6,r7,LSR#4		; get action info

	; Coughing animation can not be passed through normal channels, as we need
	; to preserve the original action.
	LDRB	r8,[r1,#10]		; get extra flags
	TST	r8,#1<<5		; floured?
	BEQ	drawaman_not_floured

	; Floured, but has timer reached coughing fit stage?
	LDRB	r8,[r1,#16]		; get timer
	CMP	r8,#128			; coughing time?
	MOVLE	r6,#6			; yes, action = coughing

drawaman_not_floured
	LDR	r2,[r2,r6,LSL#2]	; Look up animation for this action

	LDRB	r6,[r1,#18]		; Get sprite_num field for player
	LDR	r2,[r2,r6,LSL#2]	; Look up sprite data for this frame

	MOV	r7,r7,LSR#1
	AND	r7,r7,#3		; get direction from status
	ADD	r2,r2,r7,LSL#8		; Offset to sprites for that direction

	; Player palette - this goes according to the colour field of this player
	; unless s/he is covered in flour, where it is set to 4 (white).

	LDRB	r7,[r1,#10]		; get extra flags
	TST	r7,#1<<5		; floured?
	MOVNE	r7,#4			; yes - colour player white
	LDREQB	r7,[r1,#14]		; no - get colour field for player
	ADD	r14,r14,r7,LSL#8	; Offset to this players palette

	ADD	r2,r2,r5,LSL#4		; clip top of sprite

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column

	; Register status
	;
	; r0	- Offset from top of screen to man, in pixels
	; r1	- Offset from left of screen to man, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#8
	ADD	r3,r3,r0,LSL#6		; move down screen to man position
	ADD	r3,r3,r1		; and across to man position

	MOV	r7,#255			; byte mask

drawaman_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	ANDS	r8,r7,r5		; get 1st pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#0]		; draw if not background

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#1]		; draw if not background

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#2]		; draw if not background

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#3]		; draw if not background

	ANDS	r8,r7,r6		; get 5th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#4]		; draw if not background

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#5]		; draw if not background

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#6]		; draw if not background

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#7]		; draw if not background

	ANDS	r8,r7,r9		; get 9th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#8]		; draw if not background

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#9]		; draw if not background

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#10]		; draw if not background

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#11]		; draw if not background

	ANDS	r8,r7,r10		; get 13th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#12]		; draw if not background

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#13]		; draw if not background

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#14]		; draw if not background

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#15]		; draw if not background

	ADD	r3,r3,#320
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	drawaman_pixel_line	; continue until done.

drawaman_exit

	LDMFD	r13!,{r0-r10,pc}	; restore regs and return

;------------------------------------------------------------------------------

	IMPORT	bomb_gfx

drawabomb_anim
	DCB	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
	DCB	6,7,7,7,6,7,7,7,6,7,7,7,6,7,7,7
	DCB	6,6,7,7,6,6,7,7,6,6,7,7,6,6,7,7
	DCB	6,6,6,7,6,6,6,7,6,6,6,7,6,6,6,7
	DCB	5,6,6,6,5,6,6,6,5,6,6,6,5,6,6,6
	DCB	5,5,6,6,5,5,6,6,5,5,6,6,5,5,6,6
	DCB	5,5,5,6,5,5,5,6,5,5,5,6,5,5,5,6
	DCB	4,5,5,5,4,5,5,5,4,5,5,5,4,5,5,5
	DCB	4,4,5,5,4,4,5,5,4,4,5,5,4,4,5,5
	DCB	4,4,4,5,4,4,4,5,4,4,4,5,4,4,4,5
	DCB	3,4,4,4,3,4,4,4,3,4,4,4,3,4,4,4
	DCB	3,3,4,4,3,3,4,4,3,3,4,4,3,3,4,4
	DCB	3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,4
	DCB	2,3,3,3,2,3,3,3,2,3,3,3,2,3,3,3
	DCB	2,2,3,3,2,2,3,3,2,2,3,3,2,2,3,3
	DCB	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2

drawabomb_data
	DCD	bomb_gfx
	DCD	scrmem_arena
	DCD	0

drawabomb
	EXPORT	drawabomb
	; On entry,
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - address of control block for bomb being drawn

	STMFD	r13!,{r0-r10,r14}	; save regs

	STR	r0,drawabomb_data+8	; for future reference

	LDR	r3,[r1,#4]		; get bomb ypos.
	SUB	r3,r3,#1<<4		; Skip sentinel row

	; Offset in pixels from top of visible screen to bomb =
	;	bomb.ypos - (global_y>>4)

	MOV	r4,#16			; draw all 16 lines of sprite
	MOV	r5,#0			; starting at line 0

	SUBS	r0,r3,r0,ASR#4		; y offset in pixels
	ADDLT	r4,r0,#16
	RSBLT	r5,r4,#16		; clip 16+y lines from top

	; Super clip test
	ADDS	r2,r0,#16               ; Completely off top?
	BLE	drawabomb_exit
	CMP	r0,#vis_tiles_v*16      ; Completely off bottom?
	BGE	drawabomb_exit

	CMP	r0,#(vis_tiles_v-1)*16	; Does sprite overlap bottom?
	ANDGT	r4,r0,#&f
	RSBGT	r4,r4,#16               ; Draw 16-(y&15) lines

	CMP	r0,#0
	MOVLT	r0,#0			; limit y offset to 0

	ADR	r2,drawabomb_data
	LDMIA	r2,{r2,r3}
	LDR	r3,[r3,#0]		; load variables

	; Register status -
	;
	; r0	- offset in pixels from top of screen to start of bomb
	; r1	- address of bomb control block
	; r2	- address of bomb graphics data
	; r3	- screen memory start
	; r4	- number of pixel rows of sprite to draw
	; r5	- number of pixel rows of sprite to skip before drawing

	LDRB	r6,[r1,#9]		; Get timer
	ADR	r7,drawabomb_anim
	LDRB	r6,[r7,r6]		; grow bomb as timer goes down
	LDRB	r7,[r1,#10]		; get bomb type
	CMP	r7,#3
	MOVEQ	r7,#0			; bouncing bombs look like normal bombs (at the mo)
	ADD	r6,r6,r7,LSL#3
	LDRB	r7,[r1,#8]		; Get owner field for bomb colour

	CMP	r7,#255			; CPU bomb?
	MOVEQ	r7,#0			; yes - use player 1's colour

	; sprite addr = r2 + 256*frame + (32*256)*colour

	ADD	r2,r2,r6,LSL#8
	ADD	r2,r2,r7,LSL#13		; start of sprite

	LDRB	r7,[r1,#11]		; get bomb status
	TST	r7,#1<<3		; is bomb in air?
	BEQ	bomb_on_ground		; no - branch
	BL	bomb_shadow		; yes - draw shadow
	BL	bomb_clipped		; and clipped bomb
	B	drawabomb_exit

bomb_on_ground
	ADD	r2,r2,r5,LSL#4		; clip top of sprite

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column

	; Register status
	;
	; r0	- Offset from top of screen to bomb, in pixels
	; r1	- Offset from left of screen to bomb, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#8
	ADD	r3,r3,r0,LSL#6		; move down screen to bomb position
	ADD	r3,r3,r1		; and across to bomb position

	MOV	r7,#255			; byte mask

drawabomb_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	ANDS	r8,r7,r5		; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background

	ANDS	r8,r7,r6		; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background

	ANDS	r8,r7,r9		; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background

	ANDS	r8,r7,r10		; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

	ADD	r3,r3,#320
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	drawabomb_pixel_line	; continue until done.

drawabomb_exit

	LDMFD	r13!,{r0-r10,pc}	; restore regs and return

bomb_shadow
	STMFD	r13!,{r0-r4,r11,r12,r14}

	ADRL	r7,bomb_arc
	LDRB	r8,[r1,#13]		; get zpos index
	LDRB	r8,[r7,r8]		; get 'height'

	LDR	r4,[r1,#4]		; ypos
	LDR	r0,drawabomb_data+8	; global_y
	SUB	r0,r4,r0,ASR#4

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column
	SUB	r0,r0,#1<<4

	ADD	r0,r0,r8
	SUB	r1,r1,r8		; move shadow from bomb

	; Clip shadow to game area
	MOV	r4,#16			; rows to draw
	MOV	r11,#16			; columns to draw
	MOV	r12,#0			; columns to skip

	CMP	r1,#0                   ; off left?
	BGE	clipshad_right
	RSB	r5,r1,#0
	CMP	r5,#16			; completely off left?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	MOV	r12,r5
	RSB	r11,r12,#16
	B	clipshad_top

clipshad_right
	CMP	r1,#16*(vis_tiles_h-1) ; going off right?
	BLE	clipshad_top
	CMP	r1,#16*vis_tiles_h	; completely off right?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
        RSB	r11,r1,#16*vis_tiles_h

clipshad_top
	CMP	r0,#0			; going off top?
	BGE	clipshad_bottom
	RSB	r6,r0,#0
	CMP	r6,#16			; completely off top?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r6,#16
	ADD	r2,r2,r6,LSL#4
	MOV	r0,#0
	B	shadclip_done

clipshad_bottom
	CMP	r0,#16*(vis_tiles_v-1)	; going off bottom?
	BLE	shadclip_done
	CMP	r0,#16*vis_tiles_v	; completely off bottom?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r0,#16*vis_tiles_v

shadclip_done

	; Register status
	;
	; r0	- Offset from top of screen to bomb, in pixels
	; r1	- Offset from left of screen to bomb, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#8
	ADD	r3,r3,r0,LSL#6		; move down screen to bomb position
	ADD	r3,r3,r1		; and across to bomb position

	MOV	r7,#255			; byte mask
	MOV	r8,#0			; black pixel

	ADR	r0,drawabombshadow_pixels

drawabombshadow_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	MOV	r14,r11

	ADD	pc,r0,r12,LSL#4		; 4 instructions per pixel

drawabombshadow_pixels
	TST	r7,r5			; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r6			; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r9			; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r10			; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r10,LSR#16		; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	shadow_line_done

	TST	r7,r10,LSR#24		; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

shadow_line_done
	ADD	r3,r3,#320
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	drawabombshadow_pixel_line	; continue until done.

	LDMFD	r13!,{r0-r4,r11,r12,pc}		; restore regs and return

bomb_clipped
	STMFD	r13!,{r0-r4,r11,r12,r14}

	LDR	r4,[r1,#4]		; ypos
	LDR	r0,drawabomb_data+8	; global_y
	SUB	r0,r4,r0,ASR#4

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column
	SUB	r0,r0,#1<<4

	; Clip bomb to game area
	MOV	r4,#16			; rows to draw
	MOV	r11,#16			; columns to draw
	MOV	r12,#0			; columns to skip

	CMP	r1,#0                   ; off left?
	BGE	clipbomb_right
	RSB	r5,r1,#0
	CMP	r5,#16			; completely off left?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	MOV	r12,r5
	RSB	r11,r12,#16
	B	clipbomb_top

clipbomb_right
	CMP	r1,#16*(vis_tiles_h-1) ; going off right?
	BLE	clipbomb_top
	CMP	r1,#16*vis_tiles_h	; completely off right?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
        RSB	r11,r1,#16*vis_tiles_h

clipbomb_top
	CMP	r0,#0			; going off top?
	BGE	clipbomb_bottom
	RSB	r6,r0,#0
	CMP	r6,#16			; completely off top?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r6,#16
	ADD	r2,r2,r6,LSL#4
	MOV	r0,#0
	B	bombclip_done

clipbomb_bottom
	CMP	r0,#16*(vis_tiles_v-1)	; going off bottom?
	BLE	bombclip_done
	CMP	r0,#16*vis_tiles_v	; completely off bottom?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r0,#16*vis_tiles_v

bombclip_done

	; Register status
	;
	; r0	- Offset from top of screen to bomb, in pixels
	; r1	- Offset from left of screen to bomb, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#8
	ADD	r3,r3,r0,LSL#6		; move down screen to bomb position
	ADD	r3,r3,r1		; and across to bomb position

	MOV	r7,#255			; byte mask

	ADR	r0,drawaclipbomb_pixels

drawaclipbomb_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	MOV	r14,r11

	ADD	pc,r0,r12,LSL#4		; 4 instructions per pixel

drawaclipbomb_pixels
	ANDS	r8,r7,r5		; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r6		; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r9		; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r10		; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbomb_line_done

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

clipbomb_line_done
	ADD	r3,r3,#320
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	drawaclipbomb_pixel_line	; continue until done.

	LDMFD	r13!,{r0-r4,r11,r12,pc}		; restore regs and return

	;SWI	263
	;SWI	263
	;SWI	263
	;SWI	263
	;SWI	263
	DCD	&deadbeeb


	IMPORT	bombs

draw_all_bombs_data
	DCD	bombs

draw_all_bombs
	EXPORT	draw_all_bombs

	; On entry, r0 = global_y.

	STMFD	r13!,{r1,r2,r3,r14}	; save regs

	LDR	r1,draw_all_bombs_data
	MOV	r2,#64

draw_all_bombs_loop
	LDRB	r3,[r1,#11]
	TST	r3,#1<<4		; does bomb exist?

	BLNE	drawabomb		; yes - draw it

	ADD	r1,r1,#16		; go to next bomb entry

	SUBS	r2,r2,#1		; dec bomb counter
	BNE	draw_all_bombs_loop	; continue until all bombs have been drawn

	LDMFD	r13!,{r1,r2,r3,pc}	; restore regs, and return

;------------------------------------------------------------------------

	IMPORT	players			; array of player control block stuctures
	IMPORT	floor_map		; array of floor tile structures
	IMPORT	bonus_array
	IMPORT	mystery

man_handle_data
	DCD	players
	DCD	floor_map
	DCD	ctrl_word_table
	DCD	bombs
	DCD	bonus_array

man_handle
	EXPORT	man_handle

	; For each player in turn (0-3)
	;	If player is dead - status flag = dying, lives = 0 - end.
	;	If player is moving - status flag, bit 0 - continue movement
	;	else examine ctrl_word_table entry and move if necessary.
	;	Check for collision with anything fatal.
	;	Movement to tile n possible if :
	;		tile status has bit 8 set - can be walked on
	;		tile contains a bomb

	STMFD	r13!,{r0-r12,r14}	; save regs

	MOV	r0,#4			; player count

	ADR	r1,man_handle_data
	LDMIA	r1,{r1,r2,r6,r7}	; load variables

handle_each_man
	LDRB	r3,[r1,#11]		; player status

	TST	r3,#1<<3		; invulnerable?
	BEQ	handle_after_invuln

	ADRL	r4,scan_clock
	LDR	r4,[r4,#0]
	TST	r4,#1
	BNE	handle_after_invuln	; double length of invulnerability using scan clock

	LDRB	r4,[r1,#16]		; invulnerability counter
	SUBS	r4,r4,#1
	STRB	r4,[r1,#16]		; decremented

	BICEQ	r3,r3,#1<<3		; not invulnerable any more
	STREQB	r3,[r1,#11]		; new status

handle_after_invuln
	LDRB	r4,[r1,#10]
	TST	r4,#1<<5		; floured?
	BEQ	handle_after_flour

	LDRB	r4,[r1,#16]		; invulnerability counter
	SUBS	r4,r4,#1
	STRB	r4,[r1,#16]		; decremented

	LDREQB	r5,[r1,#10]
	BICEQ	r5,r5,#1<<5		; not invulnerable any more
	STREQB	r5,[r1,#10]		; new status

	; Coughing fit - to be triggered when...
	;   1. timer has reached 128 or less
	;   2. player is completely over tile
	;   3. player status is normal

	; Part 1
	CMP	r4,#128			; check timer
	BGT	handle_after_flour

	; Part 2
	LDR	r5,[r1,#0]		; player xpos
	TST	r5,#15			; fractional part not 0?
	BNE	handle_after_flour	; not completely over tile

	LDR	r5,[r1,#4]		; player ypos
	TST	r5,#15			; fractional part not 0?
	BNE	handle_after_flour	; not completely over tile

	; Part 3
	MOVS	r5,r3,LSR#4		; get current action
	BEQ	handle_coughing_fit	; only if action is normal
	CMP	r5,#6			; or coughing
	BEQ	handle_coughing_fit

handle_after_flour
	MOVS	r4,r3,LSR#4		; get current action

	BEQ	man_handle_normal

	CMP	r4,#1                   ; is player picking up bomb?
	BEQ	man_handle_pick_up

	CMP	r4,#3			; is player throwing a bomb?
	BEQ	man_handle_throw

	CMP	r4,#4			; is player stunned?
	BEQ	man_handle_stunned

	CMP	r4,#5			; is player dying?
	BEQ	man_handle_dying	; yes - branch

man_handle_normal
	; does this players nearest tile hold a reference to a bomb that is
	;  a) moving,
	;  b) is a mega bomb, and
	;  c) was not pushed by him?
	;
	; If so, we need to put this player into stunned mode:
	;
	;  If he was moving,
	;    lock to the tile the collision was with
	;    tidy up man_here references in map data
	;
	;  If he was carrying a bomb,
	;    throw the bomb.
	;
	;  Set status byte to contain stun action, not moving.
	;  Try death check.
	;
	; If no bomb is found, status byte must be preserved in r3.

	LDMIA	r1,{r3,r4}		; get bomb coords

	ADD	r3,r3,#8
	ADD	r4,r4,#8
	MOV	r3,r3,ASR#4
	MOV	r4,r4,ASR#4		; Round to nearest tile.

	; r2 contains base address for map
	ADD	r5,r2,r4,LSL#9		; 32 lots of 16 bytes per map row
	ADD	r5,r5,r3,LSL#4		; 16 bytes per map tile

	; r5 now contains the address of the nearest tile
	LDRB	r8,[r5,#2]		; get extra1 - bomb link
	TST	r8,#1<<7		; is there a bomb here?
	LDREQB	r3,[r1,#11]		; no - reload status byte...
	BEQ	not_rolled_on		; ...and jump

	; There's a bomb here! Is it moving?
	; (r7 contains base address of bomb array)
	AND	r8,r8,#63		; get bomb number
	ADD	r8,r7,r8,LSL#4		; 16 bytes per bomb

	; r8 now contains the address of the bomb we've touched
	LDRB	r9,[r8,#11]		; get bomb status
	TST	r9,#1			; is it moving?
	LDREQB	r3,[r1,#11]		; no - reload status byte...
	BEQ	not_rolled_on		; ...and jump

	; It's a rolling bomb... but is it a mega bomb?
	LDRB	r9,[r8,#10]		; get bomb type
	CMP	r9,#1			; is it a mega bomb?
	LDRNEB	r3,[r1,#11]		; no - reload status byte
	BNE	not_rolled_on		; ...and jump

	; It's a rolling mega bomb... but did we push it?
	LDRB	r9,[r8,#12]		; who pushed it?
	RSB	r9,r9,#4
	CMP	r9,r0			; was it us?
	LDREQB	r3,[r1,#11]		; yes - reload status byte
	BEQ	not_rolled_on		; ...and jump

	; Ok. It's a rolling mega bomb not pushed by us. That pretty much
	; says that this player is going to get stunned.

	; Take care of the man_here flags :
	;  tile stood on holds a reference
	;
	;  If player was not moving,
	;    if anim_ctr==0
	;      tile in movement direction holds reference
	;    else
	;      LEFT/RIGHT : tile to right holds reference
	;      UP/DOWN    : tile below holds reference
	;
	; Though it may be easier here to just blat all surrounding tiles
	; (left, right, above and below)

	ADRL	r8,collision_parameter_block

	MOV	r3,r3,LSL#4
	MOV	r4,r4,LSL#4

	STMIA	r8,{r3,r4}		; store collision coords
	STR	r5,[r8,#8]		; store tile address
	STR	r1,[r8,#12]		; store player address

	BL	collision_handler	; do it!

	LDRB	r3,[r1,#11]		; reload status byte, just in case

	B	man_handle_death_check	; That's it, I think.

not_rolled_on
	TST	r3,#1			; is player moving?
	BEQ	man_handle_waiting	; no - go and look for more input

	TST	r3,#1<<2		; Check direction
	LDREQ	r4,[r1,#0]		; Horizontal -> change xpos
	LDRNE	r4,[r1,#4]		; Vertical -> change ypos

	TST	r3,#1<<1		; increment or decrement?
	ADDNE	r4,r4,#2		; inc
	SUBEQ	r4,r4,#2		; dec

	TST	r3,#1<<2
	STREQ	r4,[r1,#0]
	STRNE	r4,[r1,#4]		; store xpos or ypos

	LDRB	r4,[r1,#18]		; get sprite_num
	ADD	r4,r4,#1		; increment
	AND	r4,r4,#7		; keep in range 0..7
	STRB	r4,[r1,#18]		; put back new sprite_num

	LDRB	r4,[r1,#13]		; get anim_ctr
	SUBS	r4,r4,#1		; dec
	STRB	r4,[r1,#13]		; write back

	EOREQ	r3,r3,#1		; if next tile has been reached, clear moving flag
	STRB	r3,[r1,#11]		; store new status

	BNE	mh_still_moving

	; Next tile has been reached. Find last tile and remove this players indicator from it.
	LDMIA	r1,{r4,r5}		; get xpos,ypos

	; Are we leaking fuel?
	LDRB	r3,[r1,#10]
	TST	r3,#1<<4
	BEQ	man_not_leaking

	MOV	r5,r5,LSR#4		; round to nearest row
	ADD	r5,r2,r5,LSL#9		; jump to that row on map (TDC)
	MOV	r4,r4,LSR#4		; round to nearest column
	ADD	r5,r5,r4,LSL#4		; move to that column on map (TDC)

	LDRB	r3,[r5,#0]		; tile status
	CMP	r3,#128			; can we leak on this tile?
	BNE	man_not_leaking

	MOV	r3,#20+128
	STRB	r3,[r5,#0]
	MOV	r3,#62
	STRB	r3,[r5,#1]

man_not_leaking
	LDMIA	r1,{r4,r5}		; get xpos,ypos

	LDRB	r3,[r1,#11]
	TST	r3,#1<<2		; Check direction
	MOVEQ	r8,r4			; change xpos
	MOVNE	r8,r5			; change ypos

	TST	r3,#1<<1		; increment or decrement?
	ADDEQ	r8,r8,#16		; inc
	SUBNE	r8,r8,#16		; dec

	TST	r3,#1<<2		; Check direction
	MOVEQ	r4,r8			; old xpos
	MOVNE	r5,r8			; old ypos

	MOV	r5,r5,LSR#4		; round to nearest row
	ADD	r5,r2,r5,LSL#9		; jump to that row on map (TDC)
	MOV	r4,r4,LSR#4		; round to nearest column
	ADD	r5,r5,r4,LSL#4		; move to that column on map (TDC)

	LDRB	r3,[r5,#8]		; get men_here flags
	RSB	r8,r0,#4		; get man number
	MOV	r4,#1
	BIC	r3,r3,r4,LSL r8		; clear this players flag
	STRB	r3,[r5,#8]		; store new flags

	; Are there any bonuses on this tile?
	; man_handle_data+16 = address of bonus array
	LDR	r3,man_handle_data+16

	LDMIA	r1,{r4,r5}		; man's coords
	MOV	r4,r4,ASR#4
	MOV	r5,r5,ASR#4

	MOV	r8,#128

standing_on_bonus
	LDRB	r9,[r3,#2]		; bonus status

	TST	r9,#1<<7		; active?
	BEQ	standing_on_next_bonus	; no - try next

	TST	r9,#1			; moving?
	BNE	standing_on_next_bonus	; yes - can't grab it.

	; compare coords
	LDRB	r10,[r3,#0]		; xpos
	CMP	r4,r10,ASR#3		; = bloke ypos?
	BNE	standing_on_next_bonus	; no - next!

	LDRB	r10,[r3,#1]		; ypos
	CMP	r5,r10,ASR#3		; = bloke ypos?
	BEQ	we_are_on_bonus		; yes - deal with it.


standing_on_next_bonus
	ADD	r3,r3,#4		; next bonus

	SUBS	r8,r8,#1
	BNE	standing_on_bonus	; until all bonuses are checked

	B	mh_still_moving

we_are_on_bonus
	ADD	r8,r2,r5,LSL#9
	ADD	r8,r8,r4,LSL#4		; tile coord

	MOV	r10,#0
	STRB	r10,[r8,#1]		; empty floor sprite
	MOV	r10,#128
	STRB	r10,[r8,#6]		; empty floor status
	STRB	r10,[r8,#0]

	MOV	r9,r9,ASR#3
	AND	r9,r9,#15		; r9 = bonus type.

	MOV	r10,#0
	STR	r10,[r3,#0]		; blank bonus entry

	; Here's where we interpret the action of the bonus...
	; I think.
	;SWI	263			; wow, what a bonus
	MOV	r12,r0
	MOV	r0,#11
	BL	dsym_playinstr		; play bonus pick-up noise
	MOV	r0,r12

	ADR	r12,post_bonus_rendez_vous
	ADR	r10,bonus_process_list
	LDR	pc,[r10,r9,LSL#2]	; branch to handle this bonus

bonus_process_list
	DCD	post_bonus_rendez_vous
	DCD	post_bonus_rendez_vous
	DCD	bh_extra_flame
	DCD	bh_extra_bomb
	DCD	bh_mega_bomb
	DCD	bh_rubber_bombs
	DCD	bh_flower_bombs
	DCD	bh_push_ability
	DCD	bh_throw_ability
	DCD	bh_mystery
	DCD	bh_protection_suit
	DCD	post_bonus_rendez_vous
	DCD	post_bonus_rendez_vous
	DCD	post_bonus_rendez_vous
	DCD	post_bonus_rendez_vous
	DCD	post_bonus_rendez_vous
	DCD	post_bonus_rendez_vous

mh_extra_data
	DCD	mystery

post_bonus_rendez_vous

mh_still_moving
	; Key presses while on the move
	; 1. Drop

	LDRB	r3,[r1,#12]		; get control word number
	LDR	r4,[r6,r3,LSL#2]	; get corresponding control word

	LDR	r5,[r1,#4]		; get ypos
	MOV	r5,r5,LSR#4		; round to nearest row
	ADD	r5,r2,r5,LSL#9		; jump to that row on map (TDC)
	LDR	r3,[r1,#0]		; get xpos
	MOV	r3,r3,LSR#4		; round to nearest column
	ADD	r5,r5,r3,LSL#4		; move to that column on map (TDC)

	STMFD	r13!,{r4}		; hold on to button data

	TST	r4,#1<<4		; was fire pressed ?
	BLNE	man_handle_fire_pressed	; yes - sort it out

	; Are we in auto bomb drop mode?
	LDR	r3,mh_extra_data	; mystery array
	RSB	r4,r0,#4
	LDRB	r3,[r3,r4,LSL#1]
        CMP	r3,#1			; auto bomb drop mode?
	BNE	not_auto_bomb_drop_mode2

	LDRB	r3,[r1,#11]
	MOV	r3,r3,LSR#4
	CMP	r3,#2			; carrying a bomb?
	BEQ	not_auto_bomb_drop_mode2

	LDMIA	r1,{r3,r4}		; get xpos, ypos

	ORR	r3,r3,r4
	TST	r3,#8			; more than half a tile from set down point?

	BNE	not_auto_bomb_drop_mode2; yes - go!

	LDRB	r3,[r5,#2]		; get current tile extra1
	TST	r3,#1<<7		; anything there?
	BLEQ	man_handle_fire_pressed	; no - try to drop a bomb

not_auto_bomb_drop_mode2
	LDMFD	r13!,{r4}		; retrieve button data

	TST	r4,#1<<5		; fire 2 pressed?
	BLNE	man_handle_f2_pressed	; yes - sort this one out

man_moving_keys_done

	B	man_handle_death_check	; go and see if we're going to die...

handle_coughing_fit
	; handle coughing animation, but don't let man move...

	LDRB	r5,[r1,#18]		; get anim_ctr
	AND	r5,r5,#15
	CMP	r5,#8			; time for sfx?
	BNE	no_cough_sfx

	STMFD	r13!,{r0,r14}
	CMP	r4,#200
	MOVGT	r0,#14
	MOVLE	r0,#0
	BL	dsym_playinstr		; play either cough samp 0 or 14
	LDMFD	r13!,{r0,r14}

no_cough_sfx
	ADD	r5,r5,#1		; increment it
	CMP	r5,#64			; end of anim?
	MOVEQ	r5,#0			; if so, return to start of anim

	CMP	r4,#4
	MOVLT	r5,#0			; end of coughing anim..?

	STRB	r5,[r1,#18]

	; coughing state cannot be placed in the top bits of the status word, because we
	; will lose what the original action was.

	B	man_handle_death_check

man_handle_waiting
	LDMIA	r1,{r4,r5}		; get xpos,ypos

	; Are we leaking fuel?
	LDRB	r3,[r1,#10]
	TST	r3,#1<<4
	BEQ	man_not_standing_leaking

	MOV	r5,r5,LSR#4		; round to nearest row
	ADD	r5,r2,r5,LSL#9		; jump to that row on map (TDC)
	MOV	r4,r4,LSR#4		; round to nearest column
	ADD	r5,r5,r4,LSL#4		; move to that column on map (TDC)

	LDRB	r3,[r5,#0]		; tile status
	CMP	r3,#128			; can we leak on this tile?
	BNE	man_not_standing_leaking

	MOV	r3,#20+128
	STRB	r3,[r5,#0]
	MOV	r3,#62
	STRB	r3,[r5,#1]

man_not_standing_leaking
	; Are there any bonuses on this tile?
	; man_handle_data+16 = address of bonus array
	LDR	r3,man_handle_data+16

	LDMIA	r1,{r4,r5}		; man's coords
	MOV	r4,r4,ASR#4
	MOV	r5,r5,ASR#4

	MOV	r8,#128

standing_still_on_bonus
	LDRB	r9,[r3,#2]		; bonus status

	TST	r9,#1<<7		; active?
	BEQ	stood_on_next_bonus	; no - try next

	TST	r9,#1			; moving?
	BNE	stood_on_next_bonus	; yes - can't grab it.

	; compare coords
	LDRB	r10,[r3,#0]		; xpos
	CMP	r4,r10,ASR#3		; = bloke ypos?
	BNE	stood_on_next_bonus	; no - next!

	LDRB	r10,[r3,#1]		; ypos
	CMP	r5,r10,ASR#3		; = bloke ypos?
	BEQ	we_are_stood_on_bonus	; yes - deal with it.

stood_on_next_bonus
	ADD	r3,r3,#4		; next bonus

	SUBS	r8,r8,#1
	BNE	standing_still_on_bonus	; until all bonuses are checked

	B	mh_stood_still_rendez

we_are_stood_on_bonus
	ADD	r8,r2,r5,LSL#9
	ADD	r8,r8,r4,LSL#4		; tile coord

	MOV	r10,#0
	STRB	r10,[r8,#1]		; empty floor sprite
	MOV	r10,#128
	STRB	r10,[r8,#6]		; empty floor status
	STRB	r10,[r8,#0]

	MOV	r9,r9,ASR#3
	AND	r9,r9,#15		; r9 = bonus type.

	MOV	r10,#0
	STR	r10,[r3,#0]		; blank bonus entry

	; Here's where we interpret the action of the bonus...
	; I think.
	;SWI	263			; wow, what a bonus
	MOV	r12,r0
	MOV	r0,#11
	BL	dsym_playinstr		; play bonus pick-up noise
	MOV	r0,r12

	ADR	r12,post_static_bonus_rendez_vous
	ADR	r10,bonus_process_list
	LDR	pc,[r10,r9,LSL#2]	; branch to handle this bonus

post_static_bonus_rendez_vous
mh_stood_still_rendez
	LDR	r5,[r1,#4]		; get ypos
	MOV	r5,r5,LSR#4		; in number of tiles
	ADD	r5,r2,r5,LSL#9		; jump r5 rows of tiles in map (1 row = 32*16bytes) (TDC)
	LDR	r3,[r1,#0]		; get xpos
	MOV	r3,r3,LSR#4		; in number of tiles
	ADD	r5,r5,r3,LSL#4		; jump along row in map to tile man is on. (TDC)

	LDRB	r3,[r1,#12]		; get control word number
	LDR	r4,[r6,r3,LSL#2]	; get corresponding control word

	;CMP	r4,#0			; any response from user?
	;BEQ	man_handle_death_check	; no - see if we're going to die, stood here.

	STMFD	r13!,{r4}

	TST	r4,#1			; left pressed?
	BNE	man_handle_go_left

	TST	r4,#1<<1		; right pressed?
	BNE	man_handle_go_right

man_handle_rendez1
	LDRB	r4,[r1,#11]		; on the move again?
	TST	r4,#1
	BNE	man_handle_rendez2	; yes - don't try going up or down

	LDMFD	r13,{r4}		; *** Just look at value on stack ***

	TST	r4,#1<<2		; up pressed?
	BNE	man_handle_go_up

	TST	r4,#1<<3		; down pressed?
	BNE	man_handle_go_down

man_handle_rendez2

	LDMFD	r13,{r4}		; *** Just look at value on stack ***

	TST	r4,#1<<4		; fire pressed?
	BLNE	man_handle_fire_pressed

	; Are we in auto bomb drop mode?
	LDR	r3,mh_extra_data	; mystery array
	RSB	r4,r0,#4
	LDRB	r3,[r3,r4,LSL#1]
        CMP	r3,#1			; auto bomb drop mode?
	BNE	not_auto_bomb_drop_mode

	LDRB	r3,[r1,#11]
	MOV	r3,r3,LSR#4
	CMP	r3,#2			; carrying a bomb?
	BEQ	not_auto_bomb_drop_mode

	LDMIA	r1,{r3,r4}		; get xpos, ypos

	ORR	r3,r3,r4
	TST	r3,#8			; more than half a tile from set down point?

	BNE	not_auto_bomb_drop_mode	; yes - go!

	LDRB	r3,[r5,#2]		; get current tile extra1
	TST	r3,#1<<7		; anything there?
	BLEQ	man_handle_fire_pressed	; no - try to drop a bomb

not_auto_bomb_drop_mode
	LDMFD	r13!,{r4}		; retrieve key data

	TST	r4,#1<<5		; fire 2 pressed?
	BLNE	man_handle_f2_pressed

	; should be fire pressed... insert bomb drop code here.
	B	man_handle_death_check

man_handle_go_left
	LDRB	r4,[r1,#11]		; get status of man
	ANDS	r3,r4,#6
	BIC	r4,r4,#7
	STRB	r4,[r1,#11]		; set status to static left

	;BNE	man_handle_rendez1	; just turn if not facing left

	LDRB	r3,[r5,#-16]		; get status of tile to left (TDC)
	TST	r3,#1<<7		; can we walk on this tile?
	BEQ	man_handle_rendez1	; no we can't

	MOV	r9,#0			; direction
	SUB	r10,r5,#16		; address of tile (TDC)

	BL	man_handle_check_move	; make sure there are no bombs/nasties in the way
	CMP	r3,#0			; check failed?
	BEQ	man_handle_rendez1	; yes - branch

	LDRB	r3,[r10,#8]		; get men_here flags for destination tile
	RSB	r11,r0,#4
	MOV	r9,#1
	ORR	r3,r3,r9,LSL r11	; set flag to say this player is going there

	STRB	r3,[r10,#8]		; store new flags

	LDR	r3,[r1,#0]		; get xpos
	SUB	r3,r3,#2		; move
	STR	r3,[r1,#0]		; store

	MOV	r3,#7
	STRB	r3,[r1,#13]		; set anim_ctr to 8 - length of anim

	MOV	r3,#1
	STRB	r3,[r1,#18]		; set sprite num to 1

	ORR	r4,r4,#1		; set status to moving
	STRB	r4,[r1,#11]		; store new status

	B 	man_handle_rendez1	; done here...

man_handle_go_right
	LDRB	r4,[r1,#11]		; get status of man
	AND	r3,r4,#6
	BIC	r4,r4,#7
	ORR	r4,r4,#1<<1
	STRB	r4,[r1,#11]		; set status to static right

	;CMP	r3,#1<<1		; facing right?
	;BNE	man_handle_rendez1	; no - just turn round

	LDRB	r3,[r5,#16]		; get status of tile to right (TDC)
	TST	r3,#1<<7		; can we walk on this tile?
	BEQ	man_handle_rendez1	; no we can't

	MOV	r9,#1			; direction
	ADD	r10,r5,#16		; address of tile (TDC)

	BL	man_handle_check_move	; make sure there are no bombs/nasties in the way
	CMP	r3,#0			; check failed?
	BEQ	man_handle_rendez1	; yes - branch

	LDRB	r3,[r10,#8]		; get men_here flags for destination tile
	RSB	r11,r0,#4
	MOV	r9,#1
	ORR	r3,r3,r9,LSL r11	; set flag to say this player is going there

	STRB	r3,[r10,#8]		; store new flags

	LDR	r3,[r1,#0]		; get xpos
	ADD	r3,r3,#2		; move
	STR	r3,[r1,#0]		; store

	MOV	r3,#7
	STRB	r3,[r1,#13]		; set anim_ctr to 8 - length of anim

	MOV	r3,#1
	STRB	r3,[r1,#18]		; set sprite num to 1

	ORR	r4,r4,#1		; set status to moving
	STRB	r4,[r1,#11]		; store new status

	B 	man_handle_rendez1	; done here...

man_handle_go_up
	LDRB	r4,[r1,#11]		; get status of man
	AND	r3,r4,#6
	BIC	r4,r4,#7
	ORR	r4,r4,#2<<1
	STRB	r4,[r1,#11]		; set status to static up

	;CMP	r3,#2<<1                ; facing up?
	;BNE	man_handle_rendez2	; no - just turn round

	LDRB	r3,[r5,#-512]		; get status of tile above (TDC)
	TST	r3,#1<<7		; can we walk on this tile?
	BEQ	man_handle_rendez2	; no we can't

	MOV	r9,#2			; direction
	SUB	r10,r5,#512		; address of tile (TDC)

	BL	man_handle_check_move	; make sure there are no bombs/nasties in the way
	CMP	r3,#0			; check failed?
	BEQ	man_handle_rendez2	; yes - branch

	LDRB	r3,[r10,#8]		; get men_here flags for destination tile
	RSB	r11,r0,#4
	MOV	r9,#1
	ORR	r3,r3,r9,LSL r11	; set flag to say this player is going there

	STRB	r3,[r10,#8]		; store new flags

	LDR	r3,[r1,#4]		; get ypos
	SUB	r3,r3,#2		; move
	STR	r3,[r1,#4]		; store

	MOV	r3,#7
	STRB	r3,[r1,#13]		; set anim_ctr to 8 - length of anim

	MOV	r3,#1
	STRB	r3,[r1,#18]		; set sprite num to 1

	ORR	r4,r4,#1		; set status to moving
	STRB	r4,[r1,#11]		; store new status

	B 	man_handle_rendez2	; done here...

man_handle_go_down
	LDRB	r4,[r1,#11]		; get status of man
	AND	r3,r4,#6		; old direction
	BIC	r4,r4,#7
	ORR	r4,r4,#3<<1
	STRB	r4,[r1,#11]		; set status to static down

	;CMP	r3,#3<<1		; was old direction down?
	;BNE	man_handle_rendez2	; no - just turn round

	LDRB	r3,[r5,#512]		; get status of tile below (TDC)
	TST	r3,#1<<7		; can we walk on this tile?
	BEQ	man_handle_rendez2	; no we can't

	MOV	r9,#3			; direction
	ADD	r10,r5,#512		; address of tile (TDC)

	BL	man_handle_check_move	; make sure there are no bombs/nasties in the way
	CMP	r3,#0			; check failed?
	BEQ	man_handle_rendez2	; yes - branch

	LDRB	r3,[r10,#8]		; get men_here flags for destination tile
	RSB	r11,r0,#4
	MOV	r9,#1
	ORR	r3,r3,r9,LSL r11	; set flag to say this player is going there

	STRB	r3,[r10,#8]		; store new flags

	LDR	r3,[r1,#4]		; get ypos
	ADD	r3,r3,#2		; move
	STR	r3,[r1,#4]		; store

	MOV	r3,#7
	STRB	r3,[r1,#13]		; set anim_ctr to 8 - length of anim

	MOV	r3,#1
	STRB	r3,[r1,#18]		; set sprite num to 1

	ORR	r4,r4,#1		; set status to moving
	STRB	r4,[r1,#11]		; store new status

	B 	man_handle_rendez2	; done here...

	IMPORT	fuse_length

bomb_dropping_data
	DCD	fuse_length

man_handle_fire_pressed
	; if bombs is greater than bombs_layed,
	; and we are sat directly above a tile (no fractional part in xpos,ypos)
	; and there is no bomb below us
	; spawn another bomb at this point

	LDRB	r3,[r1,#11]
	MOV	r3,r3,LSR#4
	CMP	r3,#2			; carrying a bomb?
	BEQ	throw_bomb

	LDMIA	r1,{r3,r4}		; get xpos, ypos

	ORR	r3,r3,r4
	TST	r3,#8			; more than half a tile from set down point?

	MOVNE	pc,r14			; yes - go!

	LDRB	r3,[r5,#2]		; get current tile extra1
	TST	r3,#1<<7		; anything there?
	BNE	man_handle_can_we_pickup; yes - go!

	LDRB	r3,[r1,#8]		; number of bombs this player can drop
	LDRB	r4,[r1,#17]		; number of bombs active from this player

	AND	r4,r4,#127		; bit 7 indicated whether special bomb has been layed.

	CMP	r3,r4
	MOVLE	pc,r14

	; Are we in no bomb drop mode?
	LDR	r3,mh_extra_data
	RSB	r4,r0,#4
	LDRB	r3,[r3,r4,LSL#1]	; players entry in mystery[] array
	CMP	r3,#3			; No bombs?
	MOVEQ	pc,r14			; if so, we can't drop a bomb.

	; ok to drop bomb -
	; Find free bomb slot in bombs array
	; Set up details in that array entry
	; update bombs_layed entry for player
	; link bomb to map

	MOV	r3,#0
	MOV	r4,r7

find_empty_bomb_loop
	LDRB	r9,[r4,#11]		; get bomb status
	TST	r9,#1<<4		; does bomb exist?
	BEQ	found_empty_bomb	; yes - use this slot

	ADD	r3,r3,#1
	ADD	r4,r4,#16		; inc pointer and count

	CMP	r3,#64
	BLT	find_empty_bomb_loop

	MOV	pc,r14			; No slot was found... quietly exit.

found_empty_bomb
	STMFD	r13!,{r14}		; free a register

	; r3 contains bomb number, r4 contains bomb address

	LDR	r9,[r1,#0]
	BIC	r9,r9,#15
	STR	r9,[r4,#0]		; bomb.xpos = player.xpos to nearest column

	LDR	r9,[r1,#4]
	BIC	r9,r9,#15
	STR	r9,[r4,#4]		; bomb.ypos = player.ypos to nearest row

	RSB	r9,r0,#4		; get player number
	STRB	r9,[r4,#8]		; this player is the owner

	MOV	r9,r0
	MOV	r0,#8
	BL	dsym_playinstr		; Play bomb drop sound effect
	MOV	r0,r9

	; Get fuse length
	LDR	r9,bomb_dropping_data
	LDR	r9,[r9,#0]
	STRB	r9,[r4,#9]		; set timer according to fuse_length

	LDRB	r9,[r1,#10]
	MOV	r9,r9,LSR#2
	AND	r9,r9,#3		; player's bomb type

	LDRB	r14,[r1,#17]		; mega/flower bomb currently active?
	TST	r14,#128

	BEQ	bomb_type_chosen

	CMP	r9,#3			; it is - reset mega/flower bomb to normal
	MOVNE	r9,#0

bomb_type_chosen
	STRB	r9,[r4,#10]		; set bomb type

	MOV	r9,#1<<4
	STRB	r9,[r4,#11]		; static bomb, on ground and exists

	; bomb control block complete. Link bomb to map

	ORR	r9,r3,#1<<7
	STRB	r9,[r5,#2]		; use extra1 - bomb link

	LDRB	r3,[r1,#17]		; number of bombs layed

	LDRB	r9,[r4,#10]		; bomb type
	CMP	r9,#1
	ORREQ	r3,r3,#128              ; mega bomb active
	CMP	r9,#2
	ORREQ	r3,r3,#128		; flower bomb active

	ADD	r3,r3,#1		; increment it
	STRB	r3,[r1,#17]		; store it

	LDMFD	r13!,{pc}

throw_bomb
	LDMIA	r1,{r3,r4}		; get xpos, ypos

	ORR	r3,r3,r4
	TST	r3,#15			; tile aligned?

	MOVNE	pc,r14			; no - go!

	LDRB	r3,[r1,#11]		; get status
	AND	r3,r3,#&f
	ORR	r3,r3,#3<<4		; throw action
	STRB	r3,[r1,#11]
	MOV	pc,r14

man_handle_can_we_pickup
	; If we have just tried to lay a bomb on a tile containing one of our bombs, pick that
	; bomb up

	; r7 - active bomb array
	; r3 - extra1 from blocked tile
	; r1 - this players control block

	;TST	r3,#1<<6		; is it a bomb?
	;MOVNE	pc,r14			; no!

	; Item linked through extra1 can ONLY be a bomb

	; Player can only pick up bomb if they are stationary

	LDRB	r4,[r1,#11]		; player status
	TST	r4,#1			; moving?
	MOVNE	pc,r14			; yes - leave

	LDRB	r4,[r1,#10]
	TST	r4,#1<<1		; can we throw bombs?
	MOVEQ	pc,r14			; apparently not.

	AND	r3,r3,#63		; bomb number
	ADD	r4,r7,r3,LSL#4		; bomb control block address
	LDRB	r3,[r4,#8]		; get bomb owner
	RSB	r9,r0,#4		; our bloke
	CMP	r9,r3			; are they the same bloke?

	MOVNE	pc,r14			; no!

	; Is bomb moving?
	LDRB	r3,[r4,#11]		; get bomb status
	TST	r3,#1			; is bomb moving?
	MOVNE	pc,r14			; yes - u can't touch this! Hammer time! etc

	; Is bomb old enough to pick up? *** CHECK VARIABLE TIMERS ****
	LDR	r9,throw_bomb_data
	LDR	r9,[r9,#0]		; get initial bomb timer
	LDRB	r3,[r4,#9]		; get current bomb timer
	SUB	r9,r9,r3		; time elapsed since bomb drop
	CMP	r9,#30			; >30 frames?
	MOVLT	pc,r14			; no - too young - leave

	; Was bomb a mega/flower bomb?
	LDRB	r9,[r1,#17]		; mega/flower bomb currently active?
	LDRB	r3,[r4,#10]		; bomb type
	CMP	r3,#1
	BICEQ	r9,r9,#128              ; mega bomb -> deactivate
	CMP	r3,#2
	BICEQ	r9,r9,#128		; flower bomb -> deactivate
	STRB	r9,[r1,#17]		; mega/flower bomb status rectified

	; delete bombs existance

	MOV	r3,#0
	STRB	r3,[r4,#11]		; remove bomb from bomb array

	; must delete bomb from map
	MOV	r3,#0
	STRB	r3,[r5,#2]		; clear extra1

start_pickup
	LDRB	r3,[r1,#11]		; get player status
	AND	r3,r3,#&f
	ORR	r3,r3,#1<<4		; "pick up" action
	STRB	r3,[r1,#11]

	MOV	r3,#0
	STRB	r3,[r1,#18]		; start animation at 0

	MOV	pc,r14

man_handle_f2_pressed
	; This will cause all bombs pushed by this player to stop in their tracks.

	MOV	r3,#0
	MOV	r4,r7
	RSB	r10,r0,#4		; player number

find_pushed_bomb_loop
	LDRB	r9,[r4,#12]		; who was bomb last pushed by?
	CMP	r9,r10			; was it us?
	BNE	next_pushed_bomb	; no - next!

	LDRB	r9,[r4,#11]		; get bomb status
	TST	r9,#1<<4		; does bomb exist?
	BEQ	next_pushed_bomb	; no - next!

	TST	r9,#1			; is bomb moving?
	ORRNE	r9,r9,#1<<5		; yes - signal to stop bomb
	STRNEB	r9,[r4,#11]		; yes - store new bomb status

next_pushed_bomb
	ADD	r3,r3,#1
	ADD	r4,r4,#16		; inc pointer and count

	CMP	r3,#64
	BLT	find_pushed_bomb_loop

	MOV	pc,r14

man_handle_death_check
	; Examine tiles(s) at current position. If any are explosion, then kill.
	; Examine position of nasties that kill on touch. If any are within range, then kill.

	; First, are we invulnerable?
	LDRB	r3,[r1,#11]		; get status
	TST	r3,#1<<3		; invulnerable?
	BNE	man_handle_done_with_this_man ; yes - we can't be harmed.

	LDMIA	r1,{r3,r4}		; get players xpos,ypos
	ADD	r3,r3,#8
	ADD	r4,r4,#8
	MOV	r3,r3,ASR#4
	MOV	r4,r4,ASR#4		; tile position, rounded to nearest tile

	ADD	r5,r2,r4,LSL#9		; (*32*16) ypos offset in map data
	ADD	r5,r5,r3,LSL#4		; (*16) xpos offset in map data - r5 = tile address

	LDRB	r3,[r5,#4]		; is there a blast covering this tile?
	CMP	r3,#0
	BEQ	how_about_a_nasty	; no but is there a nasty?

	LDRB	r3,[r5,#5]		; how old is the blast?
	CMP	r3,#3
	BGE	init_man_death		; young enough to do some harm

how_about_a_nasty
	; Check for contact with a nasty

	LDRB	r3,[r5,#3]		; tile extra2
	TST	r3,#1<<7		; something there?
	BEQ	man_handle_done_with_this_man ; apparently not.

	; DEBUG!!!
	;B	man_handle_done_with_this_man ; stop enemies killing us

weve_touched_an_enemy
	; r3 contains the enemy number. look him up to see if contact is deadly.
	AND	r3,r3,#63

	LDR	r4,how_about_a_nasty_data

	ADD	r4,r4,r3,LSL#4		; each enemy control block is 16 bytes

	LDRB	r3,[r4,#10]		; get enemy status
	TST	r3,#1<<3		; is it dying?
	BNE	man_handle_done_with_this_man ; yes - can't do us any harm now

	CMP	r3,#0			; is it dead?
	BEQ	man_handle_done_with_this_man ; yes, but if the rest of the code was working
					; properly, we would never have detected this enemy in
					; the first place...

	LDRB	r3,[r4,#9]		; get enemy abilities
	TST	r3,#2			; is contact deadly?
	BEQ	man_handle_done_with_this_man ; no - we're ok.

	; At this point we are in contact with an enemy with whom contact is
	; supposed to be deadly. The only exception is if the enemy is a SPRYT
	; and we are wearing the plasma absorption suit.
	;
	; If the abilities indicate that this enemy cannot be blown up, it
	; can be destroyed by physical contact in a plasma absorption suit.
	; Oh, it's all getting so complicated...

	TST	r3,#1			; is enemy blow uppable?
	BNE	init_man_death		; yes - this'll hurt

	LDRB	r3,[r1,#10]		; get players extra flags
	TST	r3,#1<<7		; *** BIT THAT INDICATES PLASMA SUIT ***
	BEQ	init_man_death		; oops - no suit!

	; It's ok... we're wearing a suit.

	B	man_handle_done_with_this_man

	IMPORT	nme_unit

how_about_a_nasty_data
	DCD	nme_unit

man_deth_samp
	DCB	6,19,20,21

init_man_death
	MOV	r3,#0
	STRB	r3,[r1,#13]             ; anim_ctr = 0 -> not really dead (yet)
	STRB	r3,[r1,#18]		; start death animation

	MOV	r3,r0
	BL	rnd
	AND	r0,r0,#3
	ADR	r5,man_deth_samp
	LDRB	r0,[r5,r0]
	BL	dsym_playinstr		; Play man death sound effect
	MOV	r0,r3

	LDRB	r3,[r1,#11]		; get status
	AND	r3,r3,#&f
	ORR	r3,r3,#5<<4		; set current action to dying
	STRB	r3,[r1,#11]		; store new status

	; Clear floured status
	LDRB	r5,[r1,#10]
	BIC	r5,r5,#1<<5
	STRB	r5,[r1,#10]

	; Set timer back to 0
	MOV	r5,#0
	STRB	r5,[r1,#16]

	; Must remove this player from map data as well.
	RSB	r4,r0,#4
	MOV	r3,#1
	MOV	r3,r3,LSL r4		; bit for this player

	LDMIA	r1,{r4,r5}		; player xpos,ypos

	MOV	r4,r4,ASR#4
	MOV	r5,r5,ASR#4		; tile position

	ADD	r8,r2,r5,LSL#9		; y offset
	ADD	r8,r8,r4,LSL#4          ; x offset => tile data address

	LDRB	r4,[r8,#-16+8]		; tile to left, men_here
	BIC	r4,r4,r3		; mask out our dead man
	STRB	r4,[r8,#-16+8]

	LDRB	r4,[r8,#8]		; current tile, men_here
	BIC	r4,r4,r3		; mask out our dead man
	STRB	r4,[r8,#8]

	LDRB	r4,[r8,#16+8]		; tile to right, men_here
	BIC	r4,r4,r3		; mask out our dead man
	STRB	r4,[r8,#16+8]

	SUB	r8,r8,#32*16		; tile above

	LDRB	r4,[r8,#8]		; men_here
	BIC	r4,r4,r3		; mask out our dead man
	STRB	r4,[r8,#8]

	ADD	r8,r8,#2*32*16		; tile below

	LDRB	r4,[r8,#8]		; men_here
	BIC	r4,r4,r3		; mask out our dead man
	STRB	r4,[r8,#8]

	B	man_handle_done_with_this_man

man_handle_stunned
	LDRB	r4,[r1,#18]		; get sprite_num
	ADD	r4,r4,#1		; increment
	ANDS	r4,r4,#63		; keep in range 0..63
	STRB	r4,[r1,#18]		; put back new sprite_num

	BNE	man_handle_death_check

	; Animation is complete - He's ok
	AND	r3,r3,#&0f		; set action to 0
	STRB	r3,[r1,#11]		; store new status

	B	man_handle_death_check

man_handle_dying
	; Play death animation. When complete, if any lives are left, return man as invunerable.
	; If no lives are left, leave anim_ctr as 255 and the dying flag set.

	LDRB	r4,[r1,#13]
	CMP	r4,#255			; Is he really dead?
	BEQ	man_handle_done_with_this_man	; yup.

	LDRB	r4,[r1,#18]		; get sprite_num
	ADD	r4,r4,#1		; increment
	ANDS	r4,r4,#31		; keep in range 0..31
	STRB	r4,[r1,#18]		; put back new sprite_num

	BNE	man_handle_done_with_this_man

	; Animation is complete - He's dead

	LDRB	r4,[r1,#15]		; get number of lives
	SUBS	r4,r4,#1		; lose one
	STRB	r4,[r1,#15]		; store new value

	BEQ	make_man_really_dead	; when all lives have gone, don't come back

	BL	hud_update_lives

	; He's got another life -> reincarnate
	LDMIA	r1,{r3,r4}		; xpos,ypos
	BIC	r3,r3,#&f
	BIC	r4,r4,#&f		; Lock to tile
	STMIA	r1,{r3,r4}		; store new coords

	ADD	r4,r2,r4,LSL#5		; yoffset
	ADD	r4,r4,r3                ; xoffset => tile address

	RSB	r3,r0,#4
	MOV	r5,#1
	MOV	r5,r5,LSL r3		; bit for this player

	LDRB	r3,[r4,#8]
	ORR	r3,r3,r5
	STRB	r3,[r4,#8]		; set men_here flag on our tile

	MOV	r3,#0
	STRB	r3,[r1,#13]
	STRB	r3,[r1,#18]		; clear animation counters

	LDRB	r4,[r1,#11]		; player status
	AND	r4,r4,#6		; action = 0, not moving
	ORR	r4,r4,#1<<3             ; invulnerable
	STRB	r4,[r1,#11]

	MOV	r4,#250
	STRB	r4,[r1,#16]		; set status counter - length of invulnerable mode

	; **** RESET MYSTERY EFFECTS! ****
	STMFD	r13!,{r0,r2}		; gimme some spare regs
	RSB	r0,r0,#4		; player number
	LDR	r2,reincarnate_myst	; mystery array
	ADD	r2,r2,r0,LSL#1		; this players entry

	MOV	r0,#0
	STRB	r0,[r2,#0]
	STRB	r0,[r2,#1]		; Cancel any mystery effect

	; Make sure this doesn't leave us leaking fuel
	LDRB	r0,[r1,#10]		; extra flags
	BIC	r0,r0,#1<<4		; clear leak flag
	STRB	r0,[r1,#10]

	LDMFD	r13!,{r0,r2}		; restore those registers

	B	man_handle_done_with_this_man

reincarnate_myst
	DCD	mystery

make_man_really_dead
	BL	hud_update_lives

	MOV	r4,#255
	STRB	r4,[r1,#13]		; indicates he's really dead

	B	man_handle_done_with_this_man

man_handle_pick_up
	; Continue action of picking up bomb at current position

	LDRB	r4,[r1,#18]		; get sprite_num
	ADD	r4,r4,#1		; increment
	ANDS	r4,r4,#7		; keep in range 0..7
	STRB	r4,[r1,#18]		; put back new sprite_num

	BNE	man_handle_death_check	; animation not finished

	LDRB	r4,[r1,#11]		; get status
	AND	r4,r4,#&f
	ORR	r4,r4,#2<<4		; bomb carrying action
	STRB	r4,[r1,#11]

	B	man_handle_death_check

man_handle_throw
	; Continue action of throwing bomb from current location


	LDRB	r4,[r1,#18]		; get sprite_num
	ADD	r4,r4,#1		; increment

	CMP	r4,#5			; Time to throw bomb?
	BLEQ	man_throw_bomb

	ANDS	r4,r4,#7		; keep in range 0..7
	STRB	r4,[r1,#18]		; put back new sprite_num

	; On frame 5, we will need to spawn a new thrown bomb

	BNE	man_handle_death_check	; animation not finished

	LDRB	r4,[r1,#11]		; get status
	AND	r4,r4,#&f		; reset to normal action
	STRB	r4,[r1,#11]

	B	man_handle_death_check

man_handle_done_with_this_man
	ADD	r1,r1,#32		; next player control block

	SUBS	r0,r0,#1
	BNE	handle_each_man		; while more players, 'do' them.

	LDMFD	r13!,{r0-r12,pc}	; restore registers, then leave

man_handle_check_move
	; r9 contains direction wanted to move
	; r10 contains address of destination tile

	LDRB	r3,[r10,#2]		; get extra1
	TST	r3,#1<<7		; contains bomb?
	BEQ	man_handle_check2	; no - check extra2

	; it must be a bomb...

	AND	r3,r3,#63		; get bomb number
	ADD	r8,r7,r3,LSL#4		; get address of bomb control block
	LDRB	r3,[r8,#11]		; get bomb status

	TST	r3,#1			; is bomb moving?
	BEQ	push_bomb		; no, but we'll try to make it

	AND	r3,r3,#6		; isolate direction
	MOV	r3,r3,LSR#1
	CMP	r3,r9			; same as man?
	MOVNE	r3,#0
	MOVNE	pc,r14			; no - can't move

man_handle_check2
	LDRB	r3,[r10,#3]		; get extra1
	TST	r3,#1<<7		; contains nasty?
	MOVEQ	r3,#1
	MOVEQ	pc,r14			; no - can return to move

	; it must be an enemy...

	MOV	r3,#1
	MOV	pc,r14			; no - return to move, though nasty check will go here

push_bomb
	LDRB	r3,[r1,#10]		; get players 'extra_flags'

	TST	r3,#1			; can this player push bombs?

	MOVEQ	r3,#0
	MOVEQ	pc,r14			; no - can't move

	; Yes, he can push, but will bomb move in direction in r9?

	CMP	r9,#0
	SUBEQ	r11,r10,#16		; (TDC)
	CMP	r9,#1
	ADDEQ	r11,r10,#16		; (TDC)
	CMP	r9,#2
	SUBEQ	r11,r10,#512		; (TDC)
	CMP	r9,#3
	ADDEQ	r11,r10,#512		; r11 = bombs destn tile address (TDC)

	LDRB	r3,[r11,#0]		; get tile status
	TST	r3,#1<<7		; can we push onto this tile?
	MOVEQ	r3,#0
	MOVEQ	pc,r14			; Nope. Go back

	LDRB	r3,[r8,#10]		; bomb type
	CMP	r3,#1			; Mega bomb?
	BNE	pb_over_man		; yes - able to push over other player

	LDRB	r3,[r11,#8]		; any players on destination tile?
	CMP	r3,#0
	MOVNE	r3,#0
	MOVNE	pc,r14			; yes - return unable to move

pb_over_man
	LDRB	r3,[r11,#2]		; get extra1
	TST	r3,#1<<7		; contains bomb?
	BEQ	bomb_push_check2	; no - check extra2

	; it must be a bomb...

	AND	r3,r3,#63		; get bomb number
	ADD	r8,r7,r3,LSL#4		; get address of bomb control block
	LDRB	r3,[r8,#11]		; get bomb status

	TST	r3,#1			; is bomb moving?
	MOVEQ	r3,#0
	MOVEQ	pc,r14			; no - can't move

	AND	r3,r3,#6		; isolate direction
	MOV	r3,r3,LSR#1
	CMP	r3,r9			; same as our bomb?
	MOVNE	r3,#0
	MOVNE	pc,r14			; no - can't move

bomb_push_check2
	LDRB	r3,[r11,#3]		; get extra2
	TST	r3,#1<<7		; contains nasty?
	BEQ	able_to_push_bomb	; no - can push bomb

	; it must be an enemy...
	MOV	r3,#1
	MOV	pc,r14			; return to move, though nasty check will go here

able_to_push_bomb
	; assuming r10 contains address of tile with bomb

	LDRB	r3,[r10,#2]		; get extra1

	; r11 contains address of destination tile. We must register this
	; bomb in this tile

	STRB	r3,[r11,#2]		; store in dest tile extra1

	AND	r3,r3,#63		; get bomb number

	ADD	r11,r7,r3,LSL#4		; find address of bomb to move

	; r11 - addr of bomb being pushed
	; r9 - direction to push

	LDRB	r3,[r11,#11]		; get bomb status

	BIC	r3,r3,#7		; clear movement and direction bits
	ORR	r3,r3,r9,LSL#1
	ORR	r3,r3,#1		; bomb is moving in direction in r9

	STRB	r3,[r11,#11]		; store new bomb status

	RSB	r3,r0,#4		; get player number
	STRB	r3,[r11,#12]		; indicate that this player pushed this bomb.

	; finished pushing bomb
	MOV	r3,#1			; successful move return code
	MOV	pc,r14			; return

throw_bomb_data
	DCD	fuse_length

man_throw_bomb
	; r0 is reversed man number (ie. 4-r0 = man number)
	; preserve all registers on stack

	STMFD	r13!,{r1-r5,r14}

	; Must create new bomb - first find a free slot in bomb array

	MOV	r1,r0
	MOV	r0,#10
	BL	dsym_playinstr		; Play bomb throw sound effect
	MOV	r0,r1

	LDR	r1,bomb_handler_data+8	; address of bombs

	MOV	r2,#0

find_throw_bomb_slot
	LDRB	r3,[r1,#11]		; get bomb status
	TST	r3,#1<<4		; is this slot in use
	BEQ	found_throw_bomb_slot	; no - let's use it

	ADD	r1,r1,#16		; next bomb
	ADD	r2,r2,#1
	CMP	r2,#64			; all slots checked?
	BLT	find_throw_bomb_slot

	; if we arrive here, there were no free bomb slots - we must abort!
	; Decrement active bomb number for this player.
	LDR	r1,bomb_handler_data	; address of player block
	RSB	r2,r0,#4		; actual player number
	ADD	r1,r1,r2,LSL#5		; address of this players control block
	LDRB	r2,[r1,#17]		; bombs layed
	SUB	r2,r2,#1
	STRB	r2,[r1,#17]		; bombs layed - 1

	LDMFD	r13!,{r1-r5,pc}		; restore regs and return

found_throw_bomb_slot
	; r1 contains the address of the bomb
	; man must be tile aligned before throwing can commence

	LDR	r2,bomb_handler_data
	RSB	r3,r0,#4
	ADD	r2,r2,r3,LSL#5		; address of this players control block

	LDMIA	r2,{r4,r5}		; players x,y position
	STMIA	r1,{r4,r5}		; transfer to bomb coords

	STRB	r3,[r1,#8]		; this player owns this bomb

	LDRB	r3,[r2,#11]		; players status
	AND	r3,r3,#6		; isolate players direction
	ORR	r3,r3,#9+16		; set moving/in air bits
	STRB	r3,[r1,#11]		; and use as bomb status

	LDR	r3,throw_bomb_data
	LDR	r3,[r3,#0]		; set bomb timer according to fuse_length
	STRB	r3,[r1,#9]

	MOV	r3,#0			; it's a normal bomb
	STRB	r3,[r1,#10]
	STRB	r3,[r1,#13]		; start of arc through air

	; That's it, I think...

	LDMFD	r13!,{r1-r5,pc}		; restore regs and return

;------------------------------------------------------------------------------
; Random number generator
;

rnd_seed
	DCB	'p','a','u','l'
;	DCD	&883ab7f0

	EXPORT	rnd_seed
rnd
	EXPORT	rnd

	; On exit, r0 contains random seed

	LDR	r0,rnd_seed
	ADD	r0,r0,r0,ASR#1
	STR	r0,rnd_seed

	MOV	pc,r14

rnd_seed_unsync
	DCB	'p','a','u','l'

rnd_unsync
	EXPORT	rnd_unsync

	; On exit, r0 contains random seed

	LDR	r0,rnd_seed_unsync
	ADD	r0,r0,r0,ASR#1
	STR	r0,rnd_seed_unsync

	MOV	pc,r14

;------------------------------------------------------------------------------
; Bonus handling routines
;   On entry, r1 contains address of man who picked up this bonus

bh_extra_flame
	STMFD	r13!,{r0,r12}
	LDRB	r10,[r1,#9]		; flame size
	ADD	r10,r10,#1		; increment it
	STRB	r10,[r1,#9]		; store it

	RSB	r0,r0,#4		; get man number
	BL	hud_update_flame

	LDMFD	r13!,{r0,pc}		; branch back to rendez-vous

bh_extra_bomb
	STMFD	r13!,{r0,r12}
	LDRB	r10,[r1,#8]		; bomb count
	ADD	r10,r10,#1		; increment it
	STRB	r10,[r1,#8]		; store it

	RSB	r0,r0,#4		; get man number
	BL	hud_update_bomb

	LDMFD	r13!,{r0,pc}		; branch back to rendez-vous

bh_mega_bomb
	STMFD	r13!,{r0,r12}
	LDRB	r10,[r1,#10]		; get extra flags
	BIC	r10,r10,#8+4		; clear bomb type
	ORR	r10,r10,#1<<2		; insert mega bomb flags
	STRB	r10,[r1,#10]

	RSB	r0,r0,#4		; get man number
	BL	hud_mega_bomb

	LDMFD	r13!,{r0,pc}		; branch back to rendez-vous

bh_rubber_bombs
	STMFD	r13!,{r0,r12}
	LDRB	r10,[r1,#10]		; get extra flags
	BIC	r10,r10,#8+4		; clear bomb type
	ORR	r10,r10,#3<<2		; insert bouncing bomb flags
	STRB	r10,[r1,#10]

	RSB	r0,r0,#4		; get man number
	BL	hud_rubber_bomb

	LDMFD	r13!,{r0,pc}		; branch back to rendez-vous

bh_flower_bombs
	STMFD	r13!,{r0,r12}
	LDRB	r10,[r1,#10]		; get extra flags
	BIC	r10,r10,#8+4		; clear bomb type
	ORR	r10,r10,#2<<2		; insert flower bomb flags
	STRB	r10,[r1,#10]

	RSB	r0,r0,#4		; get man number
	BL	hud_flower_bomb

	LDMFD	r13!,{r0,pc}		; branch back to rendez-vous

bh_push_ability
	STMFD	r13!,{r0,r12}
	LDRB	r10,[r1,#10]		; get extra flags
	ORR	r10,r10,#1		; set push flag
	STRB	r10,[r1,#10]

	RSB	r0,r0,#4		; get man number
	BL	hud_pushing

	LDMFD	r13!,{r0,pc}		; branch back to rendez-vous

bh_throw_ability
	STMFD	r13!,{r0,r12}
	LDRB	r10,[r1,#10]		; get extra flags
	ORR	r10,r10,#2		; set throw flag
	STRB	r10,[r1,#10]

	RSB	r0,r0,#4		; get man number
	BL	hud_throwing

	LDMFD	r13!,{r0,pc}		; branch back to rendez-vous

bh_protection_suit
	STMFD	r13!,{r0,r12}

	LDRB	r10,[r1,#10]		; get extra flags
	ORR	r10,r10,#1<<7		; plasma protection suit bit
	STRB	r10,[r1,#10]

	RSB	r0,r0,#4		; get man number
	BL	hud_plasma_suit

	LDMFD	r13!,{r0,pc}		; branch back to rendez-vous

	IMPORT	global_game_type
bh_mystery_data
	DCD	mystery
	DCD	global_game_type

mystery_calls
	DCD	myst_auto_bomb_drop
	DCD	myst_mini_bombs
	DCD	myst_no_bombs
	DCD	myst_fuel_leak
	DCD	myst_invulnerable
	DCD	myst_extra_life
	DCD	myst_auto_bomb_exp
	DCD	myst_extra_bomb_or_flame

bh_mystery
	; r0 - man number (reversed)
	; r1 - man control block

	; Return address is held in r12!

	STMFD	r13!,{r0-r4,r12}

	;MOV	r2,r0
	;BL	rnd
	;AND	r3,r0,#7		; random bonus effect
	;MOV	r0,r2

	ADRL	r3,scan_clock
	LDR	r3,[r3,#0]
	AND	r3,r3,#7		; use bottom bits of scan clock as 'random' factor

	CMP	r3,#2			; no bombs?
	BNE	mystery_ok

	LDR	r4,bh_mystery_data+4
	LDR	r4,[r4,#0]
	CMP	r4,#2			; single player game + no bombs?

	MOVEQ	r3,#7			; yes - unacceptable - do extra bomb/flame instead.

mystery_ok
	RSB	r0,r0,#4		; get unreversed player number

	CMP	r3,#7
	BEQ	mystery_no_message

	STMFD	r13!,{r1}
	ADD	r1,r3,#66		; messages start at offset 66
	BL	new_hud_msg_asm
	LDMFD	r13!,{r1}

mystery_no_message
	LDR	r4,bh_mystery_data

	; Vary bonus effect according to r3...
	ADR	r2,mystery_calls
	LDR	pc,[r2,r3,LSL#2]

	MOVNV	r0,r0
	MOVNV	r0,r0			; paranoid

myst_auto_bomb_drop
	; Drop bombs continually, while timer lasts.
	LDRB	r3,[r1,#11]		; player status
	TST	r3,#1<<3		; invulnerable?
	LDMNEFD	r13!,{r0-r4,pc}		; yes - this bonus has no effect!

	ADD	r4,r4,r0,LSL#1		; offset to this players mystery[] entry

	MOV	r3,#1
	STRB	r3,[r4,#0]		; auto bomb drop is mystery code 1

	MOV	r3,#255
	STRB	r3,[r4,#1]		; lasts for 255 mystery ticks

	LDMFD	r13!,{r0-r4,pc}

myst_mini_bombs
	; All normal bombs dropped have length of 1 unit
	ADD	r4,r4,r0,LSL#1		; offset to this players mystery[] entry

	MOV	r3,#2
	STRB	r3,[r4,#0]		; mini bombs effect is mystery code 2

	MOV	r3,#255
	STRB	r3,[r4,#1]		; lasts for 255 mystery ticks

	LDMFD	r13!,{r0-r4,pc}

myst_no_bombs
	; Cannot drop any bombs
	ADD	r4,r4,r0,LSL#1		; offset to this players mystery[] entry

	MOV	r3,#3
	STRB	r3,[r4,#0]		; no bombs effect is mystery code 3

	MOV	r3,#255
	STRB	r3,[r4,#1]		; lasts for 255 mystery ticks

	LDMFD	r13!,{r0-r4,pc}

myst_fuel_leak
	; Causes player to leak fuel
	ADD	r4,r4,r0,LSL#1		; offset to this players mystery[] entry

	MOV	r3,#4
	STRB	r3,[r4,#0]		; fuel leak is mystery code 4

	MOV	r3,#255
	STRB	r3,[r4,#1]		; lasts for 255 mystery ticks

	LDRB	r3,[r1,#10]		; get player extras byte
	ORR	r3,r3,#1<<4		; set leak bit
	STRB	r3,[r1,#10]		; store new extras byte

	LDMFD	r13!,{r0-r4,pc}

myst_invulnerable
	; Triggers invulnerability cycle
	LDRB	r3,[r1,#11]		; get player status byte
	ORR	r3,r3,#1<<3		; set invulnerable bit
	STRB	r3,[r1,#11]		; store new status byte

	LDMFD	r13!,{r0-r4,pc}

myst_extra_life
	; Give player an extra life
	LDRB	r3,[r1,#15]		; get current lives count
	ADD	r3,r3,#1
	STRB	r3,[r1,#15]

	STMFD	r13!,{r5,r6}

	MOV	r2,r3			; lives count
	MOV	r4,#5			; max number to print = 99
	BL	hud_int_to_asc

	LDMFD	r13!,{r5,r6}

	LDR	r2,hud_update_data
	LDRB	r0,[r2,r0]		; x offset of this players hud
	ADD	r1,r0,#16		; x offset to lives count
	MOV	r2,#21			; y offset to lives count
	ADR	r0,hud_workspace	; string to draw

	BL	draw_small_string

	LDMFD	r13!,{r0-r4,pc}

myst_auto_bomb_data
	DCD	bombs

myst_auto_bomb_exp
	; Set timer of all active bombs to 2
	LDR	r2,myst_auto_bomb_data

	MOV	r4,#64			; 64 possible bombs to scan
myst_auto_bomb_scan
	LDRB	r3,[r2,#11]		; get bomb status
	TST	r3,#1<<4		; exists?
	BEQ	myst_auto_bomb_scan_next ; no - jump

	LDRB	r3,[r2,#9]		; get current timer
	CMP	r3,#2			; higher than 2?
	MOVGT	r3,#2			; yes - change
	STRB	r3,[r2,#9]		; store new timer

myst_auto_bomb_scan_next
	ADD	r2,r2,#16		; next bomb
	SUBS	r4,r4,#1
	BNE	myst_auto_bomb_scan	; do all bombs

	LDMFD	r13!,{r0-r4,pc}

myst_extra_bomb_or_flame
	MOV	r3,r0
	BL	rnd
	TST	r0,#64			; toss the coin
	MOV	r0,r3

	BEQ	myst_extra_bomb		; check the coin

	; extra flame
	LDRB	r3,[r1,#9]		; flame size
	ADD	r3,r3,#1		; increment it
	STRB	r3,[r1,#9]		; store it

	BL	hud_update_flame

	LDMFD	r13!,{r0-r4,pc}

myst_extra_bomb
	LDRB	r3,[r1,#8]		; bomb count
	ADD	r3,r3,#1		; increment it
	STRB	r3,[r1,#8]		; store it

	BL	hud_update_bomb

	LDMFD	r13!,{r0-r4,pc}


	IMPORT	hud_pos
	IMPORT	msg
	IMPORT	hud_mess

hud_update_data
	DCD	hud_pos
	DCD	0
	DCD	draw_small_string
	DCD	msg
	DCD	hud_mess

hud_workspace
	DCD	0
	DCD	0
	DCD	0

hud_int_to_asc_ref
	DCD	1000000
	DCD	100000
	DCD	10000
	DCD	1000
	DCD	100
	DCD	10
	DCD	0

hud_int_to_asc
	; r2 contains integer
	; r4 contains offset to first power
	; convert integer to ascii

	ADR	r3,hud_workspace
	ADR	r5,hud_int_to_asc_ref
	ADD	r5,r5,r4,LSL#2

hud_itoa_digit
	MOV	r4,#'0'
	LDR	r6,[r5],#4		; next lower power of 10
	CMP	r6,#0			; down to units?
	BEQ	hud_itoa_end

hud_itoa_count				; count this power of ten
	CMP	r2,r6
	SUBGE	r2,r2,r6
	ADDGE	r4,r4,#1
	BGE	hud_itoa_count

	STRB	r4,[r3],#1		; store digit
	B	hud_itoa_digit

hud_itoa_end
	ADD	r4,r4,r2		; unit value
	STRB	r4,[r3],#1
	STRB	r6,[r3,#0]		; end of string character

	MOV	pc,r14

new_hud_msg_asm
	; On entry,
	;   r0 - man number
	;   r1 - msg number

	STMFD	r13!,{r0-r3,r14}

	ADR	r2,hud_update_data+12
	LDMIA	r2,{r2,r3}

	ADD	r3,r3,r0,LSL#3		; hud_mess data is 8 bytes long

	LDR	r2,[r2,r1,LSL#2]	; address of string
	STR	r2,[r3,#0]		; store string start

	MOV	r0,#0

new_hud_mess_len			; Count length of message
	LDRB	r1,[r2,r0]

	CMP	r1,#0
	ADDNE	r0,r0,#1
	BNE	new_hud_mess_len

	STRB	r0,[r3,#7]		; store length

	MOV	r0,#1
	STRB	r0,[r3,#4]		; store offset=1

	MOV	r0,#0
	STRB	r0,[r3,#5]		; store timer=0

	LDMFD	r13!,{r0-r3,pc}		; restore regs and return

hud_update_flame
	; r0 - man number
	; r1 - man control block

	STMFD	r13!,{r0-r6,r14}

	STMFD	r13!,{r1}
	MOV	r1,#29                  ; "EXTRA FLAME"
	BL	new_hud_msg_asm
	LDMFD	r13!,{r1}

	LDRB	r2,[r1,#9]		; flame size
	MOV	r4,#5			; max number to print = 99
	BL	hud_int_to_asc

	LDR	r2,hud_update_data
	LDRB	r0,[r2,r0]		; x offset of this players hud
	ADD	r1,r0,#16		; x offset to flame count
	MOV	r2,#4			; y offset to flame count
	ADR	r0,hud_workspace	; string to draw

	BL	draw_small_string

	LDMFD	r13!,{r0-r6,pc}

hud_update_flame_loss
	; r0 - man number
	; r1 - man control block

	STMFD	r13!,{r0-r6,r14}

	STMFD	r13!,{r1}
	MOV	r1,#48                  ; "LOST SOME FLAME"
	BL	new_hud_msg_asm
	LDMFD	r13!,{r1}

	LDRB	r2,[r1,#9]		; flame size
	MOV	r4,#5			; max number to print = 99
	BL	hud_int_to_asc

	LDR	r2,hud_update_data
	LDRB	r0,[r2,r0]		; x offset of this players hud
	ADD	r1,r0,#16		; x offset to flame count
	MOV	r2,#4			; y offset to flame count
	ADR	r0,hud_workspace	; string to draw

	BL	draw_small_string

	LDMFD	r13!,{r0-r6,pc}

hud_update_bomb
	; r0 - man number
	; r1 - man control block

	STMFD	r13!,{r0-r6,r14}

	STMFD	r13!,{r1}
	MOV	r1,#8			; "EXTRA BOMB"
	BL	new_hud_msg_asm
	LDMFD	r13!,{r1}

	LDRB	r2,[r1,#8]		; bomb count
	MOV	r4,#5			; max number to print = 99
	BL	hud_int_to_asc

	LDR	r2,hud_update_data
	LDRB	r0,[r2,r0]		; x offset of this players hud
	ADD	r1,r0,#16		; x offset to bomb count
	MOV	r2,#12			; y offset to bomb count
	ADR	r0,hud_workspace	; string to draw

	BL	draw_small_string

	LDMFD	r13!,{r0-r6,pc}

hud_update_bomb_loss
	; r0 - man number
	; r1 - man control block

	STMFD	r13!,{r0-r6,r14}

	STMFD	r13!,{r1}
	MOV	r1,#49                  ; "LOST A BOMB"
	BL	new_hud_msg_asm
	LDMFD	r13!,{r1}

	LDRB	r2,[r1,#8]		; bomb count
	MOV	r4,#5			; max number to print = 99
	BL	hud_int_to_asc

	LDR	r2,hud_update_data
	LDRB	r0,[r2,r0]		; x offset of this players hud
	ADD	r1,r0,#16		; x offset to bomb count
	MOV	r2,#12			; y offset to bomb count
	ADR	r0,hud_workspace	; string to draw

	BL	draw_small_string

	LDMFD	r13!,{r0-r6,pc}

hud_update_lives
	; r0 - man number (reversed)
	; r1 - man control block

	STMFD	r13!,{r0-r6,r14}

	RSB	r0,r0,#4

	LDRB	r2,[r1,#15]		; lives count
	MOV	r4,#5			; max number to print = 99
	BL	hud_int_to_asc

	LDR	r2,hud_update_data
	LDRB	r0,[r2,r0]		; x offset of this players hud
	ADD	r1,r0,#16		; x offset to lives count
	MOV	r2,#21			; y offset to lives count
	ADR	r0,hud_workspace	; string to draw

	BL	draw_small_string

	LDMFD	r13!,{r0-r6,pc}

hud_mega_bomb
	STMFD	r13!,{r0-r3,r14}

	MOV	r1,#37                  ; "MEGA BOMB"
	BL	new_hud_msg_asm

	LDR	r2,hud_update_data
	LDRB	r1,[r2,r0]		; this players hud position
	ADD	r1,r1,#27		; x offset to bonus slot 1
	MOV	r2,#4			; y offset to bonus slot 1
	MOV	r0,#0			; bonus tile 0 = mega bomb

	BL	draw_small_bonus

	LDMFD	r13!,{r0-r3,pc}

hud_plasma_suit
	STMFD	r13!,{r0-r3,r14}

	MOV	r1,#115                 ; "PLASMA SUIT"
	BL	new_hud_msg_asm

	LDR	r2,hud_update_data
	LDRB	r1,[r2,r0]		; this players hud position
	ADD	r1,r1,#48		; x offset to bonus slot 1
	MOV	r2,#4			; y offset to bonus slot 1
	MOV	r0,#5			; bonus tile 5 = plasma suit

	BL	draw_small_bonus

	LDMFD	r13!,{r0-r3,pc}

hud_rubber_bomb
	STMFD	r13!,{r0-r3,r14}

	MOV	r1,#38                  ; "REBOUND BOMB"
	BL	new_hud_msg_asm

	LDR	r2,hud_update_data
	LDRB	r1,[r2,r0]		; this players hud position
	ADD	r1,r1,#27		; x offset to bonus slot 1
	MOV	r2,#4			; y offset to bonus slot 1
	MOV	r0,#2			; bonus tile 2 = rubber bomb

	BL	draw_small_bonus

	LDMFD	r13!,{r0-r3,pc}

hud_flower_bomb
	STMFD	r13!,{r0-r3,r14}

	MOV	r1,#39                  ; "FLOWER BOMB"
	BL	new_hud_msg_asm

	LDR	r2,hud_update_data
	LDRB	r1,[r2,r0]		; this players hud position
	ADD	r1,r1,#27		; x offset to bonus slot 1
	MOV	r2,#4			; y offset to bonus slot 1
	MOV	r0,#1			; bonus tile 1 = flower bomb

	BL	draw_small_bonus

	LDMFD	r13!,{r0-r3,pc}

hud_pushing
	STMFD	r13!,{r0-r3,r14}

	MOV	r1,#40                  ; "PUSH ABILITY"
	BL	new_hud_msg_asm

	LDR	r2,hud_update_data
	LDRB	r1,[r2,r0]		; this players hud position
	ADD	r1,r1,#34		; x offset to bonus slot 2
	MOV	r2,#4			; y offset to bonus slot 2
	MOV	r0,#3			; bonus tile 3 = push ability

	BL	draw_small_bonus

	LDMFD	r13!,{r0-r3,pc}

hud_throwing
	STMFD	r13!,{r0-r3,r14}

	MOV	r1,#41                  ; "THROW ABILITY"
	BL	new_hud_msg_asm

	LDR	r2,hud_update_data
	LDRB	r1,[r2,r0]		; this players hud position
	ADD	r1,r1,#41		; x offset to bonus slot 3
	MOV	r2,#4			; y offset to bonus slot 3
	MOV	r0,#4			; bonus tile 4 = mega bomb

	BL	draw_small_bonus

	LDMFD	r13!,{r0-r3,pc}

;------------------------------------------------------------------------------
;
; Bomb collision handler

collision_parameter_block
	DCD	0		        ; Space for tile xpos
	DCD	0                       ; Space for tile ypos
	DCD	0                       ; Space for tile address
	DCD	0                       ; Space for player address
	DCD	players
	DCD	bonus_array

collision_handler
	STMFD	r13!,{r0-r12,r14}	; save all registers

	; This routine handles collisions between players and bombs.
	; Primarily for the thrown bomb landing, this code may also be
	; used for the rolling mega bomb. It sets the specified player
	; into stunned mode, tidying up the map data accordingly.

	ADR	r0,collision_parameter_block
	LDMIA	r0,{r0-r4}

	STMIA	r3,{r0,r1}		; store collision coords

	SUB	r4,r3,r4
	MOV	r4,r4,LSR#5		; get player number
	RSB	r0,r4,#4

	; Make sure it's ok to stun this player - ie. he's not dead
	LDRB	r8,[r3,#11]
	MOV	r8,r8,LSR#4             ; get current action
	CMP	r8,#5			; dead/dying?
	LDMEQFD	r13!,{r0-r12,pc}	; yes - I'm off!

	; Calculate mask bit for man_here
	MOV	r8,#1
	MOV	r8,r8,LSL r4		; 1 << player number

	; r2 is address of tile stood on
	SUB	r5,r2,#32*16

	; r5 contains address of tile above the one we are stood on.
	LDRB	r4,[r5,#8]		; get men_here byte (tile above)
	BIC	r4,r4,r8		; remove our player
	STRB	r4,[r5,#8]		; store new men_here byte

	ADD	r5,r5,#31*16		; move to left tile
	LDRB	r4,[r5,#8]		; get men_here byte (tile above)
	BIC	r4,r4,r8		; remove our player
	STRB	r4,[r5,#8]		; store new men_here byte

	; Don't need to clear flag from tile we're currently on..

	ADD	r5,r5,#32		; move to right tile
	LDRB	r4,[r5,#8]		; get men_here byte (tile right)
	BIC	r4,r4,r8		; remove our player
	STRB	r4,[r5,#8]		; store new men_here byte

	ADD	r5,r5,#31*16		; move to tile below
	LDRB	r4,[r5,#8]		; get men_here byte (tile below)
	BIC	r4,r4,r8		; remove our player
	STRB	r4,[r5,#8]		; store new men_here byte

	; All men_here references should now be fixed.

	LDRB	r4,[r3,#11]		; get player status

	; I'm worried that the bomb throw routine may be curious to find
	; the moving flag possibly still set.
	BIC	r4,r4,#1		; clear moving flag
	STRB	r4,[r3,#11]

	MOV	r4,r4,LSR#4
	CMP	r4,#2			; carrying a bomb?
	BLEQ	man_throw_bomb		; yes - throw it.
	; man_throw_bomb expects the backward player count in r0.
	; I just hope we can see man_throw_bomb from here...

	; Set man action to stunned
	MOV	r4,r0
	MOV	r0,#9
	BL	dsym_playinstr		; crush sound effect
	MOV	r0,r4

	LDRB	r4,[r3,#11]		; get player status
	BIC	r4,r4,#&f1		; clear old and moving bit
	ORR	r4,r4,#4<<4		; set stunned status
	STRB	r4,[r3,#11]		; store new status

	MOV	r4,#0
	STRB	r4,[r3,#13]		; set anim_ctr to 0

	LDRB	r4,[r3,#8]		; bomb count
	LDRB	r5,[r3,#9]		; flame size

	ADD	r6,r5,r4
	CMP	r6,#2			; are they down to a minimum?

	LDMLEFD	r13!,{r0-r12,pc}	; yes - leave them alone

	; They've got more than one bomb or more than one unit of flame.
	; Throw one out as a bonus.

	CMP	r5,#1			; only one unit of flame?

	SUBLE	r4,r4,#1
	STRLEB	r4,[r3,#8]
	MOVLE	r12,#3			; yes - throw out a bomb

	SUBGT	r5,r5,#1
	STRGTB	r5,[r3,#9]
	MOVGT	r12,#2			; no - throw out some flame

	LDR	r9,collision_parameter_block+20	; bonus_array
	MOV	r10,#0

col_find_empty_bonus
	LDRB	r11,[r9,#2]		; bonus status
	TST	r11,#1<<7		; is this bonus allocated
	BEQ	col_found_empty_bonus	; no - use it

	ADD	r10,r10,#1
	ADD	r9,r9,#4
	CMP	r10,#128		; all bonuses checked?
	BLT	col_find_empty_bonus

	; No unallocated bonus space! Panic!
	LDMFD	r13!,{r0-r12,pc}

col_found_empty_bonus
	LDMIA	r3,{r6,r7}		; get player coords
	MOV	r6,r6,LSR#1
	MOV	r7,r7,LSR#1
	STRB	r6,[r9,#0]
	STRB	r7,[r9,#1]		; store x,y position of bonus in bonus array

	MOV	r5,r12,LSL#3		; bonus type
	ORR	r5,r5,#1		; it's moving
	ORR	r5,r5,#1<<7		; bonus exists -> new status byte

	STRB	r5,[r9,#2]		; store status byte

	MOV	r5,#0
	STRB	r5,[r9,#3]		; anim_ctr = 0

	RSB	r0,r0,#4
	MOV	r1,r3

	CMP	r12,#3			; losing a bomb?
	BEQ	col_lost_bomb

	BL	hud_update_flame_loss
	LDMFD	r13!,{r0-r12,pc}	; That's it, I think.

col_lost_bomb
	BL	hud_update_bomb_loss
	LDMFD	r13!,{r0-r12,pc}

;------------------------------------------------------------------------------
;
; Bomb handler
;
; Examines bombs in bomb array -
;   Move those which are moving
;   Decrease timer
;   Cause explosion if timer reaches 0
;

bomb_arc
	DCB	0,7,12,16,20,22,25,28,30,32,33,34,34
	DCB	34,33,32,30,28,25,22,20,16,12,7
	DCB	0,4,8,10,12,10,8,4,0

	ALIGN

bomb_handler_data
	DCD	players
	DCD	floor_map
	DCD	bombs

bomb_handle
	EXPORT	bomb_handle

	STMFD	r13!,{r0-r12,r14}

	MOV	r0,#64			; maximum number of bombs

	ADR	r1,bomb_handler_data
	LDMIA	r1,{r1-r3}		; load variables

	MOV	r12,r3			; save bomb array position

handle_each_bomb
	LDRB	r4,[r3,#11]		; get bomb status

	TST	r4,#1<<4		; does bomb exist?

	BNE	handle_bomb		; if bit 4 is set, apparently it does

handle_next_bomb
	ADD	r3,r3,#16		; go on to next bomb

	SUBS	r0,r0,#1
	BNE	handle_each_bomb	; until all bombs are handled

	LDMFD	r13!,{r0-r12,pc}	; restore regs and return

handle_bomb
	LDRB	r5,[r3,#11]		; bomb status
	TST	r5,#1<<3		; is bomb in air?
	BNE	handle_flying_bomb

	; Is bomb in the path of an explosion?
	LDMIA	r3,{r5,r6}		; get bomb position

	ADD	r5,r5,#8
	BIC	r5,r5,#15
	ADD	r6,r6,#8
	BIC	r6,r6,#15		; round to nearest tile

	ADD	r8,r2,r6,LSL#5		; map start + (ypos>>4)*32*16 (TDC)
	ADD	r8,r8,r5		; + (xpos>>4)*16 (TDC)

	LDRB	r5,[r8,#5]		; blast length for this tile
	CMP	r5,#3			; 0..3 blast almost over - ignore
	BLE	handle_bomb_timer

	; Bomb caught in blast - drop timer so explosion occurs next time
	LDRB	r5,[r3,#9]		; get current timer
	CMP	r5,#4			; about to explode anyway?
	BLE	handle_bomb_timer

	MOV	r5,#4
	STRB	r5,[r3,#9]		; timer = 4!
	B	handle_bomb_mover	; and skip

handle_bomb_timer
	; Check timer
	LDRB	r5,[r3,#9]		; get timer byte
	SUBS	r5,r5,#1		; tick!
	STRB	r5,[r3,#9]		; store new time
	BEQ	explode_bomb		; timer=0... boom!

handle_bomb_mover
	; First, let's try moving it...

	TST	r4,#1			; is it moving
	BNE	handle_this_moving_bomb	; yes - continue movement.

	; Is bomb on a conveyor tile?

	LDMIA	r3,{r5,r6}		; get bomb xpos,ypos

	ADD	r8,r2,r6,LSL#5		; map start + (ypos>>4)*32*16 (TDC)
	ADD	r8,r8,r5		; + (xpos>>4)*16 (TDC)

	LDRB	r9,[r8,#0]		; get tile status byte

	CMP	r9,#144			; is this a conveyor?
	BLT	handle_next_bomb
	CMP	r9,#148			; or fuel spill?
	BGT	handle_next_bomb

	CMP	r9,#148			; fuel -> randomish direction
	LDREQ	r9,scan_clock
	SUBNE	r9,r9,#16		; conveyor -> conveyor direction
	AND	r9,r9,#3		; get direction

	LDRB	r4,[r3,#11]		; bomb status
	BIC	r4,r4,#6
	ORR	r4,r4,r9,LSL#1		; change direction
	ORR	r4,r4,#1		; start it moving
	STRB    r4,[r3,#11]		; new bomb status

	MOV	r7,r9			; new direction

	B	start_moving_on_conveyor

handle_this_moving_bomb
	; Move the bomb.

	LDMIA	r3,{r5,r6}		; get bomb xpos,ypos

	MOV	r7,r4,LSR#1
	ANDS	r7,r7,#3		; get bomb direction

	SUBEQ	r5,r5,#2		; if dir = 0, move left

	CMP	r7,#1
	ADDEQ	r5,r5,#2		; if dir = 1, move right

	CMP	r7,#2
	SUBEQ	r6,r6,#2		; if dir = 2, move up

	CMP	r7,#3
	ADDEQ	r6,r6,#2		; if dir = 3, move down

	STMIA	r3,{r5,r6}		; store new position

	; If tile aligned, check path ahead and stop bomb if necessary.
	ORR	r8,r5,r6
	ANDS	r8,r8,#15		; is new position tile aligned?

	BNE	handle_next_bomb	; no - leave for now

	; Calculate last tile position

	MOV	r10,r5
	MOV	r11,r6

	CMP	r7,#0
	ADDEQ	r10,r10,#16		; came from right
	CMP	r7,#1
	SUBEQ	r10,r10,#16		; came from left
	CMP	r7,#2
	ADDEQ	r11,r11,#16		; came from bottom
	CMP	r7,#3
	SUBEQ	r11,r11,#16		; came from top

	; last tile position on map = (ypos>>4)*32*16 + (xpos>>4)*16
	; Bottom 4 bits of xpos and ypos must be 0 to be tile aligned

	ADD	r8,r2,r11,LSL#5		; map start + (ypos>>4)*32*16 (TDC)
	ADD	r8,r8,r10		; + (xpos>>4)*16 (TDC)

	RSB	r11,r0,#64		; this bomb's number
	AND	r11,r11,#63
	ORR	r11,r11,#128		; this bomb's tile extra entry

	MOV	r10,#0
	STRB	r10,[r8,#2]		; delete its entry from map

	; Is bomb on a conveyor tile?

	ADD	r8,r2,r6,LSL#5		; map start + (ypos>>4)*32*16 (TDC)
	ADD	r8,r8,r5		; + (xpos>>4)*16 (TDC)

	LDRB	r9,[r8,#0]		; get tile status byte

	CMP	r9,#144			; is this a conveyor?
	BLT	not_on_conveyor
	CMP	r9,#148			; or a fuel spill?
	BGT	not_on_conveyor

	CMP	r9,#148
	LDREQ	r9,scan_clock		; fuel spill -> random direction
	SUBNE	r9,r9,#16		; conveyor -> conveyor direction
	AND	r9,r9,#3		; get direction

	LDRB	r4,[r3,#11]		; bomb status
	BIC	r4,r4,#6
	ORR	r4,r4,r9,LSL#1		; change direction
	STRB    r4,[r3,#11]		; new bomb status

	MOV	r7,r9			; new direction

start_moving_on_conveyor

not_on_conveyor

	; Calculate next tile position
	CMP	r7,#0
	SUBEQ	r5,r5,#16		; left
	CMP	r7,#1
	ADDEQ	r5,r5,#16		; right
	CMP	r7,#2
	SUBEQ	r6,r6,#16		; up
	CMP	r7,#3
	ADDEQ	r6,r6,#16		; down

	; next tile position on map = (ypos>>4)*32*16 + (xpos>>4)*16
	; Bottom 4 bits of xpos and ypos must be 0 to be tile aligned

	ADD	r8,r2,r6,LSL#5		; map start + (ypos>>4)*32*16 (TDC)
	ADD	r8,r8,r5		; + (xpos>>4)*16 (TDC)

	; if moving flag was cleared during move from last tile, give up here.
	TST	r4,#1<<5		; signal to stop bomb?
	BNE	stop_this_bomb		; yes - leave and stop bomb.

	LDRB	r9,[r8,#0]		; get tile status byte

	TST	r9,#128			; can we move over this tile?

	BEQ	stop_this_bomb		; top bit unset - no - stop bomb

	LDRB	r9,[r3,#10]		; get bomb type
	CMP	r9,#1			; mega bomb?
	BEQ	bm_over_man		; yes - can roll over other players

	LDRB	r9,[r8,#8]
	CMP	r9,#0			; any other players in the way?
	BNE	stop_this_bomb		; yes - cannot continue...

bm_over_man
	LDRB	r9,[r8,#2]		; get extra1
	TST	r9,#1<<7		; contains bomb?
	BEQ	bomb_move_check2	; no - check extra2

	TST	r9,#1<<6		; is it a bomb?
	BNE	bomb_move_check2	; no - skip check, though nasty check will go here

	B	stop_this_bomb
	AND	r9,r9,#63		; get bomb number
	ADD	r10,r12,r9,LSL#4	; get address of bomb control block
	LDRB	r9,[r10,#11]		; get bomb status

	TST	r9,#1			; is bomb moving?
	MOVEQ	r9,#0
	BEQ	stop_this_bomb		; no - can't move

	AND	r9,r9,#6		; isolate direction
	MOV	r9,r9,LSR#1
	CMP	r9,r7			; same as our bomb?
	BNE	stop_this_bomb		; no - can't move

bomb_move_check2
	LDRB	r9,[r8,#3]		; get extra2
	TST	r9,#1<<7		; contains nasty?
	BEQ	bomb_may_continue	; no - can move bomb

	; It's a nasty
	B	bomb_may_continue	; nasty check will go here

bomb_may_continue
	; Bomb is able to move onto the next tile...
	; Register bomb in extra byte for next tile.

	RSB	r10,r0,#64		; get bomb number
	AND	r10,r10,#63
	ORR	r10,r10,#128		; r10 = bomb's tile extra extry

	STRB	r10,[r8,#2]		; use extra1

	B	handle_next_bomb	; ok - finished, I think.

stop_this_bomb
	; Bomb cannot move to next tile...

	; Is this a rebounding bomb..?
	LDRB	r5,[r3,#10]

	CMP	r5,#3			; rebound bomb?
	BNE	ok_you_can_stop_this_bomb_now

	; It's a rebound bomb. Check whether we can move in reverse
	; direction before continuing.

	AND	r5,r4,#6
	CMP	r5,#0			; Left?
	MOVEQ	r7,#1                   ;  - go right

	CMP	r5,#1<<1                ; Right?
	MOVEQ	r7,#0                   ;  - go left

	CMP	r5,#2<<1		; Up?
	MOVEQ	r7,#3			;  - go down

	CMP	r5,#3<<1		; Down?
	MOVEQ	r7,#2			;  - go up

        BIC	r4,r4,#7
	ORR	r4,r4,r7,LSL#1		; Put new direction in status
	ORR	r4,r4,#1		; set moving flag
	STRB	r4,[r3,#11]		; store new status byte

	LDMIA	r3,{r5,r6}

	; Calculate next tile position
	CMP	r7,#0
	SUBEQ	r5,r5,#16		; left
	CMP	r7,#1
	ADDEQ	r5,r5,#16		; right
	CMP	r7,#2
	SUBEQ	r6,r6,#16		; up
	CMP	r7,#3
	ADDEQ	r6,r6,#16		; down

	; next tile position on map = (ypos>>4)*32*16 + (xpos>>4)*16
	; Bottom 4 bits of xpos and ypos must be 0 to be tile aligned

	ADD	r8,r2,r6,LSL#5		; map start + (ypos>>4)*32*16 (TDC)
	ADD	r8,r8,r5		; + (xpos>>4)*16 (TDC)

	; if moving flag was cleared during move from last tile, give up here.
	TST	r4,#1<<5		; signal to stop bomb?
	BNE	ok_you_can_stop_this_bomb_now	; yes - leave and stop bomb.

	LDRB	r9,[r8,#0]		; get tile status byte

	TST	r9,#128			; can we move over this tile?

	BEQ	ok_you_can_stop_this_bomb_now	; top bit unset - no - stop bomb

	LDRB	r9,[r3,#10]		; get bomb type
	CMP	r9,#1			; mega bomb?
	BEQ	rb_bm_over_man		; yes - can roll over other players

	LDRB	r9,[r8,#8]
	CMP	r9,#0			; any other players in the way?
	BNE	ok_you_can_stop_this_bomb_now	; yes - cannot continue...

rb_bm_over_man
	LDRB	r9,[r8,#2]		; get extra1
	TST	r9,#1<<7		; contains bomb?
	BEQ	rb_bomb_move_check2	; no - check extra2

	TST	r9,#1<<6		; is it a bomb?
	BNE	rb_bomb_move_check2	; no - skip check, though nasty check will go here

	B	ok_you_can_stop_this_bomb_now

	AND	r9,r9,#63		; get bomb number
	ADD	r10,r12,r9,LSL#4	; get address of bomb control block
	LDRB	r9,[r10,#11]		; get bomb status

	TST	r9,#1			; is bomb moving?
	MOVEQ	r9,#0
	BEQ	ok_you_can_stop_this_bomb_now	; no - can't move

	AND	r9,r9,#6		; isolate direction
	MOV	r9,r9,LSR#1
	CMP	r9,r7			; same as our bomb?
	BNE	ok_you_can_stop_this_bomb_now	; no - can't move

rb_bomb_move_check2
	LDRB	r9,[r8,#3]		; get extra2
	TST	r9,#1<<7		; contains nasty?
	BEQ	rb_bomb_may_continue	; no - can move bomb

	; It's a nasty
	B	rb_bomb_may_continue	; nasty check will go here

rb_bomb_may_continue
	; Bomb is able to move onto the next tile...
	; Register bomb in extra byte for next tile.

	RSB	r10,r0,#64		; get bomb number
	AND	r10,r10,#63
	ORR	r10,r10,#128		; r10 = bomb's tile extra extry

	STRB	r10,[r8,#2]		; use extra1

	B	handle_next_bomb	; ok - finished, I think.


ok_you_can_stop_this_bomb_now
	; Unset bomb movement bit

	BIC	r4,r4,#(1+(1<<5))	; unset movement bit and stop signal in bomb status
	STRB	r4,[r3,#11]		; store new status

	B	handle_next_bomb	; ok - finished, I think.

link_to_collision
	DCD	collision_parameter_block
	DCD	collision_handler

bomb_arena
	IMPORT	arena_depth
	DCD	arena_depth

handle_flying_bomb
	; Bomb is moving through air
	; Move according to direction bits
	; increment zpos - use zpos arc array to detect bounces.
	; when a bounce occurs,
	;  1. The bomb will (should) be tile aligned.
	;  2. A check should be made on the state of tile below it.
	;  3. If the tile is clear, [or contains a player] land the bomb.
	;  4. If the tile is not clear, loop the last bounce segment of the zpos array

	; r0 - bomb counter (preserve on exit)
	; r1 - player control block array
	; r2 - map data
	; r3 - current bomb array entry

	LDMIA	r3,{r5,r6}		; get bomb xpos,ypos

	LDRB	r7,[r3,#11]		; get bomb status
	MOV	r7,r4,LSR#1
	ANDS	r7,r7,#3		; get bomb direction

	SUBEQ	r5,r5,#2		; if dir = 0, move left

	CMP	r7,#1
	ADDEQ	r5,r5,#2		; if dir = 1, move right

	CMP	r7,#2
	SUBEQ	r6,r6,#2		; if dir = 2, move up

	CMP	r7,#3
	ADDEQ	r6,r6,#2		; if dir = 3, move down

	; Need some kind of wraparound feature! HERE!
	CMP	r5,#0
	MOVEQ	r5,#(vis_tiles_h+1)*16
	BEQ	bounce_wrapped

	CMP	r5,#16*(vis_tiles_h+1)
	MOVEQ	r5,#0
	BEQ	bounce_wrapped

	LDR	r7,bomb_arena
	LDR	r7,[r7,#0]		; arena size vertically in tiles
	ADD	r7,r7,#1
	MOV	r7,r7,LSL#4		; multiply by 16

	CMP	r6,#0			; off top?
	MOVEQ	r6,r7			; come back on bottom
	BEQ	bounce_wrapped

	CMP	r6,r7			; off bottom?
	MOVEQ	r6,#0			; come back on top

bounce_wrapped
	STMIA	r3,{r5,r6}		; store new position

	LDRB	r7,[r3,#13]		; zpos entry
	ADD	r7,r7,#1
	STRB	r7,[r3,#13]		; new zpos

	ADRL	r8,bomb_arc
	LDRB	r9,[r8,r7]		; actual bomb height

	CMP	r9,#0			; has it landed?
	BNE	handle_next_bomb	; no - leave here

	; it's come to rest on the ground! Check tile to see if it can remain here
	MOV	r5,r5,LSR#4
	MOV	r6,r6,LSR#4

	ADD	r8,r2,r6,LSL#9		; ypos*32*16
	ADD	r8,r8,r5,LSL#4		; xpos*16	= tile address

	LDRB	r9,[r8,#0]		; tile status
	TST	r9,#128			; can bomb land here?
	BEQ	continue_bounce		; no

	LDRB	r9,[r8,#2]		; extra1
	TST	r9,#128			; bomb there?
	BNE	continue_bounce		; yes - can't land here

	LDRB	r9,[r8,#3]		; extra2
	TST	r9,#128			; nasty there?
	BNE	continue_bounce		; yes - can't land here....??

	LDRB	r9,[r8,#8]		; men_here
	CMP	r9,#0			; any players here?
	BEQ	go_ahead_and_land	; no - touch down!

	; There's someone on this tile!
	; Oh good god... we need a loop because all four players could
	; be stood on this tile!
	;
	; Need a routine to handle the collision, with a parameter block
	; containing :
	;  tile xpos/ypos
	;  tile address
	;  player address

	; First, are any of the players present carrying a bomb?
	; If so, the bomb can't land.
	MOV	r11,#1
	MOV	r10,#4
man_shield_loop
	TST	r9,r11			; is this player here?
	BEQ	next_man_shield		; no - jump

	ADD	r12,r1,r10,LSL #5	; address of this player
	LDRB	r7,[r12,#11]		; player status
	MOV	r7,r7,LSR#4
	CMP	r7,#2			; carrying a bomb?
	BEQ	continue_bounce		; yes - can't land here

next_man_shield
	MOV	r11,r11,LSL#1
	SUBS	r10,r10,#1
	BNE	man_shield_loop		; test all 4 possible players

	; If we reach here, the bomb can land, but we must stun the
	; players underneath.

	LDR	r10,link_to_collision	; address of parameter block

	MOV	r5,r5,LSL#4
	MOV	r6,r6,LSL#4

	STMIA	r10,{r5,r6}		; store tile coords
	STR	r8,[r10,#8]		; store tile address

	TST	r9,#1			; player 0 here?
	STRNE	r1,[r10,#12]		; player 0 address
	BLNE	collision_handler

	TST	r9,#2			; player 1 here?
	ADDNE	r5,r1,#32
	STRNE	r5,[r10,#12]		; player 1 address
	BLNE	collision_handler

	TST	r9,#4			; player 2 here?
	ADDNE	r5,r1,#64
	STRNE	r5,[r10,#12]		; player 2 address
	BLNE	collision_handler

	TST	r9,#8			; player 3 here?
	ADDNE	r5,r1,#96
	STRNE	r5,[r10,#12]		; player 3 address
	BLNE	collision_handler

go_ahead_and_land
	; if control reaches here, the tile must be empty
	RSB	r9,r0,#64		; get bomb number
	ORR	r9,r9,#128
	STRB	r9,[r8,#2]		; set map entry - place bomb on map

	LDRB	r9,[r3,#11]		; get bomb status
	AND	r9,r9,#&f6		; clear moving/in air bits
	STRB	r9,[r3,#11]		; store new bomb status

	B	handle_next_bomb	; and that's all folks.

continue_bounce
	; Bomb can't land, so continue last section of bounce
	MOV	r9,r0
	MOV	r0,#7
	BL	dsym_playinstr		; bounce sound effect
	MOV	r0,r9

	MOV	r9,#24
	STRB	r9,[r3,#13]		; reset xpos index

	B	handle_next_bomb

explode_extra_data
	DCD	mystery

exp_rnd_sfx
	DCB	3,16,17,18

explode_bomb
	; Timer has reached 0. Boom time!

	; Though for now, we'll just remove the bomb.


	RSB	r5,r0,#64
	AND	r5,r5,#63
	ORR	r5,r5,#128		; r5 - bomb entry in tile extra slot

	LDMIA	r3,{r6,r7}		; get bomb coords

	MOV	r10,#0

	; bomb tile position on map = (ypos>>4)*32*16 + (xpos>>4)*16

	ORR	r11,r6,r7
	AND	r11,r11,#15		; is bomb between tiles?

	MOV	r12,r4,LSR#1
	AND	r12,r12,#3		; bomb direction

	BIC	r6,r6,#15
	BIC	r7,r7,#15		; clear fractional part

	ADD	r8,r2,r7,LSL#5		; map start + (ypos>>4)*32*16 (TDC)
	ADD	r8,r8,r6		; + (xpos>>4)*16 (TDC)

	LDRB	r9,[r8,#2]		; current tile, extra1
	CMP	r9,r5			; this bomb?
	STREQB	r10,[r8,#2]		; yes - delete

	TST	r4,#1			; was bomb moving?
	BEQ	explode_bomb_rendez	; no - jump

	; test neighbouring tile

	CMP	r12,#0			; going left?
	SUBEQ	r8,r8,#16		; (TDC)

	CMP	r12,#1			; going right?
	ADDEQ	r8,r8,#16		; (TDC)

	CMP	r12,#2			; going up?
	SUBEQ	r8,r8,#512		; (TDC)

	CMP	r12,#3			; going down?
	ADDEQ	r8,r8,#512		; (TDC)

	CMP	r11,#0			; tile aligned?
	BEQ	explode_bomb_do_test	; yes - jump

	CMP	r12,#0			; not tile aligned and going left?
	ADDEQ	r8,r8,#32		; yes - test tile behind (TDC)

	CMP	r12,#2			; not tile aligned and going up?
	ADDEQ	r8,r8,#1024		; yes - test tile below (TDC)

explode_bomb_do_test
	; r8 contains address of secondary tile to test.

	LDRB	r9,[r8,#2]		; current tile, extra1
	CMP	r9,r5			; this bomb?
	STREQB	r10,[r8,#2]		; yes - delete

explode_bomb_rendez
	STRB	r10,[r3,#11]		; delete bomb from bomb array

	STMFD	r13!,{r0}		; free one reg

	BL	rnd
	AND	r0,r0,#3
	ADR	r11,exp_rnd_sfx
	LDRB	r0,[r11,r0]
	BL	dsym_playinstr		; Play BOOM noise

	LDRB	r0,[r3,#8]		; get bomb owner id

	CMP	r0,#255			; CPU controlled bomb?
	MOVEQ	r5,#0			; yes - type 0
	MOVEQ	r8,#0			; null player address
	BEQ	not_a_players_bomb

	ADD	r8,r1,r0,LSL#5		; get address of owners player ctrl block

	LDRB	r9,[r8,#17]

	LDRB	r5,[r3,#10]		; get bomb type
	CMP	r5,#1
	BICEQ	r9,r9,#128		; mega bomb exploding
	CMP	r5,#2
	BICEQ	r9,r9,#128		; flower bomb exploding

	SUB	r9,r9,#1		; decrement bomb count
	STRB	r9,[r8,#17]

not_a_players_bomb
	; Explode! But first, a register check...
	;
	; r0  - owner of this bomb (counting backwards)
	; r1  - address of player control block array
	; r2  - address of floor map
	; r3  - address of this bomb's control block
	; r4  - this bomb's status byte

	LDMIA	r3,{r5,r6}		; bomb coords

	ADD	r5,r5,#8
	BIC	r5,r5,#15
	ADD	r6,r6,#8
	BIC	r6,r6,#15		; Round coords to nearest tile

	; Calculate tile position on map
	ADD	r7,r2,r6,LSL#5		; map start + (ypos>>4)*32*16 (TDC)
	ADD	r7,r7,r5		; + (xpos>>4)*16 (TDC)

	CMP	r8,#0			; owned by a player?
	MOVEQ	r8,#4			; no - default size 4
	BEQ	cpu_sized_bomb

	LDR	r11,explode_extra_data
	LDRB	r11,[r11,r0,LSL#1]	; get players mystery[] entry
	CMP	r11,#2			; mini bombs?
	MOVEQ	r8,#1			; yes - length of 1
	LDRNEB	r8,[r8,#9]		; no - get players flame length

cpu_sized_bomb
	LDRB	r11,[r3,#10]		; get bomb type
	CMP	r11,#1			; mega bomb?
	MOVEQ	r8,#100			; yes - infinite (as good as) length

	CMP	r11,#2			; flower bomb..?
	BNE	exp_not_a_flower_bomb

	MOV	r11,r0			; save r0

	BL	rnd			; get random value
	AND	r0,r0,#15
	CMP	r0,#12

	MOV	r0,r11			; restore r0

	BGE	exp_flour_bomb		; 1 in 4 chance of flour not flower

exp_not_a_flower_bomb
	LDRB	r11,[r7,#0]		; get tile status
	CMP	r11,#128		; empty floor?

	MOV	r11,#64			; explosion centre
	STREQB	r11,[r7,#1]		; tile sprite
	STRNEB	r11,[r7,#7]		; overlay

	MOV	r11,#9+16
	STRB	r11,[r7,#4]		; blast status

	MOV	r14,#20
	STRB	r14,[r7,#5]		; explosion duration

	STRB	r0,[r7,#9]		; store owner ref

	MOV	r9,r7			; tile pos
	MOV	r10,r8                  ; flame length
	MOV	r11,#84			; horizontal blast
	MOV	r12,#2

exp_left
	SUB	r9,r9,#16		; next tile (TDC)

	LDRB	r4,[r9,#5]		; current blast duration of tile
	CMP	r4,#0			; exploding?
	BNE	exp_left_skip_tile	; yes - skip tile

	LDRB	r4,[r9,#0]		; get tile status
	TST	r4,#128			; blocked?
	BNE	exp_left_cont		; no - carry on.

	AND	r5,r4,#24
	CMP	r5,#24
	BNE	not_pipe_left
        AND	r5,r4,#3		; get pipe direction
	CMP	r5,#1			; right facing end?

	ADREQ	r14,exp_left_end	; set return address
	BEQ	pipe_network_blast

not_pipe_left
	CMP	r4,#0			; removeable blockage?
	MOVEQ	r4,#8
	STREQB	r4,[r9,#4]		; explode that blockage
	STREQB	r14,[r9,#5]		; for this number of frames
	MOVEQ	r4,#33
	STREQB	r4,[r9,#1]		; and use the explosion sprites

	B	exp_left_end

exp_left_cont
	CMP	r10,#1			; end of blast?
	MOVEQ	r11,#124
	MOVEQ	r12,#4			; yes - use end sprite

	CMP	r4,#128			; empty floor tile?
	STREQB	r11,[r9,#1]		; replace tile sprite with explosion
	STRNEB	r11,[r9,#7]		; use overlay sprite instead
	STRB	r12,[r9,#4]		; store explosion info
	STRB	r14,[r9,#5]
	STRB	r0,[r9,#9]		; store owner ref

	LDRB	r4,[r9,#2]		; extra1
	TST	r4,#128                 ; = bomb there?
	MOVNE	r10,#1			; yes - quit

exp_left_skip_tile
	SUBS	r10,r10,#1
	BNE	exp_left		; continue along length of flame

exp_left_end
	MOV	r9,r7			; tile pos
	MOV	r10,r8                  ; flame length
	MOV	r11,#84			; horizontal blast
	MOV	r12,#2

exp_right
	ADD	r9,r9,#16		; next tile (TDC)

	LDRB	r4,[r9,#5]		; current blast duration of tile
	CMP	r4,#0			; exploding?
	BNE	exp_right_skip_tile	; yes - abort

	LDRB	r4,[r9,#0]		; get tile status
	TST	r4,#128			; blocked?
	BNE	exp_right_cont		; no - carry on.

	AND	r5,r4,#24
	CMP	r5,#24
	BNE	not_pipe_right
        AND	r5,r4,#3		; get pipe direction
	CMP	r5,#0			; right facing end?

	ADREQ	r14,exp_right_end	; set return address
	BEQ	pipe_network_blast

not_pipe_right
	CMP	r4,#0			; removeable blockage?
	MOVEQ	r4,#8
	STREQB	r4,[r9,#4]		; explode that blockage
	STREQB	r14,[r9,#5]		; for this number of frames
	MOVEQ	r4,#33
	STREQB	r4,[r9,#1]		; and use the explosion sprites
	B	exp_right_end

exp_right_cont
	CMP	r10,#1			; end of blast?
	MOVEQ	r11,#144
	MOVEQ	r12,#5			; yes - use end sprite

	CMP	r4,#128			; empty floor tile?
	STREQB	r11,[r9,#1]		; replace tile sprite with explosion
	STRNEB	r11,[r9,#7]		; use overlay sprite instead
	STRB	r12,[r9,#4]		; store explosion info
	STRB	r14,[r9,#5]
	STRB	r0,[r9,#9]		; store owner ref

	LDRB	r4,[r9,#2]		; extra1
	TST	r4,#128                 ; = bomb there?
	MOVNE	r10,#1			; yes - quit

exp_right_skip_tile
	SUBS	r10,r10,#1
	BNE	exp_right		; continue along length of flame

exp_right_end
	MOV	r9,r7			; tile pos
	MOV	r10,r8                  ; flame length
	MOV	r11,#104		; vertical blast
	MOV	r12,#3

exp_up
	SUB	r9,r9,#16*32		; next tile (TDC)

	LDRB	r4,[r9,#5]		; current blast duration of tile
	CMP	r4,#0			; exploding?
	BNE	exp_up_skip_tile	; yes - skip tile

	LDRB	r4,[r9,#0]		; get tile status
	TST	r4,#128			; blocked?
	BNE	exp_up_cont		; no - carry on.

	AND	r5,r4,#24
	CMP	r5,#24
	BNE	not_pipe_up
        AND	r5,r4,#3		; get pipe direction
	CMP	r5,#3			; right facing end?

	ADREQ	r14,exp_up_end		; set return address
	BEQ	pipe_network_blast

not_pipe_up
	CMP	r4,#0			; removeable blockage?
	MOVEQ	r4,#8
	STREQB	r4,[r9,#4]		; explode that blockage
	STREQB	r14,[r9,#5]		; for this number of frames
	MOVEQ	r4,#33
	STREQB	r4,[r9,#1]		; and use the explosion sprites

	B	exp_up_end

exp_up_cont
	CMP	r10,#1			; end of blast?
	MOVEQ	r11,#164
	MOVEQ	r12,#6			; yes - use end sprite

	CMP	r4,#128			; empty floor tile?
	STREQB	r11,[r9,#1]		; replace tile sprite with explosion
	STRNEB	r11,[r9,#7]		; use overlay sprite instead
	STRB	r12,[r9,#4]		; store explosion info
	STRB	r14,[r9,#5]
	STRB	r0,[r9,#9]		; store owner ref

	LDRB	r4,[r9,#2]		; extra1
	TST	r4,#128                 ; = bomb there?
	MOVNE	r10,#1			; yes - quit

exp_up_skip_tile
	SUBS	r10,r10,#1
	BNE	exp_up			; continue along length of flame

exp_up_end
	MOV	r9,r7			; tile pos
	MOV	r10,r8                  ; flame length
	MOV	r11,#104		; vertical blast
	MOV	r12,#3

exp_down
	ADD	r9,r9,#16*32		; next tile (TDC)

	LDRB	r4,[r9,#5]		; current blast duration of tile
	CMP	r4,#0			; exploding?
	BNE	exp_down_skip_tile	; yes - skip this tile

	LDRB	r4,[r9,#0]		; get tile status
	TST	r4,#128			; blocked?
	BNE	exp_down_cont		; no - carry on.

	AND	r5,r4,#24
	CMP	r5,#24
	BNE	not_pipe_down
        AND	r5,r4,#3		; get pipe direction
	CMP	r5,#2			; right facing end?

	ADREQ	r14,exp_down_end	; set return address
	BEQ	pipe_network_blast

not_pipe_down
	CMP	r4,#0			; removeable blockage?
	MOVEQ	r4,#8
	STREQB	r4,[r9,#4]		; explode that blockage
	STREQB	r14,[r9,#5]		; for this number of frames
	MOVEQ	r4,#33
	STREQB	r4,[r9,#1]		; and use the explosion sprites

	B	exp_down_end

exp_down_cont
	CMP	r10,#1			; end of blast?
	MOVEQ	r11,#184
	MOVEQ	r12,#7			; yes - use end sprite

	CMP	r4,#128			; empty floor tile?
	STREQB	r11,[r9,#1]		; replace tile sprite with explosion
	STRNEB	r11,[r9,#7]		; use overlay sprite instead
	STRB	r12,[r9,#4]		; store explosion info
	STRB	r14,[r9,#5]
	STRB	r0,[r9,#9]		; store owner ref

	LDRB	r4,[r9,#2]		; extra1
	TST	r4,#128                 ; = bomb there?
	MOVNE	r10,#1			; yes - quit

exp_down_skip_tile
	SUBS	r10,r10,#1
	BNE	exp_down		; continue along length of flame

exp_down_end

	LDRB	r11,[r3,#10]		; get bomb type
	CMP	r11,#2			; flower bomb?

	BEQ	exp_flower_bomb

exp_ending
	LDMFD	r13!,{r0}		; retrieve stored reg

	B	handle_next_bomb	; finished exploding...

exp_flour_bomb_data
	DCD	flour_array

new_flour_bomb
	; on exit, r11 contains address of free flour explosion slot

	LDR	r11,exp_flour_bomb_data	; find an empty flour explosion slot

	MOV	r10,#64			; out of the 64 available

find_new_flour_bomb
	LDRB	r8,[r11,#2]		; status of this slot
	TST	r8,#1<<7		; used?
	MOVEQ	pc,r14			;  return if not

	ADD	r11,r11,#4
	SUBS	r10,r10,#1
	BNE	find_new_flour_bomb	; test all slots

	; No slots are available!
	SUB	r11,r11,#4		; use last slot in emergency
	MOV	pc,r14			; and return

exp_flour_bomb
	STMFD	r13!,{r14}

	;SWI	263

	MOV	r5,r5,ASR#4		; x position
	MOV	r6,r6,ASR#4             ; y position (both tile coords)
	MOV	r7,#1<<7		; 'this explosion exists'
	MOV	r12,#20			; length of explosion

	BL	new_flour_bomb
	STRB	r5,[r11,#0]
	STRB	r6,[r11,#1]
	STRB	r7,[r11,#2]
	STRB	r12,[r11,#3]		; set up data, central cloud

	ADD	r5,r5,#2		; move right
	CMP	r5,#vis_tiles_h
	BGE	flour_left

	BL	new_flour_bomb
	STRB	r5,[r11,#0]
	STRB	r6,[r11,#1]
	STRB	r7,[r11,#2]
	STRB	r12,[r11,#3]		; set up data, right cloud

flour_left
	SUBS	r5,r5,#4		; move left
	BLE	flour_down

	BL	new_flour_bomb
	STRB	r5,[r11,#0]
	STRB	r6,[r11,#1]
	STRB	r7,[r11,#2]
	STRB	r12,[r11,#3]		; set up data, left cloud

flour_down
	ADD	r5,r5,#2		; move centre
	ADD	r6,r6,#2		; move down
	CMP	r6,#32
	BGE	flour_up

	BL	new_flour_bomb
	STRB	r5,[r11,#0]
	STRB	r6,[r11,#1]
	STRB	r7,[r11,#2]
	STRB	r12,[r11,#3]		; set up data, lower cloud

flour_up
	SUBS	r6,r6,#4		; move up
        BLE	flour_exp_created

	BL	new_flour_bomb
	STRB	r5,[r11,#0]
	STRB	r6,[r11,#1]
	STRB	r7,[r11,#2]
	STRB	r12,[r11,#3]		; set up data, central cloud

flour_exp_created
	LDMFD	r13!,{r14}

	B	exp_ending

exp_flower_bomb
        ; Flower bomb explosion

	CMP	r8,#3			; minimum explosion size
	BLT	exp_ending

	; Look left
	SUB	r9,r7,#16
	LDRB	r4,[r9,#0]		; get tile status
	TST	r4,#128			; blocked?
	BEQ	exp_flower_r_petal	; yes

	SUB	r9,r9,#16
	MOV	r10,#3
	BL	explode_tile		; new explosion centre
	CMP	r10,#0			; was it blocked
	BEQ	exp_flower_r_petal	; yes - next petal

	SUB	r9,r9,#16*32
	MOV	r10,#2
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_ld_petal

	SUB	r9,r9,#16*32
	MOV	r10,#3
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_ld_petal

	SUB	r9,r9,#16*32
	MOV	r10,#6
	BL	explode_tile

exp_flower_ld_petal
	SUB	r9,r7,#2*16
	ADD	r9,r9,#16*32
	MOV	r10,#2
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_r_petal

	ADD	r9,r9,#16*32
	MOV	r10,#3
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_r_petal

	ADD	r9,r9,#16*32
	MOV	r10,#7
	BL	explode_tile

exp_flower_r_petal
	ADD	r9,r7,#16
	LDRB	r4,[r9,#0]		; get tile status
	TST	r4,#128			; blocked?
	BEQ	exp_flower_u_petal	; yes

	ADD	r9,r9,#16
	MOV	r10,#3
	BL	explode_tile		; new explosion centre
	CMP	r10,#0			; was it blocked
	BEQ	exp_flower_u_petal	; yes - next petal

	SUB	r9,r9,#16*32
	MOV	r10,#2
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_rd_petal

	SUB	r9,r9,#16*32
	MOV	r10,#3
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_rd_petal

	SUB	r9,r9,#16*32
	MOV	r10,#6
	BL	explode_tile

exp_flower_rd_petal
	ADD	r9,r7,#2*16
	ADD	r9,r9,#16*32
	MOV	r10,#2
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_u_petal

	ADD	r9,r9,#16*32
	MOV	r10,#3
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_u_petal

	ADD	r9,r9,#16*32
	MOV	r10,#7
	BL	explode_tile

exp_flower_u_petal
	SUB	r9,r7,#16*32
	LDRB	r4,[r9,#0]		; get tile status
	TST	r4,#128			; blocked?
	BEQ	exp_flower_d_petal	; yes

	SUB	r9,r9,#16*32
	MOV	r10,#3
	BL	explode_tile		; new explosion centre
	CMP	r10,#0			; was it blocked
	BEQ	exp_flower_d_petal	; yes - next petal

	SUB	r9,r9,#16
	MOV	r10,#1
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_ur_petal

	SUB	r9,r9,#16
	MOV	r10,#3
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_ur_petal

	SUB	r9,r9,#16
	MOV	r10,#4
	BL	explode_tile

exp_flower_ur_petal
	SUB	r9,r7,#2*32*16
	ADD	r9,r9,#16
	MOV	r10,#1
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_d_petal

	ADD	r9,r9,#16
	MOV	r10,#3
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_d_petal

	ADD	r9,r9,#16
	MOV	r10,#5
	BL	explode_tile

exp_flower_d_petal
	ADD	r9,r7,#16*32
	LDRB	r4,[r9,#0]		; get tile status
	TST	r4,#128			; blocked?
	BEQ	exp_ending		; yes

	ADD	r9,r9,#16*32
	MOV	r10,#3
	BL	explode_tile		; new explosion centre
	CMP	r10,#0			; was it blocked
	BEQ	exp_ending		; yes - next petal

	SUB	r9,r9,#16
	MOV	r10,#1
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_dr_petal

	SUB	r9,r9,#16
	MOV	r10,#3
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_flower_dr_petal

	SUB	r9,r9,#16
	MOV	r10,#4
	BL	explode_tile

exp_flower_dr_petal
	ADD	r9,r7,#2*32*16
	ADD	r9,r9,#16
	MOV	r10,#1
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_ending

	ADD	r9,r9,#16
	MOV	r10,#3
	BL	explode_tile
	CMP	r10,#0
	BEQ	exp_ending

	ADD	r9,r9,#16
	MOV	r10,#5
	BL	explode_tile

	B	exp_ending

explode_tile
	; on entry
	;	r9  - tile address
	;	r0  - owner ref
	;	r10 - type of blast
	;
	; on exit
	;	r10 - 0=blocked, otherwise unblocked.

	CMP	r10,#3
	MOVEQ	r11,#64
	MOVEQ	r12,#9			; blast centre
	BEQ	apply_blast
	CMP	r10,#1
	MOVEQ	r11,#84
	MOVEQ	r12,#2			; horizontal
	BEQ	apply_blast
	CMP	r10,#2
	MOVEQ	r11,#104
	MOVEQ	r12,#3			; vertical
	BEQ	apply_blast
	CMP	r10,#5
	MOVEQ	r11,#144
	MOVEQ	r12,#5			; right
	CMP	r10,#6
	MOVEQ	r11,#164
	MOVEQ	r12,#6			; up
	CMP	r10,#4
	MOVEQ	r11,#124
	MOVEQ	r12,#4			; left
	CMP	r10,#7
	MOVEQ	r11,#184
	MOVEQ	r12,#7			; down

apply_blast
	MOV	r10,#20			; explosion duration

	LDRB	r4,[r9,#0]		; get tile status
	TST	r4,#128			; blocked?
	BNE	exp_tile_cont		; no - carry on.

	CMP	r4,#0			; removeable blockage?
	MOVEQ	r4,#8
	STREQB	r4,[r9,#4]		; explode that blockage
	STREQB	r10,[r9,#5]		; for this number of frames
	MOVEQ	r4,#33
	STREQB	r4,[r9,#1]		; and use the explosion sprites

	MOV	r10,#0
	MOV	pc,r14			; return with blocked code

exp_tile_cont
	CMP	r4,#128			; empty floor tile?
	STREQB	r11,[r9,#1]		; replace tile sprite with explosion
	STRNEB	r11,[r9,#7]		; use overlay sprite instead
	STRB	r12,[r9,#4]		; store explosion info
	STRB	r10,[r9,#5]
	STRB	r0,[r9,#9]		; store owner ref

	MOV	pc,r14			; return without clearing r10 -> non blocking.

pipe_network_blast
	; on entry,
	; 	r9  - pipe entry point tile address
	;	r10 - remaining flame length
	;	r14 - return address

	STMFD	r13!,{r0-r8,r11,r12,r14}

	LDR	r8,grid_scan_data	; floor map start address

	MOV	r7,r9
	MOV	r14,#20

pipe_loop
	LDR	r8,grid_scan_data	; floor map start address

	LDRB	r1,[r7,#2]		; next pipe x coord
	LDRB	r2,[r7,#3]		; next pipe y coord

	ADD	r5,r8,r1,LSL#4
	ADD	r5,r5,r2,LSL#9		; Find address of next pipe

	CMP	r5,r9			; full circle?
	LDMEQFD	r13!,{r0-r8,r11,r12,pc} ; return, restoring regs.

	MOV	r7,r5

	; Let's just make sure this is pipe first.

	ORR	r1,r1,r2
	BICS	r1,r1,#31
	LDMNEFD	r13!,{r0-r8,r11,r12,pc}

	LDRB	r1,[r5,#0]
	AND	r1,r1,#24
	CMP	r1,#24
	LDMNEFD	r13!,{r0-r8,r11,r12,pc}

	LDRB	r1,[r5,#0]
	AND	r1,r1,#3

	CMP	r1,#1			; pipe opens to right
	BEQ	pipe_exit_blast_right

	CMP	r1,#2                   ; pipe opens to top
	BEQ	pipe_exit_blast_up

	CMP	r1,#3
	BEQ	pipe_exit_blast_down	; pipe opens down

	; so pipe must open to left

pipe_exit_blast_left
	; must preserve r0,r7,r9,r10
	; r0  - owner number
	; r5  - pipe tile address
	; r10 - length of blast

	MOV	r6,r10                  ; flame length
	MOV	r11,#84			; horizontal blast
	MOV	r12,#2

exp_pipe_left
	SUB	r5,r5,#16		; next tile (TDC)

	LDRB	r4,[r5,#5]		; current blast duration of tile
	CMP	r4,#0			; quite new?
	BNE	exp_pipe_left_skip_tile	; yes - abort

	LDRB	r4,[r5,#0]		; get tile status
	TST	r4,#128			; blocked?
	BNE	exp_pipe_left_cont	; no - carry on.

	CMP	r4,#0			; removeable blockage?
	MOVEQ	r4,#8
	STREQB	r4,[r5,#4]		; explode that blockage
	STREQB	r14,[r5,#5]		; for this number of frames
	MOVEQ	r4,#33
	STREQB	r4,[r5,#1]		; and use the explosion sprites

	B	pipe_loop

exp_pipe_left_cont
	CMP	r6,#1			; end of blast?
	MOVEQ	r11,#124
	MOVEQ	r12,#4			; yes - use end sprite

	CMP	r4,#128			; empty floor tile?
	STREQB	r11,[r5,#1]		; replace tile sprite with explosion
	STRNEB	r11,[r5,#7]		; use overlay sprite instead
	STRB	r12,[r5,#4]		; store explosion info
	STRB	r14,[r5,#5]
	STRB	r0,[r5,#9]		; store owner ref

	LDRB	r4,[r5,#2]		; extra1
	TST	r4,#128                 ; = bomb there?
	MOVNE	r6,#1			; yes - quit

exp_pipe_left_skip_tile
	SUBS	r6,r6,#1
	BNE	exp_pipe_left		; continue along length of flame

	B	pipe_loop

pipe_exit_blast_right
	; must preserve r0,r7,r9,r10
	; r5  - pipe tile address
	; r10 - length of blast

	MOV	r6,r10                  ; flame length
	MOV	r11,#84			; horizontal blast
	MOV	r12,#2

exp_pipe_right
	ADD	r5,r5,#16		; next tile (TDC)

	LDRB	r4,[r5,#5]		; current blast duration of tile
	CMP	r4,#0			; quite new?
	BNE	exp_pipe_right_skip_tile ; yes - abort

	LDRB	r4,[r5,#0]		; get tile status
	TST	r4,#128			; blocked?
	BNE	exp_pipe_right_cont	; no - carry on.

	CMP	r4,#0			; removeable blockage?
	MOVEQ	r4,#8
	STREQB	r4,[r5,#4]		; explode that blockage
	STREQB	r14,[r5,#5]		; for this number of frames
	MOVEQ	r4,#33
	STREQB	r4,[r5,#1]		; and use the explosion sprites

	B	pipe_loop

exp_pipe_right_cont
	CMP	r6,#1			; end of blast?
	MOVEQ	r11,#144
	MOVEQ	r12,#5			; yes - use end sprite

	CMP	r4,#128			; empty floor tile?
	STREQB	r11,[r5,#1]		; replace tile sprite with explosion
	STRNEB	r11,[r5,#7]		; use overlay sprite instead
	STRB	r12,[r5,#4]		; store explosion info
	STRB	r14,[r5,#5]
	STRB	r0,[r5,#9]		; store owner ref

	LDRB	r4,[r5,#2]		; extra1
	TST	r4,#128                 ; = bomb there?
	MOVNE	r6,#1			; yes - quit

exp_pipe_right_skip_tile
	SUBS	r6,r6,#1
	BNE	exp_pipe_right		; continue along length of flame

	B	pipe_loop

pipe_exit_blast_up
	; must preserve r0,r7,r9,r10
	; r5  - pipe tile address
	; r10 - length of blast

	MOV	r6,r10                  ; flame length
	MOV	r11,#104			; horizontal blast
	MOV	r12,#3

exp_pipe_up
	SUB	r5,r5,#16*32		; next tile (TDC)

	LDRB	r4,[r5,#5]		; current blast duration of tile
	CMP	r4,#0			; quite new?
	BNE	exp_pipe_up_skip_tile	; yes - abort

	LDRB	r4,[r5,#0]		; get tile status
	TST	r4,#128			; blocked?
	BNE	exp_pipe_up_cont	; no - carry on.

	CMP	r4,#0			; removeable blockage?
	MOVEQ	r4,#8
	STREQB	r4,[r5,#4]		; explode that blockage
	STREQB	r14,[r5,#5]		; for this number of frames
	MOVEQ	r4,#33
	STREQB	r4,[r5,#1]		; and use the explosion sprites

	B	pipe_loop

exp_pipe_up_cont
	CMP	r6,#1			; end of blast?
	MOVEQ	r11,#164
	MOVEQ	r12,#6			; yes - use end sprite

	CMP	r4,#128			; empty floor tile?
	STREQB	r11,[r5,#1]		; replace tile sprite with explosion
	STRNEB	r11,[r5,#7]		; use overlay sprite instead
	STRB	r12,[r5,#4]		; store explosion info
	STRB	r14,[r5,#5]
	STRB	r0,[r5,#9]		; store owner ref

	LDRB	r4,[r5,#2]		; extra1
	TST	r4,#128                 ; = bomb there?
	MOVNE	r6,#1			; yes - quit

exp_pipe_up_skip_tile
	SUBS	r6,r6,#1
	BNE	exp_pipe_up		; continue along length of flame

	B	pipe_loop

pipe_exit_blast_down
	; must preserve r0,r7,r9,r10
	; r5  - pipe tile address
	; r10 - length of blast

	MOV	r6,r10                  ; flame length
	MOV	r11,#104		; horizontal blast
	MOV	r12,#3

exp_pipe_down
	ADD	r5,r5,#16*32		; next tile (TDC)

	LDRB	r4,[r5,#5]		; current blast duration of tile
	CMP	r4,#0			; quite new?
	BNE	exp_pipe_down_skip_tile	; yes - abort

	LDRB	r4,[r5,#0]		; get tile status
	TST	r4,#128			; blocked?
	BNE	exp_pipe_down_cont	; no - carry on.

	CMP	r4,#0			; removeable blockage?
	MOVEQ	r4,#8
	STREQB	r4,[r5,#4]		; explode that blockage
	STREQB	r14,[r5,#5]		; for this number of frames
	MOVEQ	r4,#33
	STREQB	r4,[r5,#1]		; and use the explosion sprites

	B	pipe_loop

exp_pipe_down_cont
	CMP	r6,#1			; end of blast?
	MOVEQ	r11,#184
	MOVEQ	r12,#7			; yes - use end sprite

	CMP	r4,#128			; empty floor tile?
	STREQB	r11,[r5,#1]		; replace tile sprite with explosion
	STRNEB	r11,[r5,#7]		; use overlay sprite instead
	STRB	r12,[r5,#4]		; store explosion info
	STRB	r14,[r5,#5]
	STRB	r0,[r5,#9]		; store owner ref

	LDRB	r4,[r5,#2]		; extra1
	TST	r4,#128                 ; = bomb there?
	MOVNE	r6,#1			; yes - quit

exp_pipe_down_skip_tile
	SUBS	r6,r6,#1
	BNE	exp_pipe_down		; continue along length of flame

	B	pipe_loop

;------------------------------------------------------------------------------
; Grid scanning - continues explosions, etc.
;

	IMPORT	bonus_array
	IMPORT	level_empty
	IMPORT	score
	IMPORT	blkscore

scan_clock
	DCD	0

scan_conveyors
	DCB	13,17,21,25

scan_exit_beam
	DCB	222,222,223,224,225,225,224,223

grid_scan_data
	DCD	floor_map
	DCD	arena_depth
	DCD	level_empty
	DCD	score
	DCD	blkscore

grid_scan
	EXPORT	grid_scan

	STMFD	r13!,{r0-r12,r14}

	LDR	r0,scan_clock
	ADD	r0,r0,#1
	STR	r0,scan_clock

	LDR	r0,grid_scan_data
	ADD	r0,r0,#33*16		; start of visible game area (TDC)

	LDR	r1,grid_scan_data+4
	LDR	r1,[r1,#0]		; Rows to check

grid_scany
	MOV	r3,r0			; r3 = start of row on map
	MOV	r2,#vis_tiles_h		; columns to check

grid_scanx
	LDRB	r4,[r3,#0]		; get tile status
	TST	r4,#128			; top bit set
	BEQ	scan_tbu

	CMP	r4,#128+16		; conveyor?
	BLT	scan_not_conveyor	; no - go away
	CMP	r4,#128+20
	BGE	scan_not_conveyor	; no - go away

	SUB	r4,r4,#16
	AND	r4,r4,#3		; get conveyor direction

	ADR	r5,scan_conveyors
	LDRB	r5,[r5,r4]		; get base sprite number

	LDR	r4,scan_clock
	MOV	r4,r4,LSR#1		; slow conveyor a bit
	AND	r4,r4,#3		; get clock value 0..3
	ADD	r5,r5,r4		; add to base conveyor sprite
	STRB	r5,[r3,#1]		; store new tile sprite number

	B	scan_rendez

scan_not_conveyor
	; is it anything else requiring animation?
	CMP	r4,#149			; is it an open exit tile?
	BNE	scan_not_open_exit

	LDR	r5,scan_clock
	TST	r5,#16
	MOV	r5,#233
	ADDEQ	r5,r5,#1		; flick between frames 233 and 234

	STRB	r5,[r3,#1]		; store new sprite number

	B	scan_rendez

scan_not_open_exit
	CMP	r4,#128+20		; is it fuel?
	BNE	scan_rendez		; no - skip

	LDRB	r4,[r3,#5]		; is it burning?
	CMP	r4,#0
	BNE	scan_rendez		; yes - skip

	ADD	r6,r3,#5		; address of blast duration byte

	LDRB	r4,[r6,#-(32*16)]	; Tile above burning?
	CMP	r4,#0
	BEQ	burn_below
	CMP	r4,#10
	BLT	ignite_fuel

burn_below
	LDRB	r4,[r6,#(32*16)]	; Tile below burning?
	CMP	r4,#0
	BEQ	burn_left
	CMP	r4,#10
	BLT	ignite_fuel

burn_left
	LDRB	r4,[r6,#-16]		; Tile to left burning?
	CMP	r4,#0
	BEQ	burn_right
	CMP	r4,#10
	BLT	ignite_fuel

burn_right
	LDRB	r4,[r6,#16]		; Tile to right burning?
	CMP	r4,#0
	BEQ	scan_rendez
	CMP	r4,#10
	BGE	scan_rendez

ignite_fuel
	;SWI	263

	MOV	r4,#9
	STRB	r4,[r3,#4]		; burn that fuel
	MOV	r4,#20-5
	STRB	r4,[r3,#5]		; for this number of frames
	MOV	r4,#33+5
	STRB	r4,[r3,#1]		; and use the explosion sprites
	MOV	r4,#128
	STRB	r4,[r3,#0]		; and there's ordinary floor underneath

	B	scan_rendez

scan_tbu
	; top bit unset
	; r4 contains tile status

	; Is this a removeable blockage? If so, we must signal the level is not yet
	; complete...
	CMP	r4,#0			; removeable blockage..?

	LDREQ	r5,grid_scan_data+8	; address of level_empty variable
	STREQ	r4,[r5,#0]		; store 0 in level_empty.

	CMP	r4,#2			; exit force field beam (code 2?)
	BNE	not_exit_beam

	; exit beam anim has 8 frames
	LDR	r4,scan_clock
	MOV	r4,r4,LSR#2		; slow animation a bit
	ADD	r4,r4,r3,LSR#4		; 1 frame offset per x position (from tile address)
	AND	r4,r4,#7		; keep within range 0..7

	ADR	r5,scan_exit_beam
	LDRB	r4,[r5,r4]		; get frame sprite number
	STRB	r4,[r3,#1]		; store new sprite number

	B	scan_rendez		; finished handling exit beam tile

not_exit_beam
scan_rendez
	LDRB	r4,[r3,#5]		; get blast duration

	CMP	r4,#0
	BEQ	scan_next		; no explosion - goto next tile

	LDRB	r6,[r3,#0]		; get tile status
	CMP	r6,#0			; is it exploding blockage?
	BEQ	scan_exp_block		; yes - go and see to it

	CMP	r6,#128			; is it an empty floor tile?

	LDREQB	r5,[r3,#1]		; get sprite number (tile)
	LDRNEB	r5,[r3,#7]              ; (overlay)
	ADD	r5,r5,#1
	STREQB	r5,[r3,#1]		; inc. sprite number (tile)
        STRNEB	r5,[r3,#7]		; (overlay)

	SUBS	r4,r4,#1
	STRB	r4,[r3,#5]		; dec. explosion duration
	BNE	scan_next		; if not finished, goto next tile

	; Explosion has ended - clean up tile info.
	STRB	r4,[r3,#4]		; No more blast

	LDRB	r4,[r3,#6]		; what tile used to be
	STRB	r4,[r3,#0]		; what tile is now.

	CMP	r4,#128			; = floor?
	MOV	r4,#0
	STREQB	r4,[r3,#1]		; yes - replace with blank floor tile.
        STRB	r4,[r3,#7]		; no - clear overlay sprite
scan_next
	ADD	r3,r3,#16		; next tile (TDC)
	SUBS	r2,r2,#1		; end of row?
	BNE	grid_scanx		; continue for rest of row

	ADD	r0,r0,#32*16		; move to next row (TDC)
	SUBS	r1,r1,#1		; all rows complete?
	BNE	grid_scany		; continue for rest of map

	; Finished main grid scan - now do bonus updates
	B	update_bonus_data


scan_exp_block
	SUB	r4,r4,#1		; decrement explosion duration
	STRB	r4,[r3,#5]

	LDRB	r5,[r3,#1]		; get sprite number
	ADD	r5,r5,#1		; increment it

	CMP	r4,#0			; end of explosion?
	MOVEQ	r5,#0			; return tile to normal floor sprite
	STRB	r5,[r3,#1]

	BNE	scan_next

	; Now explosion has finished, tidy up
	LDR	r5,grid_scan_data+16
	LDR	r6,[r5,#0]
	ADD	r6,r6,#1
	STR	r6,[r5,#0]		; inc number of blockages destroyed this frame

	MOV	r5,#0
	STRB	r5,[r3,#4]		; blast type = none

	LDRB	r5,[r3,#6]		; what tile should be
	STRB	r5,[r3,#0]		; store new status
	CMP	r5,#128			; empty floor?
	BEQ	scan_next		; yes - branch

	; A bonus has been revealed! Set up data for it.

	;STRB	r5,[r3,#0]		; tile status = bonus
	SUB	r5,r5,#127
	ADD	r5,r5,#51		; bonus sprites offset
	STRB	r5,[r3,#1]

	RSB	r6,r2,#vis_tiles_h+1
	LDR	r7,grid_scan_data+4
	LDR	r7,[r7,#0]		; arena_depth
	SUB	r7,r7,r1
	ADD	r7,r7,#1		; (sentinel row) coords of tile

	LDR	r8,bonus_create_data+4	; address of bonus map data
	ADD	r8,r8,r7,LSL#5		; 32 tiles per line
	ADD	r8,r8,r6		; r8 = coord of bonus on bonus map

	LDR	r9,bonus_create_data
	MOV	r10,#0

find_empty_bonus
	LDRB	r11,[r9,#2]		; bonus status
	TST	r11,#1<<7		; is this bonus allocated
	BEQ	found_empty_bonus	; no - use it

	ADD	r10,r10,#1
	ADD	r9,r9,#4
	CMP	r10,#128		; all bonuses checked?
	BLT	find_empty_bonus

	; No unallocated bonus space! Panic!
	B	scan_next

found_empty_bonus
	MOV	r6,r6,LSL#3
	MOV	r7,r7,LSL#3
	STRB	r6,[r9,#0]
	STRB	r7,[r9,#1]		; store x,y position of bonus in bonus array

	SUB	r5,r5,#51		; bonus type
	AND	r5,r5,#15		; make sure no overflow
	MOV	r5,r5,LSL#3
	ORR	r5,r5,#1<<7		; bonus exists -> new status byte

	STRB	r5,[r9,#2]		; store status byte

	MOV	r5,#0
	STRB	r5,[r9,#3]		; anim_ctr = 0

	B	scan_next

update_flour_data
	DCD	flour_array
	DCD	players

update_flour_explosions
	LDR	r0,update_flour_data	; address of flour array
	LDR	r3,update_flour_data+4	; address of player array

	MOV	r2,#64			; max possible flour explosions

update_flour_scan
	LDRB	r1,[r0,#2]		; get status of flour explosion
	TST	r1,#1<<7		; exists?
	BEQ	next_flour_update_scan

	; flour explosion stil active...
	;SWI	263
	LDRB	r1,[r0,#3]		; get sprite number
	SUBS	r1,r1,#1
	STRB	r1,[r0,#3]		; store new sprite number
	STREQB	r1,[r0,#2]		; if end of anim, deactivate explosion.
	BEQ	next_flour_update_scan

	; Here's where we check to see if there's a player under the cloud.
	; If there is, he will get covered in flour for a time.

	MOV	r4,r3			; working address of player array
	MOV	r5,#4			; number of players

shower_player_loop
	LDRB	r1,[r0,#0]		; exp xpos
	LDR	r6,[r4,#0]		; player xpos
	SUB	r6,r6,#8		; centre of explosion is mid tile.
	SUBS	r6,r6,r1,LSL#4
	RSBLT	r6,r6,#0		; absolute distance from explosion in 28:4 format

	CMP	r6,#24			; within range?
	BGT	shower_next_player	; no - try next player

	LDRB	r1,[r0,#1]		; exp ypos
	LDR	r6,[r4,#4]		; player ypos
	SUB	r6,r6,#8		; centre of explosion is mid tile.
	SUBS	r6,r6,r1,LSL#4
	RSBLT	r6,r6,#0		; absolute distance from explosion in 28:4 format

	CMP	r6,#24			; within range?
	BGT	shower_next_player	; no - try next player

	; Player is within range. They will be convered in flour unless they are
	; currently invulnerable.
	; r4 points to their control block

	LDRB	r1,[r4,#11]		; player status
	TST	r1,#1<<3		; invulnerable bit
	BNE	shower_next_player	; leave if they are invulnerable

	; Set 'floured' bit in extra_flags
	LDRB	r1,[r4,#10]
	ORR	r1,r1,#1<<5
	STRB	r1,[r4,#10]

	; Set duration of floured effect to maximum
	MOV	r1,#255
	STRB	r1,[r4,#16]

	; And I think that will do for now...

shower_next_player
	ADD	r4,r4,#32
	SUBS	r5,r5,#1
	BNE	shower_player_loop

next_flour_update_scan
	ADD	r0,r0,#4
	SUBS	r2,r2,#1
	BNE	update_flour_scan	; check all flour explosions

	LDMFD	r13!,{r0-r12,pc}	; finish now we're done

update_bonus_data
	; Scan bonus array to see if any bonuses lie on tiles with explosions.
	LDR	r0,grid_scan_data	; map data
	LDR	r1,bonus_create_data	; bonus array

	MOV	r2,#128			; bonus to check

bonus_update_loop
	LDRB	r3,[r1,#2]		; status
	TST	r3,#1<<7                ; bonus exists?
	BNE	update_this_bonus

bonus_rendez
	ADD	r1,r1,#4		; next bonus in array

	SUBS	r2,r2,#1
	BNE	bonus_update_loop	; until all bonuses have been checked

	B	update_flour_explosions

update_this_bonus
	TST	r3,#1			; is bonus on the move?
	BNE	bonus_moving		; yes - tile below does not affect it.

	LDRB	r4,[r1,#0]		; xpos
	LDRB	r5,[r1,#1]              ; ypos

	MOV	r4,r4,ASR#3             ; tile position
	MOV	r5,r5,ASR#3		; don't forget these are already >> by 1

	ADD	r3,r0,r5,LSL#9
	ADD	r3,r3,r4,LSL#4		; address of tile bonus is on

	LDRB	r6,[r3,#5]		; get blast duration for tile

	CMP	r6,#0			; any explosion here?
	BEQ	bonus_rendez		; nope, leave this bonus alone

	; Bonus must be moved due to explosion - begin animation
	ADD	r4,r4,r5
	AND	r4,r4,#3
	MOV	r4,r4,LSL#1		; use lower bits of position sum for direction (RND?)
	ORR	r4,r4,#1		; set moving flag

	LDRB	r5,[r1,#2]		; bonus status
	BIC	r5,r5,#7		; clear old direction/moving flag
	ORR	r5,r5,r4		; add in new direction/moving flag
	STRB	r5,[r1,#2]		; store new status

	MOV	r5,#128
	STRB	r5,[r3,#6]
	STRB	r5,[r3,#0]		; tile status = floor
	LDRB	r5,[r3,#7]
	STRB	r5,[r3,#1]		; tile sprite = floor
	MOV	r5,#0
	STRB	r5,[r3,#7]

	B	bonus_rendez

bonus_debug
	EXPORT	bonus_debug
	DCD	&dead1234
	DCD	0

bonus_arena
	DCD	arena_depth

bonus_moving
	; Bonus is flying through the air.
	LDRB	r4,[r1,#0]
	LDRB	r5,[r1,#1]		; get xpos,ypos

	MOV	r6,r3,ASR#1
	ANDS	r6,r6,#3		; get direction

	SUBEQ	r4,r4,#1		; dir=0, move left

	CMP	r6,#1
	ADDEQ	r4,r4,#1		; dir=1, move right

	CMP	r6,#2
	SUBEQ	r5,r5,#1		; dir=2, move up

	CMP	r6,#3
	ADDEQ	r5,r5,#1		; dir=3, move down

	CMP	r4,#0
	MOVEQ	r4,#vis_tiles_h*8
	BEQ	bonus_wrap_y
	CMP	r4,#vis_tiles_h*8
	MOVEQ	r4,#0

bonus_wrap_y
	LDR	r6,bonus_arena
	LDR	r6,[r6,#0]		; number of tiles vertically
	ADD	r6,r6,#1
	MOV	r6,r6,LSL#3

	CMP	r5,#0
	MOVEQ	r5,r6
	BEQ	bonus_wrapped
	CMP	r5,r6
	MOVEQ	r5,#0

bonus_wrapped
	STRB	r4,[r1,#0]
	STRB	r5,[r1,#1]		; store new position

	LDRB	r6,[r1,#3]		; get anim_ctr
	ADD	r6,r6,#1
	CMP	r6,#32
	MOVGE	r6,#24			; keep within range of arc table
	STRB	r6,[r1,#3]		; incremeted

	ADR	r7,bonus_arc
	LDRB	r6,[r7,r6]		; get 'height'

	CMP	r6,#0			; has tile 'landed'?
	BNE	bonus_rendez		; no - let it continue

	; It's touched down. Check tile underneath
	MOV	r4,r4,ASR#3
	MOV	r5,r5,ASR#3		; tile position

	ADD	r7,r0,r5,LSL#9
	ADD	r7,r7,r4,LSL#4		; address of tile bonus is on

	LDRB	r4,[r7,#5]		; get tile blast_len
	CMP	r4,#0			; is there an explosion here?
	BNE	bonus_rendez		; yes - let bonus continue

	LDRB	r4,[r7,#0]		; get tile status
	CMP	r4,#128			; is it empty floor?
	BNE	bonus_rendez		; no - let bonus continue

	; Bonus has touched down on empty tile. Set up data
	MOV	r6,r3,ASR#3
	AND	r6,r6,#15		; get bonus type
	ADD	r4,r6,r4
	STRB	r4,[r7,#0]		; new tile type

	ADD	r6,r6,#51		; bonus sprite start
	STRB	r6,[r7,#1]		; bonus tile sprite

	BIC	r3,r3,#1		; stop bonus moving
	STRB	r3,[r1,#2]		; store new bonus status

	; Our work here is done... I think

	B	bonus_rendez

bonus_create_data
	DCD	bonus_array

bonus_arc				; just like bomb_arc funnily enough.
	DCB	0,7,12,16,20,22,25,28,30,32,33,34,34
	DCB	34,33,32,30,28,25,22,20,16,12,7
	DCB	0,4,8,10,12,10,8,4,0

	ALIGN

	IMPORT	flip_bonus

drawabonus_data
	DCD	flip_bonus
	DCD	scrmem_arena

drawabonus
	EXPORT	drawabonus
	; On entry,
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - address of control block for bonus being drawn

	STMFD	r13!,{r0-r10,r14}	; save regs

	ADR	r2,drawabonus_data
	LDMIA	r2,{r2,r3}
	LDR	r3,[r3,#0]		; load variables

	; Register status -
	;
	; r0	- offset in pixels from top of screen to start of bonus
	; r1	- address of bonus control block
	; r2	- address of bonus graphics data
	; r3	- screen memory start
	; r4	- number of pixel rows of sprite to draw
	; r5	- number of pixel rows of sprite to skip before drawing

	LDRB	r6,[r1,#3]		; Get anim_ctr
	AND	r6,r6,#7
	LDRB	r7,[r1,#2]
	MOV	r7,r7,ASR#1
	AND	r7,r7,#3		; get direction

	ADD	r2,r2,r7,LSL#5		; 32 bytes of pointers per direction
	LDR	r2,[r2,r6,LSL#2]	; get address of sprite to use

	BL	bonus_shadow		; yes - draw shadow
	BL	bonus_clipped		; and clipped bonus
	B	drawabonus_exit

drawabonus_exit

	LDMFD	r13!,{r0-r10,pc}	; restore regs and return

bonus_shadow
	STMFD	r13!,{r0-r4,r11,r12,r14}

	ADRL	r7,bonus_arc
	LDRB	r8,[r1,#3]		; get zpos index
	LDRB	r8,[r7,r8]		; get 'height'

	LDRB	r4,[r1,#1]		; ypos
	MOV	r4,r4,LSL#1
	SUB	r0,r4,r0,ASR#4		; subtract global y

	LDRB	r1,[r1,#0]		; read player xpos
	MOV	r1,r1,LSL#1
	SUB	r1,r1,#1<<4		; skip sentinel column
	SUB	r0,r0,#1<<4

	ADD	r0,r0,r8
	SUB	r1,r1,r8		; move shadow from bonus

	; Clip shadow to game area
	MOV	r4,#16			; rows to draw
	MOV	r11,#16			; columns to draw
	MOV	r12,#0			; columns to skip

	CMP	r1,#0                   ; off left?
	BGE	bclipshad_right
	RSB	r5,r1,#0
	CMP	r5,#16			; completely off left?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	MOV	r12,r5
	RSB	r11,r12,#16
	B	bclipshad_top

bclipshad_right
	CMP	r1,#16*(vis_tiles_h-1) ; going off right?
	BLE	bclipshad_top
	CMP	r1,#16*vis_tiles_h	; completely off right?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
        RSB	r11,r1,#16*vis_tiles_h

bclipshad_top
	CMP	r0,#0			; going off top?
	BGE	bclipshad_bottom
	RSB	r6,r0,#0
	CMP	r6,#16			; completely off top?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r6,#16
	ADD	r2,r2,r6,LSL#4
	MOV	r0,#0
	B	bshadclip_done

bclipshad_bottom
	CMP	r0,#16*(vis_tiles_v-1)	; going off bottom?
	BLE	bshadclip_done
	CMP	r0,#16*vis_tiles_v	; completely off bottom?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r0,#16*vis_tiles_v

bshadclip_done

	; Register status
	;
	; r0	- Offset from top of screen to bonus, in pixels
	; r1	- Offset from left of screen to bonus, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#8
	ADD	r3,r3,r0,LSL#6		; move down screen to bonus position
	ADD	r3,r3,r1		; and across to bonus position

	MOV	r7,#255			; byte mask
	MOV	r8,#0			; black pixel

	ADR	r0,drawabonusshadow_pixels

drawabonusshadow_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	MOV	r14,r11

	ADD	pc,r0,r12,LSL#4		; 4 instructions per pixel

drawabonusshadow_pixels
	TST	r7,r5			; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r6			; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r9			; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r10			; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r10,LSR#16		; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	bshadow_line_done

	TST	r7,r10,LSR#24		; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

bshadow_line_done
	ADD	r3,r3,#320
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	drawabonusshadow_pixel_line	; continue until done.

	LDMFD	r13!,{r0-r4,r11,r12,pc}		; restore regs and return

bonus_clipped
	STMFD	r13!,{r0-r4,r11,r12,r14}

	LDRB	r4,[r1,#1]		; ypos
	MOV	r4,r4,LSL#1
	SUB	r0,r4,r0,ASR#4		; subtract global y

	LDRB	r1,[r1,#0]		; read player xpos
	MOV	r1,r1,LSL#1
	SUB	r1,r1,#1<<4		; skip sentinel column
	SUB	r0,r0,#1<<4

	; Clip bomb to game area
	MOV	r4,#16			; rows to draw
	MOV	r11,#16			; columns to draw
	MOV	r12,#0			; columns to skip

	CMP	r1,#0                   ; off left?
	BGE	clipbonus_right
	RSB	r5,r1,#0
	CMP	r5,#16			; completely off left?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	MOV	r12,r5
	RSB	r11,r12,#16
	B	clipbonus_top

clipbonus_right
	CMP	r1,#16*(vis_tiles_h-1) ; going off right?
	BLE	clipbonus_top
	CMP	r1,#16*vis_tiles_h	; completely off right?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
        RSB	r11,r1,#16*vis_tiles_h

clipbonus_top
	CMP	r0,#0			; going off top?
	BGE	clipbonus_bottom
	RSB	r6,r0,#0
	CMP	r6,#16			; completely off top?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r6,#16
	ADD	r2,r2,r6,LSL#4
	MOV	r0,#0
	B	bonusclip_done

clipbonus_bottom
	CMP	r0,#16*(vis_tiles_v-1)	; going off bottom?
	BLE	bonusclip_done
	CMP	r0,#16*vis_tiles_v	; completely off bottom?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r0,#16*vis_tiles_v

bonusclip_done

	; Register status
	;
	; r0	- Offset from top of screen to bonus, in pixels
	; r1	- Offset from left of screen to bonus, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#8
	ADD	r3,r3,r0,LSL#6		; move down screen to bonus position
	ADD	r3,r3,r1		; and across to bonus position

	MOV	r7,#255			; byte mask

	ADR	r0,drawaclipbonus_pixels

drawaclipbonus_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	MOV	r14,r11

	ADD	pc,r0,r12,LSL#4		; 4 instructions per pixel

drawaclipbonus_pixels
	ANDS	r8,r7,r5		; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r6		; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r9		; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r10		; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	clipbonus_line_done

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

clipbonus_line_done
	ADD	r3,r3,#320
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	drawaclipbonus_pixel_line	; continue until done.

	LDMFD	r13!,{r0-r4,r11,r12,pc}		; restore regs and return

	DCD	&deadbeeb


	IMPORT	bonus_array

draw_all_bonuses_data
	DCD	bonus_array

draw_all_bonuses
	EXPORT	draw_all_bonuses

	; On entry, r0 = global_y.

	STMFD	r13!,{r1,r2,r3,r14}	; save regs

	LDR	r1,draw_all_bonuses_data
	MOV	r2,#128

draw_all_bonuses_loop
	LDRB	r3,[r1,#2]
	TST	r3,#1<<7		; does bonus exist?

	BEQ	skip_this_bonus		; no - jump

	TST	r3,#1			; is bonus moving?

	BLNE	drawabonus		; yes - draw it

skip_this_bonus
	ADD	r1,r1,#4		; go to next bonus entry

	SUBS	r2,r2,#1		; dec bonus counter
	BNE	draw_all_bonuses_loop	; continue until all bonuses have been drawn

	LDMFD	r13!,{r1,r2,r3,pc}	; restore regs, and return

;--------------------------------------------------------------------------------------
; Small Text display
;

	IMPORT	small_font
	IMPORT	small_bonus
	IMPORT	screenbank

sml_draw_string_data
	DCD	small_font
	DCD	0
	DCD	small_bonus
	DCD	screenbank

draw_small_string
	EXPORT	draw_small_string

	STMFD	r13!,{r14}

	LDR	r14,sml_draw_string_data+12
	LDR	r14,[r14,#4]
	STR	r14,sml_draw_string_data+4
	BL	draw_small_string_act

	LDR	r14,sml_draw_string_data+12
	LDR	r14,[r14,#8]
	STR	r14,sml_draw_string_data+4
	BL	draw_small_string_act

	LDMFD	r13!,{pc}

draw_small_string_addr
	; On entry, r0 contains address of string, terminated with 0
	; r1 contains on-screen address of top left corner of string
	STMFD	r13!,{r0-r12,r14}

	SUB	r3,r1,#4

	B	sml_string_loop

draw_small_string_act

	; On entry, r0 contains address of string, terminated with 0
	; r1 -> xpos
	; r2 -> ypos
	;
	; Now draws direct to screen...

	STMFD	r13!,{r0-r12,r14}

	LDR	r3,sml_draw_string_data+4
	ADD	r3,r3,r2,LSL#8
	ADD	r3,r3,r2,LSL#6
	ADD	r3,r3,r1		; address of string on screen

	SUB	r3,r3,#4

sml_string_loop
	ADD	r3,r3,#4		; Move to next character

	MOV	r1,r3			; screen address of next character

	LDRB	r2,[r0],#1		; get next character

	CMP	r2,#0			; end of string?
	LDMEQFD	r13!,{r0-r12,pc}	; yes - exit

	; Supported chars are 0-9 A-Z ' ' and ',' skip any others

	CMP	r2,#' '
	BEQ	sml_space_draw

	CMP	r2,#'0'
	BLT	sml_string_loop		; unknown - skip
	CMP	r2,#'9'
	SUBLE	r2,r2,#'0'		; it's a digit
	BLE	sml_char_draw

	CMP	r2,#','
	MOVEQ	r2,#36
	BLE	sml_char_draw		; draw a ','

	CMP	r2,#'A'
	BLT	sml_string_loop
	CMP	r2,#'Z'
	BGT	sml_string_loop
	SUB	r2,r2,#'A'-10

sml_char_draw
	; r2 is char ref number to draw

	MOV	r11,#255

	LDR	r4,sml_draw_string_data
	ADD	r4,r4,r2,LSL#2		; address of char gfx data

	MOV	r5,#7
sml_char_yloop
	LDR	r6,[r4],#148		; get char gfx data, and move to next line

	AND	r12,r11,r6
	STRB	r12,[r1,#0]
	AND	r12,r11,r6,LSR#8
	STRB	r12,[r1,#1]
	AND	r12,r11,r6,LSR#16
	STRB	r12,[r1,#2]
	AND	r12,r11,r6,LSR#24
	STRB	r12,[r1,#3]

	ADD	r1,r1,#320
	SUBS	r5,r5,#1
	BNE	sml_char_yloop

	CMP	r2,#36			; ',' ?
	SUBEQ	r3,r3,#1		; a comma is only 3 pixels wide

	B	sml_string_loop

sml_space_draw
	; draw a blank space

	MOV	r5,#7
	MOV	r12,#53
sml_space_yloop
	STRB	r12,[r1,#0]
	STRB	r12,[r1,#1]
	STRB	r12,[r1,#2]
	STRB	r12,[r1,#3]

	ADD	r1,r1,#320
	SUBS	r5,r5,#1
	BNE	sml_space_yloop

	B	sml_string_loop

draw_small_bonus
	; On entry,
	; r0 - number of bonus to draw
	; r1,r2 -> xpos,ypos


	STMFD	r13!,{r14}

	LDR	r14,sml_draw_string_data+12
	LDR	r14,[r14,#4]
	STR	r14,sml_draw_string_data+4
	BL	draw_small_bonus_act

	LDR	r14,sml_draw_string_data+12
	LDR	r14,[r14,#8]
	STR	r14,sml_draw_string_data+4
	BL	draw_small_bonus_act

	LDMFD	r13!,{pc}

draw_small_bonus_act
	STMFD	r13!,{r0-r6,r14}

	LDR	r3,sml_draw_string_data+4	; screen address
	ADD	r3,r3,r2,LSL#8
	ADD	r3,r3,r2,LSL#6
	ADD	r1,r3,r1		; r1 = display address for bonus

	LDR	r2,sml_draw_string_data+8
	ADD	r2,r2,r0,LSL#6		; r2 = address of bonus gfx data

	MOV	r0,#7			; row count
	MOV	r5,#255

sml_bonus_yloop
	LDMIA	r2!,{r3,r4}		; get row gfx data

	AND	r6,r5,r3
	STRB	r6,[r1,#0]

	AND	r6,r5,r3,LSR#8
	STRB	r6,[r1,#1]

	AND	r6,r5,r3,LSR#16
	STRB	r6,[r1,#2]

	AND	r6,r5,r3,LSR#24
	STRB	r6,[r1,#3]

	AND	r6,r5,r4
	STRB	r6,[r1,#4]

	AND	r6,r5,r4,LSR#8
	STRB	r6,[r1,#5]

	AND	r6,r5,r4,LSR#16
	STRB	r6,[r1,#6]

	ADD	r1,r1,#320
	SUBS	r0,r0,#1
	BNE	sml_bonus_yloop

	LDMFD	r13!,{r0-r6,pc}

;--------------------------------------------------------------------------------------
; Text display
;

	IMPORT	font_wid
	IMPORT	compiler_sprite_font

draw_string_data
	DCD	font_wid
	DCD	scrmem
	DCD	compiler_sprite_font

draw_string_cols
	DCB	3,44,46,0
	DCB	7,23,55,0
	DCB	35,67,99,0
	DCB	81,117,246,0
	DCB	128,139,203,0
	DCB	27,151,223,0
	DCB	162,201,249,0
	DCB	47,211,255,0

draw_string
	EXPORT	draw_string
	; r0 = address of string, terminated by 0
	; r1 = xpos
	; r2 = ypos
	; r3 = col

	STMFD	r13!,{r3-r12,r14}

	MOV	r7,r0			; move string pointer

	SUB	r1,r1,#1
	SUB	r2,r2,#1

	ADR	r4,draw_string_data
	LDMIA	r4,{r4-r6}

	LDR	r5,[r5,#0]		; address of screen memory

	ADD	r5,r5,r2,LSL#8
	ADD	r5,r5,r2,LSL#6
	ADD	r5,r5,r1		; Screen address of start of string

	; Set up colours
	ADR	r8,draw_string_cols
	ADD	r8,r8,r3,LSL#2		; find entry in colour table

	LDRB	r1,[r8,#0]		; dark
	LDRB	r2,[r8,#1]		; medium
	LDRB	r3,[r8,#2]		; light

draw_string_char_loop
	LDRB	r8,[r7],#1		; Get next character

	CMP	r8,#0			; End of string?
	LDMEQFD	r13!,{r3-r12,pc}	; yes - we're done here

	SUB	r8,r8,#32		; font starts at space

	MOV	r0,r5			; Load character screen address

	LDRB	r9,[r4,r8]		; get width
	ADD	r9,r9,#1		; 1 pixel gap between chars

	ADD	r5,r5,r9		; move on for next char

	ADR	r14,draw_string_char_loop ; we want to return here
	LDR	pc,[r6,r8,LSL#2]	; jump to character draw routine

draw_char
	EXPORT	draw_char
	; r0 = ascii character
	; r1 = xpos
	; r2 = ypos
	; r3 = col

	STMFD	r13!,{r3-r12,r14}

	MOV	r7,r0			; move character

	SUB	r1,r1,#1
	SUB	r2,r2,#1

	ADR	r4,draw_string_data
	LDMIA	r4,{r4-r6}

	LDR	r5,[r5,#0]		; address of screen memory

	ADD	r5,r5,r2,LSL#8
	ADD	r5,r5,r2,LSL#6
	ADD	r5,r5,r1		; Screen address of start of char

	; Set up colours
	ADR	r8,draw_string_cols
	ADD	r8,r8,r3,LSL#2		; find entry in colour table

	LDRB	r1,[r8,#0]		; dark
	LDRB	r2,[r8,#1]		; medium
	LDRB	r3,[r8,#2]		; light

	SUB	r7,r7,#32		; font starts at space

	MOV	r0,r5			; Load character screen address

	ADR	r14,draw_char_end	; we want to return here
	LDR	pc,[r6,r7,LSL#2]	; jump to character draw routine

draw_char_end
	LDMFD	r13!,{r3-r12,pc}


draw_string_highlight
	EXPORT	draw_string_highlight
	; r0 = address of string, terminated by 0
	; r1 = xpos
	; r2 = ypos
	; r3 = pixel colour

	STMFD	r13!,{r3-r12,r14}

	MOV	r7,r0			; move string pointer

	SUB	r1,r1,#1
	SUB	r2,r2,#1

	ADR	r4,draw_string_data
	LDMIA	r4,{r4-r6}

	LDR	r5,[r5,#0]		; address of screen memory

	ADD	r5,r5,r2,LSL#8
	ADD	r5,r5,r2,LSL#6
	ADD	r5,r5,r1		; Screen address of start of string

	; Set up colours
	MOV	r1,r3
	MOV	r2,r3

draw_hl_string_char_loop
	LDRB	r8,[r7],#1		; Get next character

	CMP	r8,#0			; End of string?
	LDMEQFD	r13!,{r3-r12,pc}	; yes - we're done here

	SUB	r8,r8,#32		; font starts at space

	MOV	r0,r5			; Load character screen address

	LDRB	r9,[r4,r8]		; get width
	ADD	r9,r9,#1		; 1 pixel gap between chars

	ADD	r5,r5,r9		; move on for next char

	ADR	r14,draw_hl_string_char_loop ; we want to return here
	LDR	pc,[r6,r8,LSL#2]	; jump to character draw routine

get_string_width
	EXPORT	get_string_width
	; On entry,
	; r0 - pointer to string

	STMFD	r13!,{r1-r3,r14}

	LDR	r1,draw_string_data	; address of font width table

	MOV	r2,#0

width_loop
	LDRB	r3,[r0],#1

	CMP	r3,#0                   ; end of string?
	SUBEQ	r0,r2,#1		; string length (-character spacing)
	LDMEQFD	r13!,{r1-r3,pc}		; yes - return string length

	SUB	r3,r3,#32		; font starts at space

	LDRB	r3,[r1,r3]		; get character width
	ADD	r3,r3,#1		; between character spacing
	ADD	r2,r2,r3		; add to length so far

	B	width_loop

;------------------------------------------------------------------------------
; Draw menu screen
;

	IMPORT	flour_gfx
        IMPORT	screenres

draw_menu_data
	DCD	flour_gfx		; used for storing menu background
	DCD	scrmem
	DCD	1280			; loop counter
	DCD	screenres

draw_menu_screen
	EXPORT	draw_menu_screen

	STMFD	r13!,{r0}
	LDR	r0,draw_menu_data+12
	LDR	r0,[r0,#0]
	CMP	r0,#0
	LDMFD	r13!,{r0}
	BNE	H_draw_menu_screen

	STMFD	r13!,{r0-r10,r14}

	ADR	r0,draw_menu_data
	LDMIA	r0,{r0-r2}
	LDR	r1,[r1,#0]

menu_copy_loop
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}

	SUBS	r2,r2,#1
	BNE	menu_copy_loop

	LDMFD	r13!,{r0-r10,pc}


;------------------------------------------------------------------------------
;
; Clear screen routine - completely black screen
;

draw_black_screen_data
	DCD	scrmem

draw_black_screen
	EXPORT	draw_black_screen

	STMFD	r13!,{r0-r5,r14}

	MOV	r0,#0
	MOV	r1,#0
	MOV	r2,#0
	MOV	r3,#0			; black pixel data

	LDR	r4,draw_black_screen_data
	LDR	r4,[r4,#0]              ; screen address

	MOV	r5,#(320*256)/(4*4*4)	; loop counter

draw_black_screen_loop
	STMIA	r4!,{r0-r3}
	STMIA	r4!,{r0-r3}
	STMIA	r4!,{r0-r3}
	STMIA	r4!,{r0-r3}		; blat 4*4*4 black pixels

	SUBS	r5,r5,#1
	BNE	draw_black_screen_loop	; continue for whole screen

	LDMFD	r13!,{r0-r5,pc}		; return

;------------------------------------------------------------------------------
;
; Enemy support routines
;
	IMPORT	enemy_anims
	IMPORT	nme_death_anim

drawanenemy_data
	DCD	enemy_anims
	DCD	scrmem_arena
	DCD	0
	DCD	nme_death_anim

drawanenemy
	EXPORT	drawanenemy
	; On entry,
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - address of control block for enemy being drawn

	STMFD	r13!,{r0-r10,r14}	; save regs

	STR	r0,drawanenemy_data+8	; for future reference

	LDR	r3,[r1,#4]		; get enemy ypos.
	SUB	r3,r3,#1<<4		; Skip sentinel row

	; Offset in pixels from top of visible screen to enemy =
	;	enemy.ypos - (global_y>>4)

	MOV	r4,#16			; draw all 16 lines of sprite
	MOV	r5,#0			; starting at line 0

	SUBS	r0,r3,r0,ASR#4		; y offset in pixels
	ADDLT	r4,r0,#16
	RSBLT	r5,r4,#16		; clip 16+y lines from top

	; Super clip test
	ADDS	r2,r0,#16               ; Completely off top?
	BLE	drawanenemy_exit
	CMP	r0,#vis_tiles_v*16      ; Completely off bottom?
	BGE	drawanenemy_exit

	CMP	r0,#(vis_tiles_v-1)*16	; Does sprite overlap bottom?
	ANDGT	r4,r0,#&f
	RSBGT	r4,r4,#16               ; Draw 16-(y&15) lines

	CMP	r0,#0
	MOVLT	r0,#0			; limit y offset to 0

	ADR	r2,drawanenemy_data
	LDMIA	r2,{r2,r3}
	LDR	r3,[r3,#0]		; load variables

	; Register status -
	;
	; r0	- offset in pixels from top of screen to start of enemy
	; r1	- address of enemy control block
	; r2	- address of enemy graphics data
	; r3	- screen memory start
	; r4	- number of pixel rows of sprite to draw
	; r5	- number of pixel rows of sprite to skip before drawing

	LDRB	r7,[r1,#10]		; enemy status
	TST	r7,#1<<3		; dying?
	BEQ	nme_not_dying

	LDR	r2,drawanenemy_data+12	; address of death animation
	LDRB	r7,[r1,#11]		; get animation frame
	LDR	r2,[r2,r7,LSL#2]	; look up data for that frame

	B	nme_animation_rendez

nme_not_dying
	LDRB	r7,[r1,#8]		; get enemy type
	LDR	r2,[r2,r7,LSL#2]	; look up animation start
	LDRB	r7,[r1,#11]		; get animation frame
	LDR	r2,[r2,r7,LSL#2]	; look up animation frame

	LDRB	r7,[r1,#10]		; get enemy status
	MOV	r7,r7,ASR#1
	AND	r7,r7,#3		; get enemy direction
	ADD	r2,r2,r7,LSL#8		; skip to sprite for that direction (16*16=256=<<8)

nme_animation_rendez
	ADD	r2,r2,r5,LSL#4		; clip top of sprite

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column

	; Register status
	;
	; r0	- Offset from top of screen to enemy, in pixels
	; r1	- Offset from left of screen to enemy, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#8
	ADD	r3,r3,r0,LSL#6		; move down screen to enemy position
	ADD	r3,r3,r1		; and across to enemy position

	MOV	r7,#255			; byte mask

drawanenemy_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	ANDS	r8,r7,r5		; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background

	ANDS	r8,r7,r6		; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background

	ANDS	r8,r7,r9		; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background

	ANDS	r8,r7,r10		; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

	ADD	r3,r3,#320
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	drawanenemy_pixel_line	; continue until done.

drawanenemy_exit

	LDMFD	r13!,{r0-r10,pc}	; restore regs and return

	IMPORT	nme_unit

draw_all_enemies_data
	DCD	nme_unit

draw_all_enemies
	EXPORT	draw_all_enemies

	; On entry, r0 = global_y.

	STMFD	r13!,{r1,r2,r3,r14}	; save regs

	LDR	r1,draw_all_enemies_data
	MOV	r2,#64

draw_all_enemies_loop
	LDRB	r3,[r1,#10]
	TST	r3,#1<<7		; does enemy exist?

	BLNE	drawanenemy		; yes - draw it

	ADD	r1,r1,#16		; go to next enemy entry

	SUBS	r2,r2,#1		; dec enemy counter
	BNE	draw_all_enemies_loop	; continue until all enemies have been drawn

	LDMFD	r13!,{r1,r2,r3,pc}	; restore regs, and return

;------------------------------------------------------------------------------
;
; Digital Symphony interface routines
;
;
;

dsym_load
	EXPORT	dsym_load

	; On entry,
	;	r0 points to filename

	STMFD	r13!,{r1-r4,r14}

	MOV	r2,#0
	MOV	r3,#0			; Load data into RMA
	MOV	r4,#0			; unpack buffer should use RMA

	SWI	dsym_swi_chunk		; "DSym_Load"

	; If error occurs, V is set

	MOVVS	r0,#1
	MOVVC	r0,#0			; set error code

	LDMFD	r13!,{r1-r4,pc}		; return


	IMPORT	sfx_table_with_mus
	IMPORT	sfx_table_no_mus
	IMPORT	global_audio_stat

dsym_playinstr_data
	DCD	sfx_table_with_mus
	DCD	global_audio_stat
	DCD	sfx_table_no_mus

dsym_playinstr
	EXPORT	dsym_playinstr

	; On entry, r0 contains sound effect number.
	STMFD	r13!,{r0-r6,r14}

	LDR	r1,dsym_playinstr_data+4
	LDR	r1,[r1,#0]
	TST	r1,#4			; sound effects enabled?
	LDMEQFD	r13!,{r0-r6,pc}

	; If game music is playing (on channels 0 and 1), sfx channel allocation
	; is restricted to channel 2 for bombs and 3 for everything else. This causes
	; some samples to be cut short. If the game music is disabled, use all four
	; channels for sound effects.
	TST	r1,#2			; game music enabled?
	LDRNE	r6,dsym_playinstr_data
	LDREQ	r6,dsym_playinstr_data+8

	ADD	r6,r6,r0,LSL#2		; Look up our sound effect

	LDRB	r0,[r6,#0]		; get channel number
	LDRB	r1,[r6,#1]		; get note number
	LDRB	r2,[r6,#2]		; get sample number

	MOV	r3,#0
	MOV	r4,#0			; No effect

	MOV	r5,#0			; min sustain time is 0

	MOV	r6,#0			; override currently playing sample

	SWI	dsym_swi_chunk+6	; "DSym_PlayInstr"

	LDMFD	r13!,{r0-r6,pc}		; return

dsym_start_song_cold
	EXPORT	dsym_start_song_cold

	STMFD	r13!,{r1}
	LDR	r1,dsym_playinstr_data+4
	LDR	r1,[r1,#0]
	TST	r1,#1			; menu music enabled?
	LDMFD	r13!,{r1}
	MOVEQ	pc,r14

	SWI	dsym_swi_chunk+1	; "DSym_RestartSong"

	MOV	pc,r14

dsym_song_info
	DCD	1,1
	DCD	2,10

dsym_start_song_warm
	EXPORT	dsym_start_song_warm
	; On entry, r0 contains the number of the song to start playing

	STMFD	r13!,{r0,r1,r2,r14}

	ADR	r2,dsym_song_info
	ADD	r2,r2,r0,LSL#3		; address of song details

	LDR	r1,[r2,#0]		; menu/game music enabled mask

	LDR	r0,dsym_playinstr_data+4
	LDR	r0,[r0,#0]
	TST	r0,r1			; is this music enabled?

	LDMEQFD	r13!,{r0,r1,r2,pc}	; no - go away

	LDR	r2,[r2,#4]		; get offset to start of song

	SWI	dsym_swi_chunk+1	; "DSym_RestartSong"

	MOV	r0,r2			; Sequence dictated by offset
	MOV	r1,#0			; Pattern position 0
	SWI	dsym_swi_chunk+&c	; "DSym_SongPos"

	LDMFD	r13!,{r0,r1,r2,pc}

dsym_stop_song
	EXPORT	dsym_stop_song

	STMFD	r13!,{r0,r1,r14}

	SWI	dsym_swi_chunk+&e	; "DSym_Pause"

	MOV	r0,#63
	SWI	dsym_swi_chunk+2	; Set volume back to default

	LDR	r1,dsym_vol_data
	STR	r0,[r1,#0]		; Tell the sound code we've reset the volume

	LDMFD	r13!,{r0,r1,pc}


	IMPORT	global_volume
dsym_vol_data
	DCD	global_volume

dsym_monitor_volume
	; Destination volume is passed in r0
	; Current volume is returned in r0

	EXPORT	dsym_monitor_volume

	STMFD	r13!,{r1,r2,r14}	; Store registers

	MOV	r2,r0

	MVN	r0,#0
	SWI	dsym_swi_chunk+2	; Read current volume

	LDR	r1,dsym_vol_data
	STR	r0,[r1,#0]		; store current volume

	CMP	r0,r2

	LDMEQFD	r13!,{r1,r2,pc}		; if volume is correct, leave.
	ADDLT	r0,r0,#1		; if too low, increase
	SUBGT	r0,r0,#1		; if too high, decrease

	SWI	dsym_swi_chunk+2	; "DSym_Vol"

	; Store new volume
	LDR	r1,dsym_vol_data
	STR	r0,[r1,#0]

	LDMFD	r13!,{r1,r2,pc}		; return

dsym_stereo_pos
	DCD	0
	DCD	0
	DCD	0
	DCD	0

dsym_get_stereo_positions
	EXPORT	dsym_get_stereo_positions

	; Read and record current (initial) stereo position values
	STMFD	r13!,{r0,r1,r14}

	; Just record settings for channels 2 and 3 for now...
	MOV	r0,#2			; channel 2
	MVN	r1,#127			; -128
	SWI	dsym_swi_chunk+3	; DSym_Stereo
	STR	r0,dsym_stereo_pos+8

	MOV	r0,#2			; channel 3
	MVN	r1,#127			; -128
	SWI	dsym_swi_chunk+3	; DSym_Stereo
	STR	r0,dsym_stereo_pos+12

	LDMFD	r13!,{r0,r1,pc}

dsym_set_stereo_for_menus
	; Channels 0..2 at preset positions, channel 3 at mid position
	EXPORT	dsym_set_stereo_for_menus

	STMFD	r13!,{r0,r1,r14}

	MOV	r0,#2			; channel 2
	LDR	r1,dsym_stereo_pos+8	; preset position
	SWI	dsym_swi_chunk+3	; DSym_Stereo

	MOV	r0,#3			; channel 3
	MOV	r1,#0			; mid point
	SWI	dsym_swi_chunk+3	; DSym_Stereo

	LDMFD	r13!,{r0,r1,pc}

dsym_set_stereo_for_game
	; Channels 0 and 1 at preset positions, channels 2 and 3 at mid position
	EXPORT	dsym_set_stereo_for_game

	STMFD	r13!,{r0,r1,r14}

	MOV	r0,#2			; channel 2
	MOV	r1,#0			; mid point
	SWI	dsym_swi_chunk+3	; DSym_Stereo

	MOV	r0,#3			; channel 3
	MOV	r1,#0			; mid point
	SWI	dsym_swi_chunk+3	; DSym_Stereo
	MOV	r0,#2

	LDMFD	r13!,{r0,r1,pc}

dsym_resetparams
	; Attempt to revive dsym module after wimp abuse
	EXPORT dsym_resetparams

	SWI	dsym_swi_chunk+7	; DSym_ResetParams

	MOV	pc,r14

;------------------------------------------------------------------------------
; Remove Digital Symphony player module

dsym_die_data
	DCB	"RMKILL DSymphonyPlayer"
	DCB	0

dsym_time_to_die
	EXPORT	dsym_time_to_die

	STMFD	r13!,{r0,r14}

	ADR	r0,dsym_die_data
	SWI	5			; OS_CLI

	LDMFD	r13!,{r0,pc}

;------------------------------------------------------------------------------
;
; Screen dump routine
;
; Dumps screen (through '*savescreen scrdump')
;

scrdump_data
	DCB	"screensave scrdump0"
	DCB	&0d

	ALIGN

scrdump
	EXPORT	scrdump

	STMFD	r13!,{r0,r14}

	ADR	r0,scrdump_data
	SWI	&20005			; XOS_CLI

	LDRB	r0,scrdump_data+18
	ADD	r0,r0,#1
	STRB	r0,scrdump_data+18

	LDMFD	r13!,{r0,pc}

scrblank_data
	DCB	"blanktime 0"
	DCB	&0d

	ALIGN

scrblanker_off
	EXPORT	scrblanker_off

	STMFD	r13!,{r0,r14}

	ADR	r0,scrblank_data
	SWI	&20005			; XOS_CLI

	LDMFD	r13!,{r0,pc}

;------------------------------------------------------------------------------
;
; Clear keyboard buffer with *fx 15,1
;

clear_keyboard
	EXPORT	clear_keyboard

	STMFD	r13!,{r0,r1,r14}

	MOV	r0,#15
	MOV	r1,#1
	SWI	6			; OS_BYTE

	LDMFD	r13!,{r0,r1,pc}

;------------------------------------------------------------------------------
;
; Mode 49 support
;

H_draw_floor_data
	DCD	floor_map
	DCD	floor_tiles
	DCD	scrmem_arena
	DCD	expl_gfx

H_draw_floor
	EXPORT H_draw_floor

	; parameters :
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - floorsize - vertical size of floor, in tiles.
	;	r2 - floor gfx address

	STMFD	r13!,{r0-r12,r14}	; Save regs

	ADR	r2,H_draw_floor_data
	LDMIA	r2,{r2,r3,r6}
	LDR	r6,[r6,#0]		; load variables

	ADD	r2,r2,#33*16		; skip sentinel tiles on map (TDC)

	; bottom 8 bits of global_y (r0) contain the fraction within a tile. The tiles are only
	; 16x16 pixels, so this gives us an accuracy to 1/16th of a pixel. If there is a hi-res
	; RPC mode (640x512) we can have 32x32 tiles, giving 1/8th pixel accuracy.

	MOV	r4,r0,LSR#4
	AND	r4,r4,#15		; get pixel offset within top row

	MOV	r0,r0,LSR#8		; get tile row offset

	MOV	r5,r4,LSL#4		; calc offset within single tile gfx

        ; r0 - first on screen tile row
	; r1 - max tile row
	; r2 - floor map data structure pointer
	; r3 - floor tiles gfx
	; r4 - pixel offset within tile
	; r5 - offset within gfx data to skip part of tile not on screen
	; r6 - start of screen memory

	; If the top row is not entirely visible (scroll is underway -> r4 != 0) draw top
	; row of tiles

	CMP	r4,#0                   ; no scroll ?
	MOVEQ	r7,#vis_tiles_v		; no - draw all vis_tiles_v rows
	BEQ	H_draw_floor_full_tiles	; and just draw those

	; draw partially visible top row

	STMFD	r13!,{r0,r1,r2,r4}	; free a few regs

	RSB	r4,r4,#16		; number of pixel lines to draw

	ADD	r2,r2,r0,LSL#9		; skip 32*16bytes per map line (TDC)

	MOV	r0,#vis_tiles_h		; tile count

	MOV	r7,r6			; save screen pointer

H_draw_floor_top_partial
	; r0  - tile counter
	; r2  - points to next map data entry
	; r3  - tile gfx data
	; r4  - number of pixel lines to draw
	; r5  - offset within tile pixel data to start reading from
	; r6  - screen memory pointer
	; r7  - screen pointer saved
	; r1,r8-r12,r14 free

	LDRB	r1,[r2,#1]		; load sprite reference number for next tile
	ADD	r1,r3,r1,LSL#8		; find address of that tiles pixel data
	ADD	r1,r1,r5		; skip top part of tile

	MOV	r8,r4			; line counter
	MOV	r14,r6			; screen pointer

H_partial_top_tile
	LDMIA	r1!,{r9-r12}		; load line of tile
	STMIA	r14,{r9-r12}		; write line to screen

	ADD	r14,r14,#640		; move down to next line

	SUBS	r8,r8,#1		; decrement line counter
	BNE	H_partial_top_tile	; continue until tile is complete

	LDRB	r1,[r2,#7]		; overlay sprite?
	CMP	r1,#0
	BEQ	H_partial_top_cont	; no - goto next tile

	; Ok, we've got to overlay an explosion sprite - what registers do we have?
	; r0  - tile counter
	; r1  - which sprite to overlay
	; r2  - points to next map data entry
	; r3  - tile gfx data
	; r4  - number of pixel lines to draw
	; r5  - offset within tile pixel data to start reading from
	; r6  - screen memory pointer
	; r7  - screen pointer saved
	; r1,r8-r12,r14 free

	LDR	r8,H_draw_floor_data+12	; get explosion overlay graphics address

	SUB	r1,r1,#64		; overlay counts from 64...
	ADD	r1,r8,r1,LSL#8		; 256 bytes per overlay
	ADD	r1,r1,r5		; skip hidden part of overlay

	STMFD	r13!,{r6,r7}		; free up two regs.

	MOV	r7,#255			; byte mask

	MOV	r8,r6			; screen addr
	MOV	r14,r4

H_drawpoverlay_pixel_line
	LDMIA	r1!,{r9-r12}		; get pixel line

	ANDS	r6,r7,r9		; get 1st pixel
	STRNEB	r6,[r8,#0]		; draw if not background

	ANDS	r6,r7,r9,LSR#8		; get 2nd pixel
	STRNEB	r6,[r8,#1]		; draw if not background

	ANDS	r6,r7,r9,LSR#16		; get 3rd pixel
	STRNEB	r6,[r8,#2]		; draw if not background

	ANDS	r6,r7,r9,LSR#24		; get 4th pixel
	STRNEB	r6,[r8,#3]		; draw if not background

	ANDS	r6,r7,r10		; get 5th pixel
	STRNEB	r6,[r8,#4]		; draw if not background

	ANDS	r6,r7,r10,LSR#8		; get 6th pixel
	STRNEB	r6,[r8,#5]		; draw if not background

	ANDS	r6,r7,r10,LSR#16	; get 7th pixel
	STRNEB	r6,[r8,#6]		; draw if not background

	ANDS	r6,r7,r10,LSR#24	; get 8th pixel
	STRNEB	r6,[r8,#7]		; draw if not background

	ANDS	r6,r7,r11		; get 9th pixel
	STRNEB	r6,[r8,#8]		; draw if not background

	ANDS	r6,r7,r11,LSR#8		; get 10th pixel
	STRNEB	r6,[r8,#9]		; draw if not background

	ANDS	r6,r7,r11,LSR#16	; get 11th pixel
	STRNEB	r6,[r8,#10]		; draw if not background

	ANDS	r6,r7,r11,LSR#24	; get 12th pixel
	STRNEB	r6,[r8,#11]		; draw if not background

	ANDS	r6,r7,r12		; get 13th pixel
	STRNEB	r6,[r8,#12]		; draw if not background

	ANDS	r6,r7,r12,LSR#8		; get 14th pixel
	STRNEB	r6,[r8,#13]		; draw if not background

	ANDS	r6,r7,r12,LSR#16	; get 15th pixel
	STRNEB	r6,[r8,#14]		; draw if not background

	ANDS	r6,r7,r12,LSR#24	; get 16th pixel
	STRNEB	r6,[r8,#15]		; draw if not background

	ADD	r8,r8,#640
	SUBS	r14,r14,#1		; finished row - any more?
	BNE	H_drawpoverlay_pixel_line	; continue until done.

	LDMFD	r13!,{r6,r7}


H_partial_top_cont
	ADD	r2,r2,#16		; move to next tile in map data (TDC)
	ADD	r6,r6,#16		; move to next tile on screen

	SUBS	r0,r0,#1		; decrement tile counter
	BNE	H_draw_floor_top_partial	; continue until top line is complete

	MOV	r6,r7
	ADD	r6,r6,r4,LSL#9
	ADD	r6,r6,r4,LSL#7		; set screen pointer to beginning of next tile row

	LDMFD	r13!,{r0,r1,r2,r4}	; restore regs

	ADD	r0,r0,#1		; move to next line on map

	MOV	r7,#vis_tiles_v-1	; one less full row than when no partial rows

H_draw_floor_full_tiles
	; r0 - tile row
	; r1 - max tile row	- what are we going to do with this...? Preprocess, I think!
	; r2 - floor map data structure pointer
	; r3 - floor tiles gfx
	; r4 - pixel offset within tile
	; r5 - offset within gfx data to skip part of tile not on screen
	; r6 - start of screen memory
	; r7 - number of full rows left to draw

	STMFD	r13!,{r0,r2,r4,r7}	; free a few regs

	MOV	r4,#16			; number of pixel lines to draw

	ADD	r2,r2,r0,LSL#9		; skip 32*16bytes per map line (TDC)

	MOV	r0,#vis_tiles_h		; tile count

	MOV	r7,r6			; save screen pointer

H_draw_floor_full_row
	LDRB	r1,[r2,#1]		; load sprite reference number for next tile
	ADD	r1,r3,r1,LSL#8		; find address of that tiles pixel data

	MOV	r8,r4			; line counter
	MOV	r14,r6			; screen pointer

H_full_tile_line
	LDMIA	r1!,{r9-r12}		; load line of tile
	STMIA	r14,{r9-r12}		; write line to screen

	ADD	r14,r14,#640		; move down to next line

	SUBS	r8,r8,#1		; decrement line counter
	BNE	H_full_tile_line	; continue until tile is complete

	LDRB	r1,[r2,#7]		; overlay sprite?
	CMP	r1,#0
	BEQ	H_full_cont		; no - goto next tile

	; Ok, we've got to overlay an explosion sprite - what registers do we have?
	; r0 - tile row
	; r1 - overlay sprite
	; r2 - floor map data structure pointer
	; r3 - floor tiles gfx
	; r4 - pixel offset within tile
	; r5 - offset within gfx data to skip part of tile not on screen
	; r6 - start of screen memory
	; r7 - number of full rows left to draw

	LDR	r8,H_draw_floor_data+12	; get explosion overlay graphics address

	SUB	r1,r1,#64		; overlay counts from 64...
	ADD	r1,r8,r1,LSL#8		; 256 bytes per overlay

	STMFD	r13!,{r6,r7}		; free up two regs.

	MOV	r7,#255			; byte mask

	MOV	r8,r6			; screen addr
	MOV	r14,r4

H_drawoverlay_pixel_line
	LDMIA	r1!,{r9-r12}		; get pixel line

	ANDS	r6,r7,r9		; get 1st pixel
	STRNEB	r6,[r8,#0]		; draw if not background

	ANDS	r6,r7,r9,LSR#8		; get 2nd pixel
	STRNEB	r6,[r8,#1]		; draw if not background

	ANDS	r6,r7,r9,LSR#16		; get 3rd pixel
	STRNEB	r6,[r8,#2]		; draw if not background

	ANDS	r6,r7,r9,LSR#24		; get 4th pixel
	STRNEB	r6,[r8,#3]		; draw if not background

	ANDS	r6,r7,r10		; get 5th pixel
	STRNEB	r6,[r8,#4]		; draw if not background

	ANDS	r6,r7,r10,LSR#8		; get 6th pixel
	STRNEB	r6,[r8,#5]		; draw if not background

	ANDS	r6,r7,r10,LSR#16	; get 7th pixel
	STRNEB	r6,[r8,#6]		; draw if not background

	ANDS	r6,r7,r10,LSR#24	; get 8th pixel
	STRNEB	r6,[r8,#7]		; draw if not background

	ANDS	r6,r7,r11		; get 9th pixel
	STRNEB	r6,[r8,#8]		; draw if not background

	ANDS	r6,r7,r11,LSR#8		; get 10th pixel
	STRNEB	r6,[r8,#9]		; draw if not background

	ANDS	r6,r7,r11,LSR#16	; get 11th pixel
	STRNEB	r6,[r8,#10]		; draw if not background

	ANDS	r6,r7,r11,LSR#24	; get 12th pixel
	STRNEB	r6,[r8,#11]		; draw if not background

	ANDS	r6,r7,r12		; get 13th pixel
	STRNEB	r6,[r8,#12]		; draw if not background

	ANDS	r6,r7,r12,LSR#8		; get 14th pixel
	STRNEB	r6,[r8,#13]		; draw if not background

	ANDS	r6,r7,r12,LSR#16	; get 15th pixel
	STRNEB	r6,[r8,#14]		; draw if not background

	ANDS	r6,r7,r12,LSR#24	; get 16th pixel
	STRNEB	r6,[r8,#15]		; draw if not background

	ADD	r8,r8,#640
	SUBS	r14,r14,#1		; finished row - any more?
	BNE	H_drawoverlay_pixel_line	; continue until done.

	LDMFD	r13!,{r6,r7}

H_full_cont
	ADD	r2,r2,#16		; move to next tile in map data (TDC)
	ADD	r6,r6,#16		; move to next tile on screen

	SUBS	r0,r0,#1		; decrement tile counter
	BNE	H_draw_floor_full_row	; continue until top line is complete

	MOV	r6,r7
	ADD	r6,r6,r4,LSL#9
	ADD	r6,r6,r4,LSL#7		; set screen pointer to beginning of next tile row

	LDMFD	r13!,{r0,r2,r4,r7}	; restore regs

	ADD	r0,r0,#1		; move to next row

	SUBS	r7,r7,#1		; decrement row counter
	BNE	H_draw_floor_full_tiles	; until there's no more rows to draw

	CMP	r4,#0			; any scroll?
	BEQ	H_draw_floor_exit	; no - go to exit

	; must draw partial bottom row
        ; r4 contains the number of pixel lines to draw

	ADD	r2,r2,r0,LSL#9		; skip 32*16bytes per map line (TDC)

	MOV	r0,#vis_tiles_h		; tile count

	MOV	r7,r6			; save screen pointer

H_draw_floor_bottom_row
	LDRB	r1,[r2,#1]		; load sprite reference number for next tile
	ADD	r1,r3,r1,LSL#8		; find address of that tiles pixel data

	MOV	r8,r4			; line counter
	MOV	r14,r6			; screen pointer

H_bottom_tile_line
	LDMIA	r1!,{r9-r12}		; load line of tile
	STMIA	r14,{r9-r12}		; write line to screen

	ADD	r14,r14,#640		; move down to next line

	SUBS	r8,r8,#1		; decrement line counter
	BNE	H_bottom_tile_line	; continue until tile is complete

	LDRB	r1,[r2,#7]		; overlay sprite?
	CMP	r1,#0
	BEQ	H_bottom_cont		; no - goto next tile

	; Ok, we've got to overlay an explosion sprite - what registers do we have?
	; r0 - tile row
	; r1 - overlay sprite
	; r2 - floor map data structure pointer
	; r3 - floor tiles gfx
	; r4 - pixel offset within tile
	; r5 - offset within gfx data to skip part of tile not on screen
	; r6 - start of screen memory
	; r7 - number of full rows left to draw

	LDR	r8,H_draw_floor_data+12	; get explosion overlay graphics address

	SUB	r1,r1,#64		; overlay counts from 64...
	ADD	r1,r8,r1,LSL#8		; 256 bytes per overlay

	STMFD	r13!,{r6,r7}		; free up two regs.

	MOV	r7,#255			; byte mask

	MOV	r8,r6			; screen addr
	MOV	r14,r4

H_drawboverlay_pixel_line
	LDMIA	r1!,{r9-r12}		; get pixel line

	ANDS	r6,r7,r9		; get 1st pixel
	STRNEB	r6,[r8,#0]		; draw if not background

	ANDS	r6,r7,r9,LSR#8		; get 2nd pixel
	STRNEB	r6,[r8,#1]		; draw if not background

	ANDS	r6,r7,r9,LSR#16		; get 3rd pixel
	STRNEB	r6,[r8,#2]		; draw if not background

	ANDS	r6,r7,r9,LSR#24		; get 4th pixel
	STRNEB	r6,[r8,#3]		; draw if not background

	ANDS	r6,r7,r10		; get 5th pixel
	STRNEB	r6,[r8,#4]		; draw if not background

	ANDS	r6,r7,r10,LSR#8		; get 6th pixel
	STRNEB	r6,[r8,#5]		; draw if not background

	ANDS	r6,r7,r10,LSR#16	; get 7th pixel
	STRNEB	r6,[r8,#6]		; draw if not background

	ANDS	r6,r7,r10,LSR#24	; get 8th pixel
	STRNEB	r6,[r8,#7]		; draw if not background

	ANDS	r6,r7,r11		; get 9th pixel
	STRNEB	r6,[r8,#8]		; draw if not background

	ANDS	r6,r7,r11,LSR#8		; get 10th pixel
	STRNEB	r6,[r8,#9]		; draw if not background

	ANDS	r6,r7,r11,LSR#16	; get 11th pixel
	STRNEB	r6,[r8,#10]		; draw if not background

	ANDS	r6,r7,r11,LSR#24	; get 12th pixel
	STRNEB	r6,[r8,#11]		; draw if not background

	ANDS	r6,r7,r12		; get 13th pixel
	STRNEB	r6,[r8,#12]		; draw if not background

	ANDS	r6,r7,r12,LSR#8		; get 14th pixel
	STRNEB	r6,[r8,#13]		; draw if not background

	ANDS	r6,r7,r12,LSR#16	; get 15th pixel
	STRNEB	r6,[r8,#14]		; draw if not background

	ANDS	r6,r7,r12,LSR#24	; get 16th pixel
	STRNEB	r6,[r8,#15]		; draw if not background

	ADD	r8,r8,#640
	SUBS	r14,r14,#1		; finished row - any more?
	BNE	H_drawboverlay_pixel_line	; continue until done.

	LDMFD	r13!,{r6,r7}

H_bottom_cont
	ADD	r2,r2,#16		; move to next tile in map data (TDC)
	ADD	r6,r6,#16		; move to next tile on screen

	SUBS	r0,r0,#1		; decrement tile counter
	BNE	H_draw_floor_bottom_row	; continue until top line is complete

H_draw_floor_exit
	; We've finished here -> let's exit

	LDMFD	r13!,{r0-r12,pc}

H_adv_exp_data
	DCD	floor_map
	DCD	scrmem_arena
	DCD	bexpl_gfx

H_draw_adv_exp
	EXPORT	H_draw_adv_exp

	STMFD	r13!,{r0-r12,r14}

	; On entry, r0 contains global_y

	BIC	r1,r0,#255
	SUB	r1,r1,#768

	; r1 = actual y big explosion will start drawing at

	MOV	r2,r0,ASR#8
	SUB	r2,r2,#1		; r2 = map tile row to start scan on

	ADR	r3,H_adv_exp_data
	LDMIA	r3,{r3-r5}		; load variables
	LDR	r4,[r4,#0]		; get screen address

	ADD	r3,r3,r2,LSL#9		; Move to start of map row
	MOV	r9,#(vis_tiles_v+2)	; Number of rows to scan

H_adv_scan_y
	MOV	r6,#vis_tiles_h+1
	MOV	r7,r3			; store current map row position

H_adv_scan_x
	LDRB	r8,[r3,#4]		; get blast details
	CMP	r8,#9+16		; explosion centre?

	;LDR	r12,plotdbug
	;ADD	r12,r12,#1
	;STR	r12,plotdbug		; test how many explosions are being drawn

	BLEQ	H_adv_exp_plot		; yes - draw it

	ADD	r3,r3,#16		; next tile
	SUBS	r6,r6,#1		; end of row?
	BNE	H_adv_scan_x		; no - continue loop

	ADD	r3,r7,#512		; move to next row
	ADD	r1,r1,#256
	SUBS	r9,r9,#1		; all necessary rows scanned?
	BNE	H_adv_scan_y		; no - continue loop

	; Scan and draw complete - exit

	LDMFD	r13!,{r0-r12,pc}

H_adv_exp_plot
	; On entry,
	;	r0  =	global_y
	;	r1  =	global_y scale position of top of big explosion
	;	r3  =	address of current tile data
	;	r4  =	screen memory start
	; 	r5  =	big explosion graphics data
	;	r6  =	vis_tiles_h-r6 = x position of tile on map
	;	r7  =   address of start of map row
	;	r9  =   no use here, but must be preserved
	;	r2, r8, r10-r12 = available for use
	;	r14 =   return address

	STMFD	r13!,{r1,r3,r4,r5,r6,r7,r9,r14}

	; Find start of pixel data

	RSB	r6,r6,#vis_tiles_h+1	; calc column number

	SUB	r6,r6,#1

	CMP	r6,#0
	CMPNE	r6,#vis_tiles_h-1	; left or rightmost column?

	MOVNE	r11,#48
	MOVEQ	r11,#32			; draw 2/3 if part off screen

	LDRB	r8,[r3,#5]		; blast frame number
	RSB	r8,r8,#20

	ADD	r2,r5,r8,LSL#12
	ADD	r2,r2,r8,LSL#9		; r2 = start address of blast frame

	CMP	r6,#0
	ADDEQ	r2,r2,#16*2		; clip left side if necessary
	SUBNE	r4,r4,#16		; otherwise, move back to centre explosion

	CMP	r1,r0
	BLT	H_adv_off_top

	; frame is not going off top of screen
	MOV	r9,#48                          ; default pixel rows to draw
	SUB	r8,r1,r0
	MOV	r8,r8,ASR#4
	CMP	r8,#((vis_tiles_v*16)-48)	; goes off bottom of screen?
	SUBGT	r10,r8,#((vis_tiles_v*16)-48)
	SUBGT	r9,r9,r10			; clipped pixel rows to draw

	ADD	r4,r4,r8,LSL#9
	ADD	r4,r4,r8,LSL#7			; Move down to start pixel row
	ADD	r4,r4,r6,LSL#4			; Move across to start column

	B	H_adv_start_draw

H_adv_off_top
	; frame is part way off top of screen
	SUB	r8,r0,r1
	MOV	r8,r8,ASR#4			; r8 pixel rows off top
	RSB	r9,r8,#48			; number of lines to draw

	ADD	r2,r2,r8,LSL#6
	ADD	r2,r2,r8,LSL#5			; skip pixel data

	ADD	r4,r4,r6,LSL#4			; move across to start row

H_adv_start_draw
	; r4 = screen address of point to start drawing
	; r2 = address of start of pixel data (after clipping)
	; r9 = number of rows to draw
	; r11 = width to draw
	; all other regs apart from r0 available for use

	CMP	r9,#0
	LDMLEFD	r13!,{r1,r3,r4,r5,r6,r7,r9,pc}	; Super clip if necessary

H_adv_draw_loop
	MOV	r10,r4			; screen address temp
	MOV	r12,r2			; pixel data temp

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 8

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 16

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 24

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 32

	CMP	r11,#48			; clip now?
	BLT	H_adv_next_line

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 40

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 48

H_adv_next_line
	ADD	r4,r4,#640		; move down screen 1 line
	ADD	r2,r2,#48*2		; move down pixel data 1 line

	SUBS	r9,r9,#1		; all lines done?
	BNE	H_adv_draw_loop

	; drawing is now complete. Restore regs and leave

	LDMFD	r13!,{r1,r3,r4,r5,r6,r7,r9,pc}

H_adv_flour_data
	DCD	scrmem_arena
	DCD	flour_gfx
	DCD	flour_array

H_draw_flour_exp
	EXPORT	H_draw_flour_exp

	STMFD	r13!,{r0-r12,r14}

	; On entry, r0 contains global_y

	MOV	r1,r0,ASR#8		; r1 = first row visible on screen
	SUB	r1,r1,#1		; big explosion can cover neighbouring rows
	ADD	r2,r1,#vis_tiles_v+2	; r2 = last row visible

	ADR	r4,H_adv_flour_data
	LDMIA	r4,{r4-r6}		; load variables
	LDR	r4,[r4,#0]		; get screen address

	MOV	r9,#64			; Number of possible explosions

H_flour_scan
	LDRB	r8,[r6,#2]		; get flour stats
	TST	r8,#1<<7		; exists?
	BEQ	H_no_flour_here		; apparently not

	LDRB	r8,[r6,#1]		; get flour y position
	CMP	r8,r1			; off top of screen?
	BLT	H_no_flour_here
	CMP	r8,r2			; off bottom of screen?
	BGE	H_no_flour_here

	LDRB	r7,[r6,#0]		; get x position
	BL	H_flour_exp_plot		; yes - draw it

H_no_flour_here
	ADD	r6,r6,#4
	SUBS	r9,r9,#1
	BNE	H_flour_scan

	; Scan and draw complete - exit

	LDMFD	r13!,{r0-r12,pc}

H_flour_exp_plot
	; On entry,
	;	r0  =	global_y
	;	r1  =	to be preserved
	;	r2  =	to be preserved
	;	r4  =	screen memory start
	; 	r5  =	big explosion graphics data
	;	r6  =	address of flour explosion control data
	;	r7  =   tile x position of flour explosion
	;	r8  =	tile y position of flour explosion
	;	r9  =   no use here, but must be preserved
	;	r3, r8, r10-r12 = available for use
	;	r14 =   return address

	STMFD	r13!,{r1,r2,r4,r5,r6,r7,r9,r14}

	; Find start of pixel data

	SUB	r8,r8,#2
	SUB	r7,r7,#1

	MOV	r1,r7

	CMP	r1,#0
	CMPNE	r1,#vis_tiles_h-1	; left or rightmost column?

	MOVNE	r11,#48
	MOVEQ	r11,#32			; draw 2/3 if part off screen

	LDRB	r6,[r6,#3]		; blast frame number
	RSB	r6,r6,#20

	ADD	r2,r5,r6,LSL#12
	ADD	r2,r2,r6,LSL#9		; r2 = start address of blast frame

	CMP	r1,#0
	ADDEQ	r2,r2,#16*2		; clip left side if necessary
	SUBNE	r4,r4,#16		; otherwise, move back to centre explosion

	CMP	r0,r8,LSL#8
	BGE	H_flour_off_top

	; frame is not going off top of screen
	MOV	r9,#48                          ; default pixel rows to draw
	RSB	r3,r0,r8,LSL#8			; exp_y - global_y
	MOV	r3,r3,ASR#4                     ; shifted to get pixel coords
	CMP	r3,#((vis_tiles_v*16)-48)	; goes off bottom of screen?
	SUBGT	r10,r3,#((vis_tiles_v*16)-48)
	SUBGT	r9,r9,r10			; clipped pixel rows to draw

	ADD	r4,r4,r3,LSL#9
	ADD	r4,r4,r3,LSL#7			; Move down to start pixel row
	ADD	r4,r4,r7,LSL#4			; Move across to start column

	B	H_flour_start_draw

H_flour_off_top
	; frame is part way off top of screen
	SUB	r3,r0,r8,LSL#8
	MOV	r3,r3,ASR#4			; r8 pixel rows off top
	RSB	r9,r3,#48			; number of lines to draw

	ADD	r2,r2,r3,LSL#6
	ADD	r2,r2,r3,LSL#5			; skip pixel data

	ADD	r4,r4,r7,LSL#4			; move across to start row

H_flour_start_draw
	; r4 = screen address of point to start drawing
	; r2 = address of start of pixel data (after clipping)
	; r9 = number of rows to draw
	; r11 = width to draw
	; all other regs apart from r0 available for use

	CMP	r9,#0
	LDMLEFD	r13!,{r1,r3,r4,r5,r6,r7,r9,pc}	; Super clip if necessary

H_flour_draw_loop
	MOV	r10,r4			; screen address temp
	MOV	r12,r2			; pixel data temp

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 8

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 16

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 24

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 32

	CMP	r11,#48			; clip now?
	BLT	H_flour_next_line

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 40

	LDMIA	r12!,{r1,r3,r5,r6}	; 8 pixels worth + masks
	LDMIA	r10,{r7,r8}		; 8 pixels from screen

	AND	r7,r7,r3
	AND	r8,r8,r6		; mask screen data

	ORR	r7,r7,r1
	ORR	r8,r8,r5		; insert new pixels

	STMIA	r10!,{r7,r8}		; store new screen data		= 48

H_flour_next_line
	ADD	r4,r4,#640		; move down screen 1 line
	ADD	r2,r2,#48*2		; move down pixel data 1 line

	SUBS	r9,r9,#1		; all lines done?
	BNE	H_flour_draw_loop

	; drawing is now complete. Restore regs and leave

	LDMFD	r13!,{r1,r3,r4,r5,r6,r7,r9,pc}

H_draw_icon_data
	DCD	menu_icon
	DCD	scrmem

H_draw_icon
	EXPORT	H_draw_icon

	; On entry,
	;	r0 - icon to draw
	;	r1,r2 - top left coord

	STMFD	r13!,{r0-r12,r14}

	LDR	r3,H_draw_icon_data	; address of sprite reference table
	ADD	r3,r3,r0,LSL#4		; 16 bytes per entry... r3 = our sprite

	LDMIA	r3,{r3,r5,r6}		; get width, height and sprite start address

	LDR	r4,H_draw_icon_data+4
	LDR	r4,[r4,#0]		; get screen address

	SUB	r2,r2,#16

	ADD	r4,r4,r2,LSL#9
	ADD	r4,r4,r2,LSL#7
	ADD	r4,r4,r1		; screen address to start drawing at

H_icon_draw_loop_y
	MOV	r10,r4			; screen address temp
	ADD	r8,r10,#320

	MOV	r11,r3			; width counter
H_icon_draw_loop_x
	LDMIA	r6!,{r1,r2}		; 4 pixels worth + masks
	LDMIA	r10,{r7}		; 4 pixels from screen

	AND	r7,r7,r2		; mask out parts of screen
	ORR	r7,r7,r1		; add in parts of icon

	STMIA	r10!,{r7}		; store new screen data

	LDMIA	r8,{r7}			; 4 pixels from screen

	AND	r7,r7,r2		; mask out parts of screen
	ORR	r7,r7,r1		; add in parts of icon

	STMIA	r8!,{r7}		; store new screen data

	SUBS	r11,r11,#4		; decrement x counter
	BGT	H_icon_draw_loop_x

	ADD	r4,r4,#640		; move down screen 1 line

	SUBS	r5,r5,#1		; all lines done?
	BNE	H_icon_draw_loop_y

	LDMFD	r13!,{r0-r12,pc}

H_drawaman_data
	DCD	action_table
	DCD	scrmem_arena
	DCD	plrpals

H_drawaman
	EXPORT	H_drawaman
	; On entry,
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - address of control block for man being drawn

	STMFD	r13!,{r0-r10,r14}	; save regs

	; is player dead?
	LDRB	r3,[r1,#11]		; player status
	MOV	r3,r3,LSR#4		; get action code
	CMP	r3,#5			; dying?
	BNE	H_drawaman_not_dying
	LDRB	r4,[r1,#13]
	CMP	r4,#255			; dying, and animctr==255 => dead
	LDMEQFD r13!,{r0-r10,pc}

H_drawaman_not_dying

	LDR	r3,[r1,#4]		; get player ypos.
	SUB	r3,r3,#1<<4		; Skip sentinel row

	; Offset in pixels from top of visible screen to man =
	;	man.ypos - (global_y>>4)

	MOV	r4,#16			; draw all 16 lines of sprite
	MOV	r5,#0			; starting at line 0

	SUBS	r0,r3,r0,ASR#4		; y offset in pixels
	ADDLT	r4,r0,#16
	RSBLT	r5,r4,#16		; clip 16+y lines from top

	; Super clip test
	ADDS	r2,r0,#16               ; Completely off top?
	BLE	H_drawaman_exit
	CMP	r0,#vis_tiles_v*16      ; Completely off bottom?
	BGE	H_drawaman_exit

	CMP	r0,#(vis_tiles_v-1)*16	; Does sprite overlap bottom?
	ANDGT	r4,r0,#&f
	RSBGT	r4,r4,#16               ; Draw 16-(y&15) lines

	CMP	r0,#0
	MOVLT	r0,#0			; limit y offset to 0

	ADR	r2,H_drawaman_data
	LDMIA	r2,{r2,r3,r14}
	LDR	r3,[r3,#0]		; load variables

	; Register status -
	;
	; r0	- offset in pixels from top of screen to start of man
	; r1	- address of player control block
	; r2	- address of player action array
	; r3	- screen memory start
	; r4	- number of pixel rows of sprite to draw
	; r5	- number of pixel rows of sprite to skip before drawing

	LDRB	r7,[r1,#11]		; get status
	MOV	r6,r7,LSR#4		; get action info

	; Coughing animation can not be passed through normal channels, as we need
	; to preserve the original action.
	LDRB	r8,[r1,#10]		; get extra flags
	TST	r8,#1<<5		; floured?
	BEQ	H_drawaman_not_floured

	; Floured, but has timer reached coughing fit stage?
	LDRB	r8,[r1,#16]		; get timer
	CMP	r8,#128			; coughing time?
	MOVLE	r6,#6			; yes, action = coughing

H_drawaman_not_floured
	LDR	r2,[r2,r6,LSL#2]	; Look up animation for this action

	LDRB	r6,[r1,#18]		; Get sprite_num field for player
	LDR	r2,[r2,r6,LSL#2]	; Look up sprite data for this frame

	MOV	r7,r7,LSR#1
	AND	r7,r7,#3		; get direction from status
	ADD	r2,r2,r7,LSL#8		; Offset to sprites for that direction

	; Player palette - this goes according to the colour field of this player
	; unless s/he is covered in flour, where it is set to 4 (white).

	LDRB	r7,[r1,#10]		; get extra flags
	TST	r7,#1<<5		; floured?
	MOVNE	r7,#4			; yes - colour player white
	LDREQB	r7,[r1,#14]		; no - get colour field for player
	ADD	r14,r14,r7,LSL#8	; Offset to this players palette

	ADD	r2,r2,r5,LSL#4		; clip top of sprite

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column

	; Register status
	;
	; r0	- Offset from top of screen to man, in pixels
	; r1	- Offset from left of screen to man, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#9
	ADD	r3,r3,r0,LSL#7		; move down screen to man position
	ADD	r3,r3,r1		; and across to man position

	MOV	r7,#255			; byte mask

H_drawaman_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	ANDS	r8,r7,r5		; get 1st pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#0]		; draw if not background

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#1]		; draw if not background

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#2]		; draw if not background

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#3]		; draw if not background

	ANDS	r8,r7,r6		; get 5th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#4]		; draw if not background

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#5]		; draw if not background

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#6]		; draw if not background

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#7]		; draw if not background

	ANDS	r8,r7,r9		; get 9th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#8]		; draw if not background

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#9]		; draw if not background

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#10]		; draw if not background

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#11]		; draw if not background

	ANDS	r8,r7,r10		; get 13th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#12]		; draw if not background

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#13]		; draw if not background

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#14]		; draw if not background

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	LDRNEB  r8,[r14,r8]		; palette look up
	STRNEB	r8,[r3,#15]		; draw if not background

	ADD	r3,r3,#640
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	H_drawaman_pixel_line	; continue until done.

H_drawaman_exit

	LDMFD	r13!,{r0-r10,pc}	; restore regs and return

;------------------------------------------------------------------------------

	IMPORT	bomb_gfx

H_drawabomb_anim
	DCB	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
	DCB	6,7,7,7,6,7,7,7,6,7,7,7,6,7,7,7
	DCB	6,6,7,7,6,6,7,7,6,6,7,7,6,6,7,7
	DCB	6,6,6,7,6,6,6,7,6,6,6,7,6,6,6,7
	DCB	5,6,6,6,5,6,6,6,5,6,6,6,5,6,6,6
	DCB	5,5,6,6,5,5,6,6,5,5,6,6,5,5,6,6
	DCB	5,5,5,6,5,5,5,6,5,5,5,6,5,5,5,6
	DCB	4,5,5,5,4,5,5,5,4,5,5,5,4,5,5,5
	DCB	4,4,5,5,4,4,5,5,4,4,5,5,4,4,5,5
	DCB	4,4,4,5,4,4,4,5,4,4,4,5,4,4,4,5
	DCB	3,4,4,4,3,4,4,4,3,4,4,4,3,4,4,4
	DCB	3,3,4,4,3,3,4,4,3,3,4,4,3,3,4,4
	DCB	3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,4
	DCB	2,3,3,3,2,3,3,3,2,3,3,3,2,3,3,3
	DCB	2,2,3,3,2,2,3,3,2,2,3,3,2,2,3,3
	DCB	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2

H_drawabomb_data
	DCD	bomb_gfx
	DCD	scrmem_arena
	DCD	0

H_drawabomb
	EXPORT	H_drawabomb
	; On entry,
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - address of control block for bomb being drawn

	STMFD	r13!,{r0-r10,r14}	; save regs

	STR	r0,H_drawabomb_data+8	; for future reference

	LDR	r3,[r1,#4]		; get bomb ypos.
	SUB	r3,r3,#1<<4		; Skip sentinel row

	; Offset in pixels from top of visible screen to bomb =
	;	bomb.ypos - (global_y>>4)

	MOV	r4,#16			; draw all 16 lines of sprite
	MOV	r5,#0			; starting at line 0

	SUBS	r0,r3,r0,ASR#4		; y offset in pixels
	ADDLT	r4,r0,#16
	RSBLT	r5,r4,#16		; clip 16+y lines from top

	; Super clip test
	ADDS	r2,r0,#16               ; Completely off top?
	BLE	H_drawabomb_exit
	CMP	r0,#vis_tiles_v*16      ; Completely off bottom?
	BGE	H_drawabomb_exit

	CMP	r0,#(vis_tiles_v-1)*16	; Does sprite overlap bottom?
	ANDGT	r4,r0,#&f
	RSBGT	r4,r4,#16               ; Draw 16-(y&15) lines

	CMP	r0,#0
	MOVLT	r0,#0			; limit y offset to 0

	ADR	r2,H_drawabomb_data
	LDMIA	r2,{r2,r3}
	LDR	r3,[r3,#0]		; load variables

	; Register status -
	;
	; r0	- offset in pixels from top of screen to start of bomb
	; r1	- address of bomb control block
	; r2	- address of bomb graphics data
	; r3	- screen memory start
	; r4	- number of pixel rows of sprite to draw
	; r5	- number of pixel rows of sprite to skip before drawing

	LDRB	r6,[r1,#9]		; Get timer
	ADR	r7,H_drawabomb_anim
	LDRB	r6,[r7,r6]		; grow bomb as timer goes down
	LDRB	r7,[r1,#10]		; get bomb type
	CMP	r7,#3
	MOVEQ	r7,#0			; bouncing bombs look like normal bombs (at the mo)
	ADD	r6,r6,r7,LSL#3
	LDRB	r7,[r1,#8]		; Get owner field for bomb colour

	CMP	r7,#255			; CPU bomb?
	MOVEQ	r7,#0			; yes - use player 1's colour

	; sprite addr = r2 + 256*frame + (32*256)*colour

	ADD	r2,r2,r6,LSL#8
	ADD	r2,r2,r7,LSL#13		; start of sprite

	LDRB	r7,[r1,#11]		; get bomb status
	TST	r7,#1<<3		; is bomb in air?
	BEQ	H_bomb_on_ground	; no - branch
	BL	H_bomb_shadow		; yes - draw shadow
	BL	H_bomb_clipped		; and clipped bomb
	B	H_drawabomb_exit

H_bomb_on_ground
	ADD	r2,r2,r5,LSL#4		; clip top of sprite

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column

	; Register status
	;
	; r0	- Offset from top of screen to bomb, in pixels
	; r1	- Offset from left of screen to bomb, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#9
	ADD	r3,r3,r0,LSL#7		; move down screen to bomb position
	ADD	r3,r3,r1		; and across to bomb position

	MOV	r7,#255			; byte mask

H_drawabomb_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	ANDS	r8,r7,r5		; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background

	ANDS	r8,r7,r6		; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background

	ANDS	r8,r7,r9		; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background

	ANDS	r8,r7,r10		; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

	ADD	r3,r3,#640
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	H_drawabomb_pixel_line	; continue until done.

H_drawabomb_exit

	LDMFD	r13!,{r0-r10,pc}	; restore regs and return

H_bomb_shadow
	STMFD	r13!,{r0-r4,r11,r12,r14}

	ADRL	r7,bomb_arc
	LDRB	r8,[r1,#13]		; get zpos index
	LDRB	r8,[r7,r8]		; get 'height'

	LDR	r4,[r1,#4]		; ypos
	LDR	r0,H_drawabomb_data+8	; global_y
	SUB	r0,r4,r0,ASR#4

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column
	SUB	r0,r0,#1<<4

	ADD	r0,r0,r8
	SUB	r1,r1,r8		; move shadow from bomb

	; Clip shadow to game area
	MOV	r4,#16			; rows to draw
	MOV	r11,#16			; columns to draw
	MOV	r12,#0			; columns to skip

	CMP	r1,#0                   ; off left?
	BGE	H_clipshad_right
	RSB	r5,r1,#0
	CMP	r5,#16			; completely off left?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	MOV	r12,r5
	RSB	r11,r12,#16
	B	H_clipshad_top

H_clipshad_right
	CMP	r1,#16*(vis_tiles_h-1) ; going off right?
	BLE	H_clipshad_top
	CMP	r1,#16*vis_tiles_h	; completely off right?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
        RSB	r11,r1,#16*vis_tiles_h

H_clipshad_top
	CMP	r0,#0			; going off top?
	BGE	H_clipshad_bottom
	RSB	r6,r0,#0
	CMP	r6,#16			; completely off top?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r6,#16
	ADD	r2,r2,r6,LSL#4
	MOV	r0,#0
	B	H_shadclip_done

H_clipshad_bottom
	CMP	r0,#16*(vis_tiles_v-1)	; going off bottom?
	BLE	H_shadclip_done
	CMP	r0,#16*vis_tiles_v	; completely off bottom?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r0,#16*vis_tiles_v

H_shadclip_done

	; Register status
	;
	; r0	- Offset from top of screen to bomb, in pixels
	; r1	- Offset from left of screen to bomb, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#9
	ADD	r3,r3,r0,LSL#7		; move down screen to bomb position
	ADD	r3,r3,r1		; and across to bomb position

	MOV	r7,#255			; byte mask
	MOV	r8,#0			; black pixel

	ADR	r0,H_drawabombshadow_pixels

H_drawabombshadow_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	MOV	r14,r11

	ADD	pc,r0,r12,LSL#4		; 4 instructions per pixel

H_drawabombshadow_pixels
	TST	r7,r5			; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r6			; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r9			; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r10			; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r10,LSR#16		; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_shadow_line_done

	TST	r7,r10,LSR#24		; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

H_shadow_line_done
	ADD	r3,r3,#640
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	H_drawabombshadow_pixel_line	; continue until done.

	LDMFD	r13!,{r0-r4,r11,r12,pc}		; restore regs and return

H_bomb_clipped
	STMFD	r13!,{r0-r4,r11,r12,r14}

	LDR	r4,[r1,#4]		; ypos
	LDR	r0,H_drawabomb_data+8	; global_y
	SUB	r0,r4,r0,ASR#4

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column
	SUB	r0,r0,#1<<4

	; Clip bomb to game area
	MOV	r4,#16			; rows to draw
	MOV	r11,#16			; columns to draw
	MOV	r12,#0			; columns to skip

	CMP	r1,#0                   ; off left?
	BGE	H_clipbomb_right
	RSB	r5,r1,#0
	CMP	r5,#16			; completely off left?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	MOV	r12,r5
	RSB	r11,r12,#16
	B	H_clipbomb_top

H_clipbomb_right
	CMP	r1,#16*(vis_tiles_h-1) ; going off right?
	BLE	H_clipbomb_top
	CMP	r1,#16*vis_tiles_h	; completely off right?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
        RSB	r11,r1,#16*vis_tiles_h

H_clipbomb_top
	CMP	r0,#0			; going off top?
	BGE	H_clipbomb_bottom
	RSB	r6,r0,#0
	CMP	r6,#16			; completely off top?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r6,#16
	ADD	r2,r2,r6,LSL#4
	MOV	r0,#0
	B	H_bombclip_done

H_clipbomb_bottom
	CMP	r0,#16*(vis_tiles_v-1)	; going off bottom?
	BLE	H_bombclip_done
	CMP	r0,#16*vis_tiles_v	; completely off bottom?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r0,#16*vis_tiles_v

H_bombclip_done

	; Register status
	;
	; r0	- Offset from top of screen to bomb, in pixels
	; r1	- Offset from left of screen to bomb, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#9
	ADD	r3,r3,r0,LSL#7		; move down screen to bomb position
	ADD	r3,r3,r1		; and across to bomb position

	MOV	r7,#255			; byte mask

	ADR	r0,H_drawaclipbomb_pixels

H_drawaclipbomb_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	MOV	r14,r11

	ADD	pc,r0,r12,LSL#4		; 4 instructions per pixel

H_drawaclipbomb_pixels
	ANDS	r8,r7,r5		; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r6		; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r9		; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r10		; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbomb_line_done

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

H_clipbomb_line_done
	ADD	r3,r3,#640
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	H_drawaclipbomb_pixel_line	; continue until done.

	LDMFD	r13!,{r0-r4,r11,r12,pc}		; restore regs and return

	;SWI	263
	;SWI	263
	;SWI	263
	;SWI	263
	;SWI	263
	DCD	&deadbeeb


	IMPORT	bombs

H_draw_all_bombs_data
	DCD	bombs

H_draw_all_bombs
	EXPORT	H_draw_all_bombs

	; On entry, r0 = global_y.

	STMFD	r13!,{r1,r2,r3,r14}	; save regs

	LDR	r1,H_draw_all_bombs_data
	MOV	r2,#64

H_draw_all_bombs_loop
	LDRB	r3,[r1,#11]
	TST	r3,#1<<4		; does bomb exist?

	BLNE	H_drawabomb		; yes - draw it

	ADD	r1,r1,#16		; go to next bomb entry

	SUBS	r2,r2,#1		; dec bomb counter
	BNE	H_draw_all_bombs_loop	; continue until all bombs have been drawn

	LDMFD	r13!,{r1,r2,r3,pc}	; restore regs, and return

H_bonus_arc				; just like bomb_arc funnily enough.
	DCB	0,7,12,16,20,22,25,28,30,32,33,34,34
	DCB	34,33,32,30,28,25,22,20,16,12,7
	DCB	0,4,8,10,12,10,8,4,0

	ALIGN

	IMPORT	flip_bonus

H_drawabonus_data
	DCD	flip_bonus
	DCD	scrmem_arena

H_drawabonus
	EXPORT	H_drawabonus
	; On entry,
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - address of control block for bonus being drawn

	STMFD	r13!,{r0-r10,r14}	; save regs

	ADR	r2,H_drawabonus_data
	LDMIA	r2,{r2,r3}
	LDR	r3,[r3,#0]		; load variables

	; Register status -
	;
	; r0	- offset in pixels from top of screen to start of bonus
	; r1	- address of bonus control block
	; r2	- address of bonus graphics data
	; r3	- screen memory start
	; r4	- number of pixel rows of sprite to draw
	; r5	- number of pixel rows of sprite to skip before drawing

	LDRB	r6,[r1,#3]		; Get anim_ctr
	AND	r6,r6,#7
	LDRB	r7,[r1,#2]
	MOV	r7,r7,ASR#1
	AND	r7,r7,#3		; get direction

	ADD	r2,r2,r7,LSL#5		; 32 bytes of pointers per direction
	LDR	r2,[r2,r6,LSL#2]	; get address of sprite to use

	BL	H_bonus_shadow		; yes - draw shadow
	BL	H_bonus_clipped		; and clipped bonus
	B	H_drawabonus_exit

H_drawabonus_exit

	LDMFD	r13!,{r0-r10,pc}	; restore regs and return

H_bonus_shadow
	STMFD	r13!,{r0-r4,r11,r12,r14}

	ADRL	r7,H_bonus_arc
	LDRB	r8,[r1,#3]		; get zpos index
	LDRB	r8,[r7,r8]		; get 'height'

	LDRB	r4,[r1,#1]		; ypos
	MOV	r4,r4,LSL#1
	SUB	r0,r4,r0,ASR#4		; subtract global y

	LDRB	r1,[r1,#0]		; read player xpos
	MOV	r1,r1,LSL#1
	SUB	r1,r1,#1<<4		; skip sentinel column
	SUB	r0,r0,#1<<4

	ADD	r0,r0,r8
	SUB	r1,r1,r8		; move shadow from bonus

	; Clip shadow to game area
	MOV	r4,#16			; rows to draw
	MOV	r11,#16			; columns to draw
	MOV	r12,#0			; columns to skip

	CMP	r1,#0                   ; off left?
	BGE	H_bclipshad_right
	RSB	r5,r1,#0
	CMP	r5,#16			; completely off left?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	MOV	r12,r5
	RSB	r11,r12,#16
	B	bclipshad_top

H_bclipshad_right
	CMP	r1,#16*(vis_tiles_h-1) ; going off right?
	BLE	H_bclipshad_top
	CMP	r1,#16*vis_tiles_h	; completely off right?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
        RSB	r11,r1,#16*vis_tiles_h

H_bclipshad_top
	CMP	r0,#0			; going off top?
	BGE	H_bclipshad_bottom
	RSB	r6,r0,#0
	CMP	r6,#16			; completely off top?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r6,#16
	ADD	r2,r2,r6,LSL#4
	MOV	r0,#0
	B	H_bshadclip_done

H_bclipshad_bottom
	CMP	r0,#16*(vis_tiles_v-1)	; going off bottom?
	BLE	H_bshadclip_done
	CMP	r0,#16*vis_tiles_v	; completely off bottom?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r0,#16*vis_tiles_v

H_bshadclip_done

	; Register status
	;
	; r0	- Offset from top of screen to bonus, in pixels
	; r1	- Offset from left of screen to bonus, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#9
	ADD	r3,r3,r0,LSL#7		; move down screen to bonus position
	ADD	r3,r3,r1		; and across to bonus position

	MOV	r7,#255			; byte mask
	MOV	r8,#0			; black pixel

	ADR	r0,H_drawabonusshadow_pixels

H_drawabonusshadow_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	MOV	r14,r11

	ADD	pc,r0,r12,LSL#4		; 4 instructions per pixel

H_drawabonusshadow_pixels
	TST	r7,r5			; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r6			; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r9			; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r10			; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r10,LSR#16		; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_bshadow_line_done

	TST	r7,r10,LSR#24		; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

H_bshadow_line_done
	ADD	r3,r3,#640
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	H_drawabonusshadow_pixel_line	; continue until done.

	LDMFD	r13!,{r0-r4,r11,r12,pc}		; restore regs and return

H_bonus_clipped
	STMFD	r13!,{r0-r4,r11,r12,r14}

	LDRB	r4,[r1,#1]		; ypos
	MOV	r4,r4,LSL#1
	SUB	r0,r4,r0,ASR#4		; subtract global y

	LDRB	r1,[r1,#0]		; read player xpos
	MOV	r1,r1,LSL#1
	SUB	r1,r1,#1<<4		; skip sentinel column
	SUB	r0,r0,#1<<4

	; Clip bomb to game area
	MOV	r4,#16			; rows to draw
	MOV	r11,#16			; columns to draw
	MOV	r12,#0			; columns to skip

	CMP	r1,#0                   ; off left?
	BGE	H_clipbonus_right
	RSB	r5,r1,#0
	CMP	r5,#16			; completely off left?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	MOV	r12,r5
	RSB	r11,r12,#16
	B	H_clipbonus_top

H_clipbonus_right
	CMP	r1,#16*(vis_tiles_h-1) ; going off right?
	BLE	H_clipbonus_top
	CMP	r1,#16*vis_tiles_h	; completely off right?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
        RSB	r11,r1,#16*vis_tiles_h

H_clipbonus_top
	CMP	r0,#0			; going off top?
	BGE	H_clipbonus_bottom
	RSB	r6,r0,#0
	CMP	r6,#16			; completely off top?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r6,#16
	ADD	r2,r2,r6,LSL#4
	MOV	r0,#0
	B	H_bonusclip_done

H_clipbonus_bottom
	CMP	r0,#16*(vis_tiles_v-1)	; going off bottom?
	BLE	H_bonusclip_done
	CMP	r0,#16*vis_tiles_v	; completely off bottom?
	LDMGEFD	r13!,{r0-r4,r11,r12,pc}
	RSB	r4,r0,#16*vis_tiles_v

H_bonusclip_done

	; Register status
	;
	; r0	- Offset from top of screen to bonus, in pixels
	; r1	- Offset from left of screen to bonus, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#9
	ADD	r3,r3,r0,LSL#7		; move down screen to bonus position
	ADD	r3,r3,r1		; and across to bonus position

	MOV	r7,#255			; byte mask

	ADR	r0,H_drawaclipbonus_pixels

H_drawaclipbonus_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	MOV	r14,r11

	ADD	pc,r0,r12,LSL#4		; 4 instructions per pixel

H_drawaclipbonus_pixels
	ANDS	r8,r7,r5		; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r6		; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r9		; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r10		; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background
	SUBS	r14,r14,#1
	BEQ	H_clipbonus_line_done

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

H_clipbonus_line_done
	ADD	r3,r3,#640
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	H_drawaclipbonus_pixel_line	; continue until done.

	LDMFD	r13!,{r0-r4,r11,r12,pc}		; restore regs and return

	DCD	&deadbeeb


	IMPORT	bonus_array

H_draw_all_bonuses_data
	DCD	bonus_array

H_draw_all_bonuses
	EXPORT	H_draw_all_bonuses

	; On entry, r0 = global_y.

	STMFD	r13!,{r1,r2,r3,r14}	; save regs

	LDR	r1,H_draw_all_bonuses_data
	MOV	r2,#128

H_draw_all_bonuses_loop
	LDRB	r3,[r1,#2]
	TST	r3,#1<<7		; does bonus exist?

	BEQ	H_skip_this_bonus		; no - jump

	TST	r3,#1			; is bonus moving?

	BLNE	H_drawabonus		; yes - draw it

H_skip_this_bonus
	ADD	r1,r1,#4		; go to next bonus entry

	SUBS	r2,r2,#1		; dec bonus counter
	BNE	H_draw_all_bonuses_loop	; continue until all bonuses have been drawn

	LDMFD	r13!,{r1,r2,r3,pc}	; restore regs, and return

H_draw_string_data
	DCD	font_wid
	DCD	scrmem
	DCD	compiler_sprite_font

H_draw_string_cols
	DCB	3,44,46,0
	DCB	7,23,55,0
	DCB	35,67,99,0
	DCB	81,117,246,0
	DCB	128,139,203,0
	DCB	27,151,223,0
	DCB	162,201,249,0
	DCB	47,211,255,0

H_draw_string
	EXPORT	H_draw_string
	; r0 = address of string, terminated by 0
	; r1 = xpos
	; r2 = ypos
	; r3 = col

	STMFD	r13!,{r3-r12,r14}

	MOV	r7,r0			; move string pointer

	SUB	r1,r1,#1
	SUB	r2,r2,#16

	ADR	r4,H_draw_string_data
	LDMIA	r4,{r4-r6}

	LDR	r5,[r5,#0]		; address of screen memory

	ADD	r5,r5,r2,LSL#9
	ADD	r5,r5,r2,LSL#7
	ADD	r5,r5,r1		; Screen address of start of string

	; Set up colours
	ADR	r8,H_draw_string_cols
	ADD	r8,r8,r3,LSL#2		; find entry in colour table

	LDRB	r1,[r8,#0]		; dark
	LDRB	r2,[r8,#1]		; medium
	LDRB	r3,[r8,#2]		; light

H_draw_string_char_loop
	LDRB	r8,[r7],#1		; Get next character

	CMP	r8,#0			; End of string?
	LDMEQFD	r13!,{r3-r12,pc}	; yes - we're done here

	SUB	r8,r8,#32		; font starts at space

	MOV	r0,r5			; Load character screen address

	LDRB	r9,[r4,r8]		; get width
	ADD	r9,r9,#1		; 1 pixel gap between chars

	ADD	r5,r5,r9		; move on for next char

	ADR	r14,H_draw_string_char_loop ; we want to return here
	LDR	pc,[r6,r8,LSL#2]	; jump to character draw routine

H_draw_char
	EXPORT	H_draw_char
	; r0 = ascii character
	; r1 = xpos
	; r2 = ypos
	; r3 = col

	STMFD	r13!,{r3-r12,r14}

	MOV	r7,r0			; move character

	SUB	r1,r1,#1
	SUB	r2,r2,#16

	ADR	r4,H_draw_string_data
	LDMIA	r4,{r4-r6}

	LDR	r5,[r5,#0]		; address of screen memory

	ADD	r5,r5,r2,LSL#9
	ADD	r5,r5,r2,LSL#7
	ADD	r5,r5,r1		; Screen address of start of char

	; Set up colours
	ADR	r8,H_draw_string_cols
	ADD	r8,r8,r3,LSL#2		; find entry in colour table

	LDRB	r1,[r8,#0]		; dark
	LDRB	r2,[r8,#1]		; medium
	LDRB	r3,[r8,#2]		; light

	SUB	r7,r7,#32		; font starts at space

	MOV	r0,r5			; Load character screen address

	ADR	r14,H_draw_char_end	; we want to return here
	LDR	pc,[r6,r7,LSL#2]	; jump to character draw routine

H_draw_char_end
	LDMFD	r13!,{r3-r12,pc}


H_draw_string_highlight
	EXPORT	H_draw_string_highlight
	; r0 = address of string, terminated by 0
	; r1 = xpos
	; r2 = ypos
	; r3 = pixel colour

	STMFD	r13!,{r3-r12,r14}

	MOV	r7,r0			; move string pointer

	SUB	r1,r1,#1
	SUB	r2,r2,#16

	ADR	r4,H_draw_string_data
	LDMIA	r4,{r4-r6}

	LDR	r5,[r5,#0]		; address of screen memory

	ADD	r5,r5,r2,LSL#9
	ADD	r5,r5,r2,LSL#7
	ADD	r5,r5,r1		; Screen address of start of string

	; Set up colours
	MOV	r1,r3
	MOV	r2,r3

H_draw_hl_string_char_loop
	LDRB	r8,[r7],#1		; Get next character

	CMP	r8,#0			; End of string?
	LDMEQFD	r13!,{r3-r12,pc}	; yes - we're done here

	SUB	r8,r8,#32		; font starts at space

	MOV	r0,r5			; Load character screen address

	LDRB	r9,[r4,r8]		; get width
	ADD	r9,r9,#1		; 1 pixel gap between chars

	ADD	r5,r5,r9		; move on for next char

	ADR	r14,H_draw_hl_string_char_loop ; we want to return here
	LDR	pc,[r6,r8,LSL#2]	; jump to character draw routine

H_draw_menu_data
	DCD	flour_gfx		; used for storing menu background
	DCD	scrmem
	DCD	240			; loop counter

H_draw_menu_screen
	EXPORT	H_draw_menu_screen

	STMFD	r13!,{r0-r11,r14}

	ADR	r0,H_draw_menu_data
	LDMIA	r0,{r0-r2}
	LDR	r1,[r1,#0]
	ADD	r11,r1,#320

H_menu_copy_loop
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}
	LDMIA	r0!,{r3-r10}
	STMIA	r1!,{r3-r10}
	STMIA	r11!,{r3-r10}

	ADD	r1,r1,#320
	ADD	r11,r11,#320

	SUBS	r2,r2,#1
	BNE	H_menu_copy_loop

	LDMFD	r13!,{r0-r11,pc}

H_draw_black_screen_data
	DCD	scrmem

H_draw_black_screen
	EXPORT	H_draw_black_screen

	STMFD	r13!,{r0-r5,r14}

	MOV	r0,#0
	MOV	r1,#0
	MOV	r2,#0
	MOV	r3,#0			; black pixel data

	LDR	r4,H_draw_black_screen_data
	LDR	r4,[r4,#0]              ; screen address

	MOV	r5,#(320*480)/(4*4*4)	; loop counter

H_draw_black_screen_loop
	STMIA	r4!,{r0-r3}
	STMIA	r4!,{r0-r3}
	STMIA	r4!,{r0-r3}
	STMIA	r4!,{r0-r3}		; blat 4*4*4 black pixels

	SUBS	r5,r5,#1
	BNE	H_draw_black_screen_loop	; continue for whole screen

	LDMFD	r13!,{r0-r5,pc}		; return

H_drawanenemy_data
	DCD	enemy_anims
	DCD	scrmem_arena
	DCD	0
	DCD	nme_death_anim

H_drawanenemy
	EXPORT	H_drawanenemy
	; On entry,
	;	r0 - global_y - offset of top of visible floor from top of actual floor.
	;	r1 - address of control block for enemy being drawn

	STMFD	r13!,{r0-r10,r14}	; save regs

	STR	r0,H_drawanenemy_data+8	; for future reference

	LDR	r3,[r1,#4]		; get enemy ypos.
	SUB	r3,r3,#1<<4		; Skip sentinel row

	; Offset in pixels from top of visible screen to enemy =
	;	enemy.ypos - (global_y>>4)

	MOV	r4,#16			; draw all 16 lines of sprite
	MOV	r5,#0			; starting at line 0

	SUBS	r0,r3,r0,ASR#4		; y offset in pixels
	ADDLT	r4,r0,#16
	RSBLT	r5,r4,#16		; clip 16+y lines from top

	; Super clip test
	ADDS	r2,r0,#16               ; Completely off top?
	BLE	H_drawanenemy_exit
	CMP	r0,#vis_tiles_v*16      ; Completely off bottom?
	BGE	H_drawanenemy_exit

	CMP	r0,#(vis_tiles_v-1)*16	; Does sprite overlap bottom?
	ANDGT	r4,r0,#&f
	RSBGT	r4,r4,#16               ; Draw 16-(y&15) lines

	CMP	r0,#0
	MOVLT	r0,#0			; limit y offset to 0

	ADR	r2,H_drawanenemy_data
	LDMIA	r2,{r2,r3}
	LDR	r3,[r3,#0]		; load variables

	; Register status -
	;
	; r0	- offset in pixels from top of screen to start of enemy
	; r1	- address of enemy control block
	; r2	- address of enemy graphics data
	; r3	- screen memory start
	; r4	- number of pixel rows of sprite to draw
	; r5	- number of pixel rows of sprite to skip before drawing

	LDRB	r7,[r1,#10]		; enemy status
	TST	r7,#1<<3		; dying?
	BEQ	H_nme_not_dying

	LDR	r2,H_drawanenemy_data+12	; address of death animation
	LDRB	r7,[r1,#11]		; get animation frame
	LDR	r2,[r2,r7,LSL#2]	; look up data for that frame

	B	H_nme_animation_rendez

H_nme_not_dying
	LDRB	r7,[r1,#8]		; get enemy type
	LDR	r2,[r2,r7,LSL#2]	; look up animation start
	LDRB	r7,[r1,#11]		; get animation frame
	LDR	r2,[r2,r7,LSL#2]	; look up animation frame

	LDRB	r7,[r1,#10]		; get enemy status
	MOV	r7,r7,ASR#1
	AND	r7,r7,#3		; get enemy direction
	ADD	r2,r2,r7,LSL#8		; skip to sprite for that direction (16*16=256=<<8)

H_nme_animation_rendez
	ADD	r2,r2,r5,LSL#4		; clip top of sprite

	LDR	r1,[r1,#0]		; read player xpos
	SUB	r1,r1,#1<<4		; skip sentinel column

	; Register status
	;
	; r0	- Offset from top of screen to enemy, in pixels
	; r1	- Offset from left of screen to enemy, in pixels
	; r2	- Address of sprite pixel data
	; r3	- start of screen memory
	; r4	- number of pixel lines to draw

	ADD	r3,r3,r0,LSL#9
	ADD	r3,r3,r0,LSL#7		; move down screen to enemy position
	ADD	r3,r3,r1		; and across to enemy position

	MOV	r7,#255			; byte mask

H_drawanenemy_pixel_line
	LDMIA	r2!,{r5,r6,r9,r10}	; get pixel line

	ANDS	r8,r7,r5		; get 1st pixel
	STRNEB	r8,[r3,#0]		; draw if not background

	ANDS	r8,r7,r5,LSR#8		; get 2nd pixel
	STRNEB	r8,[r3,#1]		; draw if not background

	ANDS	r8,r7,r5,LSR#16		; get 3rd pixel
	STRNEB	r8,[r3,#2]		; draw if not background

	ANDS	r8,r7,r5,LSR#24		; get 4th pixel
	STRNEB	r8,[r3,#3]		; draw if not background

	ANDS	r8,r7,r6		; get 5th pixel
	STRNEB	r8,[r3,#4]		; draw if not background

	ANDS	r8,r7,r6,LSR#8		; get 6th pixel
	STRNEB	r8,[r3,#5]		; draw if not background

	ANDS	r8,r7,r6,LSR#16		; get 7th pixel
	STRNEB	r8,[r3,#6]		; draw if not background

	ANDS	r8,r7,r6,LSR#24		; get 8th pixel
	STRNEB	r8,[r3,#7]		; draw if not background

	ANDS	r8,r7,r9		; get 9th pixel
	STRNEB	r8,[r3,#8]		; draw if not background

	ANDS	r8,r7,r9,LSR#8		; get 10th pixel
	STRNEB	r8,[r3,#9]		; draw if not background

	ANDS	r8,r7,r9,LSR#16		; get 11th pixel
	STRNEB	r8,[r3,#10]		; draw if not background

	ANDS	r8,r7,r9,LSR#24		; get 12th pixel
	STRNEB	r8,[r3,#11]		; draw if not background

	ANDS	r8,r7,r10		; get 13th pixel
	STRNEB	r8,[r3,#12]		; draw if not background

	ANDS	r8,r7,r10,LSR#8		; get 14th pixel
	STRNEB	r8,[r3,#13]		; draw if not background

	ANDS	r8,r7,r10,LSR#16	; get 15th pixel
	STRNEB	r8,[r3,#14]		; draw if not background

	ANDS	r8,r7,r10,LSR#24	; get 16th pixel
	STRNEB	r8,[r3,#15]		; draw if not background

	ADD	r3,r3,#640
	SUBS	r4,r4,#1		; finished row - any more?
	BNE	H_drawanenemy_pixel_line	; continue until done.

H_drawanenemy_exit

	LDMFD	r13!,{r0-r10,pc}	; restore regs and return

	IMPORT	nme_unit

H_draw_all_enemies_data
	DCD	nme_unit

H_draw_all_enemies
	EXPORT	H_draw_all_enemies

	; On entry, r0 = global_y.

	STMFD	r13!,{r1,r2,r3,r14}	; save regs

	LDR	r1,H_draw_all_enemies_data
	MOV	r2,#64

H_draw_all_enemies_loop
	LDRB	r3,[r1,#10]
	TST	r3,#1<<7		; does enemy exist?

	BLNE	H_drawanenemy		; yes - draw it

	ADD	r1,r1,#16		; go to next enemy entry

	SUBS	r2,r2,#1		; dec enemy counter
	BNE	H_draw_all_enemies_loop	; continue until all enemies have been drawn

	LDMFD	r13!,{r1,r2,r3,pc}	; restore regs, and return

;------------------------------------------------------------------------------
; Duplicate every other line to scale screen to mode 49

m49_scale_data
	DCD	scrmem_arena

mode_49_scale
	EXPORT	mode_49_scale

	STMFD	r13!,{r0-r12,r14}

	LDR	r0,m49_scale_data
	LDR	r0,[r0,#0]		; get screen address
	ADD	r1,r0,#320		; next line address

	MOV	r12,#vis_tiles_v*16
m49_loop
	LDMIA	r0!,{r2-r11}
	STMIA	r1!,{r2-r11}
	LDMIA	r0!,{r2-r11}
	STMIA	r1!,{r2-r11}
	LDMIA	r0!,{r2-r11}
	STMIA	r1!,{r2-r11}
	LDMIA	r0!,{r2-r11}
	STMIA	r1!,{r2-r11}
	LDMIA	r0!,{r2-r11}
	STMIA	r1!,{r2-r11}
	LDMIA	r0!,{r2-r11}
	STMIA	r1!,{r2-r11}
	LDMIA	r0!,{r2-r11}
	STMIA	r1!,{r2-r11}
	LDMIA	r0!,{r2-r7}
	STMIA	r1!,{r2-r7}

	ADD	r0,r0,#320+16
	ADD	r1,r1,#320+16

	SUBS	r12,r12,#1
	BNE	m49_loop

	LDMFD	r13!,{r0-r12,pc}

slink_init
	EXPORT	slink_init

	; Set receive/transmit speed to 9600 baud

	STMFD	r13!,{r0-r4,r14}

	MOV	r0,#0
	MOV	r1,#2
	MVN	r2,#255
	SWI	&57

	MOV	r0,#1
	MOV	r1,#0

	SWI	&57

	MOV	r0,#5
	MOV	r1,#8

	SWI	&57			; OS_SerialOp 5 (RX=9600)

	MOV	r0,#6
	MOV	r1,#8

	SWI	&57			; OS_SerialOp 6 (TX=9600)

	MOV	r0,#2
	MOV	r1,#2

	SWI	6			; OS_Byte 2 (i/p stream = key+serial)

	LDMFD	r13!,{r0-r4,pc}		; return

slink_close
	EXPORT	slink_close

	STMFD	r13!,{r0,r1,r14}

	MOV	r0,#2
	MOV	r1,#0

	SWI	6			; disable serial input

	MOV	r0,#3
	MOV	r1,#0

	SWI	6			; disable serial output

	LDMFD	r13!,{r0,r1,pc}

slink_input_buffer_empty
	EXPORT	slink_input_buffer_empty

	; Returns 1 if empty, 0 if not empty

	STMFD	r13!,{r1,r14}

	MOV	r0,#152
	MOV	r1,#1			; RS423 input

	SWI	6			; OS_Byte 152

	MOVCS	r0,#1			; r0 = 1 if buffer empty
	MOVCC	r0,#0			; r0 = 0 if not

	LDMFD	r13!,{r1,pc}

slink_output_buffer_empty
	EXPORT	slink_output_buffer_empty

	; Returns 1 is empty, 0 if not empty

	STMFD	r13!,{r1,r14}

	MOV	r0,#152
	MOV	r1,#2			; RS423 output

	SWI	6			; OS_Byte 152

	MOVCS	r0,#1			; r0 = 1 if buffer empty
	MOVCC	r0,#0			; r0 = 0 if not

	LDMFD	r13!,{r1,pc}

slink_send_byte
	EXPORT	slink_send_byte

	; On entry, r0 contains byte to be sent
	; On exit, returns 1 if successful, 0 if buffer full

	STMFD	r13!,{r1,r10,r14}

	MOV	r10,r0

	MOV	r0,#3
	MOV	r1,#1

	SWI	6			; OS_Byte 3 (o/p stream += serial)

	MOV	r1,r10
	MOV	r0,#3

	SWI	&57			; OS_SerialOp 3 (send byte)

	MOVCS	r10,#1			; Byte sent
	MOVCC	r10,#0			; Buffer full

	MOV	r0,#3
	MOV	r1,#0

	SWI	6			; OS_Byte 3 (o/p stream -= serial)

	MOV	r0,r10

	LDMFD	r13!,{r1,r10,pc}

slink_read_byte
	EXPORT	slink_read_byte

	; Returns a byte from the serial input buffer

	STMFD	r13!,{r1,r10,r14}

	MOV	r0,#2
	MOV	r1,#1
	SWI	6			; OS_Byte 2 (enable serial i/p)

	MOV	r0,#4

	SWI	&57			; OS_SerialOp 4 (read byte)

	MOV	r10,r1			; remember byte

	MOV	r0,#2
	MOV	r1,#2
	SWI	6

	MOV	r0,r10

	LDMFD	r13!,{r1,r10,pc}

slink_flush_input_buffer
	EXPORT	slink_flush_input_buffer

	STMFD	r13!,{r0,r1,r2,r14}

	MOV	r0,#21
	MOV	r1,#1

	SWI	6

	LDMFD	r13!,{r0,r1,r2,pc}

slink_flush_output_buffer
	EXPORT	slink_flush_output_buffer

	STMFD	r13!,{r0,r1,r2,r14}

	MOV	r0,#21
	MOV	r1,#2

	SWI	6

	LDMFD	r13!,{r0,r1,r2,pc}

is_escape_condition
	EXPORT	is_escape_condition

	STMFD	r13!,{r14}

	SWI	&2c			; OS_ReadEscapeState

	MOVCS	r0,#1
	MOVCC	r0,#0

	LDMFD	r13!,{pc}

ack_escape_condition
	EXPORT	ack_escape_condition

	STMFD	r13!,{r0-r2,r14}

	MOV	r0,#124
	SWI	6			; OS_Byte 124

	LDMFD	r13!,{r0-r2,r14}

;------------------------------------------------------------------------------
; Cause !Help file to be opened

launch_help_data
	DCB	"Filer_run <Mars$Dir>.!Help"
	DCB	0

launch_help
	EXPORT	launch_help

	STMFD	r13!,{r0,r14}

	ADR	r0,launch_help_data
	SWI	5			; OS_CLI

	LDMFD	r13!,{r0,pc}

;------------------------------------------------------------------------------
; Stop game-on module confusing screen set up

nobble_gameon_data
	DCB	"Arcscreenoff"
	DCB	0

nobble_gameon
	EXPORT	nobble_gameon

	STMFD	r13!,{r0,r14}

	ADR	r0,nobble_gameon_data
	SWI	&20005			; XOS_CLI

	LDMFD	r13!,{r0,pc}











		END
